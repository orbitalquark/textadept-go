Abs cmplx.Abs(x complex128) float64\nAbs returns the absolute value (also called the modulus) of x.
Abs filepath.Abs(path string) (string, error)\nAbs returns an absolute representation of path. If the path is not absolute\nit will be joined with the current working directory to turn it into an\nabsolute path. The absolute path name for a given file is not guaranteed to\nbe unique. Abs calls Clean on the result.
Abs math.Abs(x float64) float64\nAbs returns the absolute value of x.\nSpecial cases are:\nAbs(±Inf) = +Inf\nAbs(NaN) = NaN
Accept TCPListener.Accept() (Conn, error)\n
Accept UnixListener.Accept() (Conn, error)\n
AcceptTCP TCPListener.AcceptTCP() (*TCPConn, error)\n
AcceptUnix UnixListener.AcceptUnix() (*UnixConn, error)\n
Acos cmplx.Acos(x complex128) complex128\nAcos returns the inverse cosine of x.
Acos math.Acos(x float64) float64\nAcos returns the arccosine, in radians, of x.\nSpecial case is:\nAcos(x) = NaN if x < -1 or x > 1
Acosh cmplx.Acosh(x complex128) complex128\nAcosh returns the inverse hyperbolic cosine of x.
Acosh math.Acosh(x float64) float64\nAcosh returns the inverse hyperbolic cosine of x.\nSpecial cases are:\nAcosh(+Inf) = +Inf\nAcosh(x) = NaN if x < 1\nAcosh(NaN) = NaN
ActionNode parse.ActionNode\nActionNode holds an action (something bounded by delimiters). Control\nactions have their own nodes; ActionNode represents simple ones such as\nfield evaluations and parenthesized pipelines.\n
Add ChainNode.Add(field string)\n
Add Time.Add(d Duration) Time\n
Add WaitGroup.Add(delta int)\n
AddCookie Request.AddCookie(c *Cookie)\n
AddDate Time.AddDate(years int, months int, days int) Time\n
AddParseTree Template.AddParseTree(name string, tree *parse.Tree) (*Template, error)\n
AddParseTree Template.AddParseTree(name string, tree *parse.Tree) (*Template, error)\n
Addr TCPListener.Addr() Addr\n
Addr UnixListener.Addr() Addr\n
Addr net.Addr\nAddr represents a network end point address.\n\nThe two methods Network and String conventionally return strings that can be\npassed as the arguments to Dial, but the exact form and meaning of the\nstrings is up to the implementation.\n
AddrError net.AddrError\n
Addrs Interface.Addrs() ([]Addr, error)\n
After Time.After(u Time) bool\n
After time.After(d Duration) <-chan Time\nAfter waits for the duration to elapse and then sends the current time on\nthe returned channel. It is equivalent to NewTimer(d).C. The underlying\nTimer is not recovered by the garbage collector until the timer fires. If\nefficiency is a concern, use NewTimer instead and call Timer.Stop if the\ntimer is no longer needed.
AfterFunc Timer.AfterFunc(d Duration, f func()) *Timer\n
AfterFunc time.AfterFunc(d Duration, f func()) *Timer\nAfterFunc waits for the duration to elapse and then calls f in its own\ngoroutine. It returns a Timer that can be used to cancel the call using its\nStop method.
AllocedBytesPerOp BenchmarkResult.AllocedBytesPerOp() int64\n
AllocsPerOp BenchmarkResult.AllocsPerOp() int64\n
AllocsPerRun testing.AllocsPerRun(runs int, f func()) (avg float64)\nAllocsPerRun returns the average number of allocations during calls to f.\nAlthough the return value has type float64, it will always be an integral\nvalue.\nTo compute the number of allocations, the function will first be run once as\na warm-up. The average number of allocations over the specified number of\nruns will then be measured and returned.\nAllocsPerRun sets GOMAXPROCS to 1 during its measurement and will restore it\nbefore returning.
AllowQuerySemicolons Handler.AllowQuerySemicolons(h Handler) Handler\n
AllowQuerySemicolons http.AllowQuerySemicolons(h Handler) Handler\nAllowQuerySemicolons returns a handler that serves requests by converting\nany unescaped semicolons in the URL query to ampersands, and invoking the\nhandler h.\nThis restores the pre-Go 1.17 behavior of splitting query parameters on both\nsemicolons and ampersands. (See golang.org/issue/25192). Note that this\nbehavior doesn't match that of many proxies, and the mismatch can lead to\nsecurity issues.\nAllowQuerySemicolons should be invoked before Request.ParseForm is called.
AppendBool strconv.AppendBool(dst []byte, b bool) []byte\nAppendBool appends "true" or "false", according to the value of b, to dst\nand returns the extended buffer.
AppendFloat strconv.AppendFloat(dst []byte, f float64, fmt byte, prec, bitSize int) []byte\nAppendFloat appends the string form of the floating-point number f, as\ngenerated by FormatFloat, to dst and returns the extended buffer.
AppendFormat Time.AppendFormat(b []byte, layout string) []byte\n
AppendInt strconv.AppendInt(dst []byte, i int64, base int) []byte\nAppendInt appends the string form of the integer i, as generated by\nFormatInt, to dst and returns the extended buffer.
AppendQuote strconv.AppendQuote(dst []byte, s string) []byte\nAppendQuote appends a double-quoted Go string literal representing s, as\ngenerated by Quote, to dst and returns the extended buffer.
AppendQuoteRune strconv.AppendQuoteRune(dst []byte, r rune) []byte\nAppendQuoteRune appends a single-quoted Go character literal representing\nthe rune, as generated by QuoteRune, to dst and returns the extended buffer.
AppendQuoteRuneToASCII strconv.AppendQuoteRuneToASCII(dst []byte, r rune) []byte\nAppendQuoteRuneToASCII appends a single-quoted Go character literal\nrepresenting the rune, as generated by QuoteRuneToASCII, to dst and returns\nthe extended buffer.
AppendQuoteRuneToGraphic strconv.AppendQuoteRuneToGraphic(dst []byte, r rune) []byte\nAppendQuoteRuneToGraphic appends a single-quoted Go character literal\nrepresenting the rune, as generated by QuoteRuneToGraphic, to dst and\nreturns the extended buffer.
AppendQuoteToASCII strconv.AppendQuoteToASCII(dst []byte, s string) []byte\nAppendQuoteToASCII appends a double-quoted Go string literal representing s,\nas generated by QuoteToASCII, to dst and returns the extended buffer.
AppendQuoteToGraphic strconv.AppendQuoteToGraphic(dst []byte, s string) []byte\nAppendQuoteToGraphic appends a double-quoted Go string literal representing\ns, as generated by QuoteToGraphic, to dst and returns the extended buffer.
AppendUint strconv.AppendUint(dst []byte, i uint64, base int) []byte\nAppendUint appends the string form of the unsigned integer i, as generated\nby FormatUint, to dst and returns the extended buffer.
Arg FlagSet.Arg(i int) string\n
Arg flag.Arg(i int) string\nArg returns the i'th command-line argument. Arg(0) is the first remaining\nargument after flags have been processed. Arg returns an empty string if the\nrequested element does not exist.
Args FlagSet.Args() []string\n
Args flag.Args() []string\nArgs returns the non-flag command-line arguments.
As errors.As(err error, target interface{}) bool\nAs finds the first error in err's chain that matches target, and if so, sets\ntarget to that error value and returns true. Otherwise, it returns false.\nThe chain consists of err itself followed by the sequence of errors obtained\nby repeatedly calling Unwrap.\nAn error matches target if the error's concrete value is assignable to the\nvalue pointed to by target, or if the error has a method As(interface{})\nbool such that As(target) returns true. In the latter case, the As method is\nresponsible for setting target.\nAn error type might provide an As method so it can be treated as if it were\na different error type.\nAs panics if target is not a non-nil pointer to either a type that\nimplements error, or to any interface type.
Asin cmplx.Asin(x complex128) complex128\nAsin returns the inverse sine of x.
Asin math.Asin(x float64) float64\nAsin returns the arcsine, in radians, of x.\nSpecial cases are:\nAsin(±0) = ±0\nAsin(x) = NaN if x < -1 or x > 1
Asinh cmplx.Asinh(x complex128) complex128\nAsinh returns the inverse hyperbolic sine of x.
Asinh math.Asinh(x float64) float64\nAsinh returns the inverse hyperbolic sine of x.\nSpecial cases are:\nAsinh(±0) = ±0\nAsinh(±Inf) = ±Inf\nAsinh(NaN) = NaN
Atan cmplx.Atan(x complex128) complex128\nAtan returns the inverse tangent of x.
Atan math.Atan(x float64) float64\nAtan returns the arctangent, in radians, of x.\nSpecial cases are:\nAtan(±0) = ±0\nAtan(±Inf) = ±Pi/2
Atan2 math.Atan2(y, x float64) float64\nAtan2 returns the arc tangent of y/x, using the signs of the two to\ndetermine the quadrant of the return value.\nSpecial cases are (in order):\nAtan2(y, NaN) = NaN\nAtan2(NaN, x) = NaN\nAtan2(+0, x>=0) = +0\nAtan2(-0, x>=0) = -0\nAtan2(+0, x<=-0) = +Pi\nAtan2(-0, x<=-0) = -Pi\nAtan2(y>0, 0) = +Pi/2\nAtan2(y<0, 0) = -Pi/2\nAtan2(+Inf, +Inf) = +Pi/4\nAtan2(-Inf, +Inf) = -Pi/4\nAtan2(+Inf, -Inf) = 3Pi/4\nAtan2(-Inf, -Inf) = -3Pi/4\nAtan2(y, +Inf) = 0\nAtan2(y>0, -Inf) = +Pi\nAtan2(y<0, -Inf) = -Pi\nAtan2(+Inf, x) = +Pi/2\nAtan2(-Inf, x) = -Pi/2
Atanh cmplx.Atanh(x complex128) complex128\nAtanh returns the inverse hyperbolic tangent of x.
Atanh math.Atanh(x float64) float64\nAtanh returns the inverse hyperbolic tangent of x.\nSpecial cases are:\nAtanh(1) = +Inf\nAtanh(±0) = ±0\nAtanh(-1) = -Inf\nAtanh(x) = NaN if x < -1 or x > 1\nAtanh(NaN) = NaN
Atoi strconv.Atoi(s string) (int, error)\nAtoi is equivalent to ParseInt(s, 10, 0), converted to type int.
Attr xml.Attr\nAn Attr represents an attribute in an XML element (Name=Value).\n
Available Writer.Available() int\n
B testing.B\nB is a type passed to Benchmark functions to manage benchmark timing and to\nspecify the number of iterations to run.\n\nA benchmark ends when its Benchmark function returns or calls any of the\nmethods FailNow, Fatal, Fatalf, SkipNow, Skip, or Skipf. Those methods must\nbe called only from the goroutine running the Benchmark function. The other\nreporting methods, such as the variations of Log and Error, may be called\nsimultaneously from multiple goroutines.\n\nLike in tests, benchmark logs are accumulated during execution and dumped to\nstandard output when done. Unlike in tests, benchmark logs are always\nprinted, so as not to hide output whose existence may be affecting benchmark\nresults.\n
Base filepath.Base(path string) string\nBase returns the last element of path. Trailing path separators are removed\nbefore extracting the last element. If the path is empty, Base returns ".".\nIf the path consists entirely of separators, Base returns a single\nseparator.
Base path.Base(path string) string\nBase returns the last element of path. Trailing slashes are removed before\nextracting the last element. If the path is empty, Base returns ".". If the\npath consists entirely of slashes, Base returns "/".
BasicAuth Request.BasicAuth() (username, password string, ok bool)\n
Before Time.Before(u Time) bool\n
Benchmark BenchmarkResult.Benchmark(f func(b *B)) BenchmarkResult\n
Benchmark testing.Benchmark(f func(b *B)) BenchmarkResult\nBenchmark benchmarks a single function. It is useful for creating custom\nbenchmarks that do not use the "go test" command.\nIf f depends on testing flags, then Init must be used to register those\nflags before calling Benchmark and before calling flag.Parse.\nIf f calls Run, the result will be an estimate of running all its\nsubbenchmarks that don't call Run in sequence in a single benchmark.
BenchmarkResult testing.BenchmarkResult\nBenchmarkResult contains the results of a benchmark run.\n
BinaryMarshaler encoding.BinaryMarshaler\nBinaryMarshaler is the interface implemented by an object that can marshal\nitself into a binary form.\n\nMarshalBinary encodes the receiver into a binary form and returns the\nresult.\n
BinaryUnmarshaler encoding.BinaryUnmarshaler\nBinaryUnmarshaler is the interface implemented by an object that can\nunmarshal a binary representation of itself.\n\nUnmarshalBinary must be able to decode the form generated by MarshalBinary.\nUnmarshalBinary must copy the data if it wishes to retain the data after\nreturning.\n
BlockProfile runtime.BlockProfile(p []BlockProfileRecord) (n int, ok bool)\nBlockProfile returns n, the number of records in the current blocking\nprofile. If len(p) >= n, BlockProfile copies the profile into p and returns\nn, true. If len(p) < n, BlockProfile does not change p and returns n, false.\nMost clients should use the runtime/pprof package or the testing package's\n-test.blockprofile flag instead of calling BlockProfile directly.
BlockProfileRecord runtime.BlockProfileRecord\nBlockProfileRecord describes blocking events originated at a particular call\nsequence (stack trace).\n
Bool FlagSet.Bool(name string, value bool, usage string) *bool\n
Bool flag.Bool(name string, value bool, usage string) *bool\nBool defines a bool flag with specified name, default value, and usage\nstring. The return value is the address of a bool variable that stores the\nvalue of the flag.
BoolNode parse.BoolNode\nBoolNode holds a boolean constant.\n
BoolVar FlagSet.BoolVar(p *bool, name string, value bool, usage string)\n
BoolVar flag.BoolVar(p *bool, name string, value bool, usage string)\nBoolVar defines a bool flag with specified name, default value, and usage\nstring. The argument p points to a bool variable in which to store the value\nof the flag.
BranchNode parse.BranchNode\nBranchNode is the common representation of if, range, and with.\n
Breakpoint runtime.Breakpoint()\nBreakpoint executes a breakpoint trap.
Broadcast Cond.Broadcast()\n
Buffer Scanner.Buffer(buf []byte, max int)\n
Buffer bytes.Buffer\nA Buffer is a variable-sized buffer of bytes with Read and Write methods.\nThe zero value for Buffer is an empty buffer ready to use.\n
Buffered Decoder.Buffered() io.Reader\n
Buffered Reader.Buffered() int\n
Buffered Writer.Buffered() int\n
Builder strings.Builder\nA Builder is used to efficiently build a string using Write methods. It\nminimizes memory copying. The zero value is ready to use. Do not copy a\nnon-zero Builder.\n
ByteOrder binary.ByteOrder\nA ByteOrder specifies how to convert byte sequences into 16-, 32-, or 64-bit\nunsigned integers.\n
ByteReader io.ByteReader\nByteReader is the interface that wraps the ReadByte method.\n\nReadByte reads and returns the next byte from the input or any error\nencountered. If ReadByte returns an error, no input byte was consumed, and\nthe returned byte value is undefined.\n\nReadByte provides an efficient interface for byte-at-time processing. A\nReader that does not implement ByteReader can be wrapped using\nbufio.NewReader to add this method.\n
ByteScanner io.ByteScanner\nByteScanner is the interface that adds the UnreadByte method to the basic\nReadByte method.\n\nUnreadByte causes the next call to ReadByte to return the same byte as the\nprevious call to ReadByte. It may be an error to call UnreadByte twice\nwithout an intervening call to ReadByte.\n
ByteWriter io.ByteWriter\nByteWriter is the interface that wraps the WriteByte method.\n
Bytes Buffer.Bytes() []byte\n
Bytes Scanner.Bytes() []byte\n
CIDRMask net.CIDRMask(ones, bits int) IPMask\nCIDRMask returns an IPMask consisting of 'ones' 1 bits followed by 0s up to\na total length of 'bits' bits. For a mask of this form, CIDRMask is the\ninverse of IPMask.Size.
CPUProfile runtime.CPUProfile() []byte\nCPUProfile panics. It formerly provided raw access to chunks of a\npprof-format profile generated by the runtime. The details of generating\nthat format have changed, so this functionality has been removed.\nDeprecated: Use the runtime/pprof package, or the handlers in the\nnet/http/pprof package, or the testing package's -test.cpuprofile flag\ninstead.
Caller runtime.Caller(skip int) (pc uintptr, file string, line int, ok bool)\nCaller reports file and line number information about function invocations\non the calling goroutine's stack. The argument skip is the number of stack\nframes to ascend, with 0 identifying the caller of Caller. (For historical\nreasons the meaning of skip differs between Caller and Callers.) The return\nvalues report the program counter, file name, and line number within the\nfile of the corresponding call. The boolean ok is false if it was not\npossible to recover the information.
Callers runtime.Callers(skip int, pc []uintptr) int\nCallers fills the slice pc with the return program counters of function\ninvocations on the calling goroutine's stack. The argument skip is the\nnumber of stack frames to skip before recording in pc, with 0 identifying\nthe frame for Callers itself and 1 identifying the caller of Callers. It\nreturns the number of entries written to pc.\nTo translate these PCs into symbolic information such as function names and\nline numbers, use CallersFrames. CallersFrames accounts for inlined\nfunctions and adjusts the return program counters into call program\ncounters. Iterating over the returned slice of PCs directly is discouraged,\nas is using FuncForPC on any of the returned PCs, since these cannot account\nfor inlining or return program counter adjustment.
CallersFrames Frames.CallersFrames(callers []uintptr) *Frames\n
CallersFrames runtime.CallersFrames(callers []uintptr) *Frames\nCallersFrames takes a slice of PC values returned by Callers and prepares to\nreturn function/file/line information. Do not change the slice until you are\ndone with the Frames.
CanBackquote strconv.CanBackquote(s string) bool\nCanBackquote reports whether the string s can be represented unchanged as a\nsingle-line backquoted string without control characters other than tab.
CancelRequest Transport.CancelRequest(req *Request)\n
CanonicalHeaderKey http.CanonicalHeaderKey(s string) string\nCanonicalHeaderKey returns the canonical format of the header key s. The\ncanonicalization converts the first letter and any letter following a hyphen\nto upper case; the rest are converted to lowercase. For example, the\ncanonical key for "accept-encoding" is "Accept-Encoding". If s contains a\nspace or invalid header field bytes, it is returned without modifications.
Cap Buffer.Cap() int\n
Cap Builder.Cap() int\n
CapNames Regexp.CapNames() []string\n
CaseRange unicode.CaseRange\nCaseRange represents a range of Unicode code points for simple (one code\npoint to one code point) case conversion. The range runs from Lo to Hi\ninclusive, with a fixed stride of 1. Deltas are the number to add to the\ncode point to reach the code point for a different case for that character.\nThey may be negative. If zero, it means the character is in the\ncorresponding case. There is a special case representing sequences of\nalternating corresponding Upper and Lower pairs. It appears with a fixed\nDelta of\n\n{UpperLower, UpperLower, UpperLower}\n\nThe constant UpperLower has an otherwise impossible delta value.\n
Cbrt math.Cbrt(x float64) float64\nCbrt returns the cube root of x.\nSpecial cases are:\nCbrt(±0) = ±0\nCbrt(±Inf) = ±Inf\nCbrt(NaN) = NaN
Ceil math.Ceil(x float64) float64\nCeil returns the least integer value greater than or equal to x.\nSpecial cases are:\nCeil(±0) = ±0\nCeil(±Inf) = ±Inf\nCeil(NaN) = NaN
ChainNode parse.ChainNode\nChainNode holds a term followed by a chain of field accesses (identifier\nstarting with '.'). The names may be chained ('.x.y'). The periods are\ndropped from each ident.\n
Chdir File.Chdir() error\n
Chdir os.Chdir(dir string) error\nChdir changes the current working directory to the named directory. If there\nis an error, it will be of type *PathError.
Check quick.Check(f interface{}, config *Config) error\nCheck looks for an input to f, any function that returns bool, such that f\nreturns false. It calls f repeatedly, with arbitrary values for each\nargument. If f returns false on a given input, Check returns that input as a\n*CheckError. For example:\nfunc TestOddMultipleOfThree(t *testing.T) {\nf := func(x int) bool {\ny := OddMultipleOfThree(x)\nreturn y%2 == 1 && y%3 == 0\n}\nif err := quick.Check(f, nil); err != nil {\nt.Error(err)\n}\n}
CheckEqual quick.CheckEqual(f, g interface{}, config *Config) error\nCheckEqual looks for an input on which f and g return different results. It\ncalls f and g repeatedly with arbitrary values for each argument. If f and g\nreturn different answers, CheckEqual returns a *CheckEqualError describing\nthe input and the outputs.
CheckEqualError quick.CheckEqualError\nA CheckEqualError is the result CheckEqual finding an error.\n
CheckError quick.CheckError\nA CheckError is the result of Check finding an error.\n
Chmod File.Chmod(mode FileMode) error\n
Chmod os.Chmod(name string, mode FileMode) error\nChmod changes the mode of the named file to mode. If the file is a symbolic\nlink, it changes the mode of the link's target. If there is an error, it\nwill be of type *PathError.\nA different subset of the mode bits are used, depending on the operating\nsystem.\nOn Unix, the mode's permission bits, ModeSetuid, ModeSetgid, and ModeSticky\nare used.\nOn Windows, only the 0200 bit (owner writable) of mode is used; it controls\nwhether the file's read-only attribute is set or cleared. The other bits are\ncurrently unused. For compatibility with Go 1.12 and earlier, use a non-zero\nmode. Use mode 0400 for a read-only file and 0600 for a readable+writable\nfile.\nOn Plan 9, the mode's permission bits, ModeAppend, ModeExclusive, and\nModeTemporary are used.
Chown File.Chown(uid, gid int) error\n
Chown os.Chown(name string, uid, gid int) error\nChown changes the numeric uid and gid of the named file. If the file is a\nsymbolic link, it changes the uid and gid of the link's target. A uid or gid\nof -1 means to not change that value. If there is an error, it will be of\ntype *PathError.\nOn Windows or Plan 9, Chown always returns the syscall.EWINDOWS or EPLAN9\nerror, wrapped in *PathError.
Chtimes os.Chtimes(name string, atime time.Time, mtime time.Time) error\nChtimes changes the access and modification times of the named file, similar\nto the Unix utime() or utimes() functions.\nThe underlying filesystem may truncate or round the values to a less precise\ntime unit. If there is an error, it will be of type *PathError.
Clean filepath.Clean(path string) string\nClean returns the shortest path name equivalent to path by purely lexical\nprocessing. It applies the following rules iteratively until no further\nprocessing can be done:\n1. Replace multiple Separator elements with a single one.\n2. Eliminate each . path name element (the current directory).\n3. Eliminate each inner .. path name element (the parent directory)\nalong with the non-.. element that precedes it.\n4. Eliminate .. elements that begin a rooted path:\nthat is, replace "/.." by "/" at the beginning of a path,\nassuming Separator is '/'.\nThe returned path ends in a slash only if it represents a root directory,\nsuch as "/" on Unix or `C:\` on Windows.\nFinally, any occurrences of slash are replaced by Separator.\nIf the result of this process is an empty string, Clean returns the string\n".".\nSee also Rob Pike, “Lexical File Names in Plan 9 or Getting Dot-Dot Right,”\nhttps://9p.io/sys/doc/lexnames.html
Clean path.Clean(path string) string\nClean returns the shortest path name equivalent to path by purely lexical\nprocessing. It applies the following rules iteratively until no further\nprocessing can be done:\n1. Replace multiple slashes with a single slash.\n2. Eliminate each . path name element (the current directory).\n3. Eliminate each inner .. path name element (the parent directory)\nalong with the non-.. element that precedes it.\n4. Eliminate .. elements that begin a rooted path:\nthat is, replace "/.." by "/" at the beginning of a path.\nThe returned path ends in a slash only if it is the root "/".\nIf the result of this process is an empty string, Clean returns the string\n".".\nSee also Rob Pike, “Lexical File Names in Plan 9 or Getting Dot-Dot Right,”\nhttps://9p.io/sys/doc/lexnames.html
Cleanup B.Cleanup(f func())\n
Cleanup T.Cleanup(f func())\n
Clearenv os.Clearenv()\nClearenv deletes all environment variables.
Client http.Client\nA Client is an HTTP client. Its zero value (DefaultClient) is a usable\nclient that uses DefaultTransport.\n\nThe Client's Transport typically has internal state (cached TCP\nconnections), so Clients should be reused instead of created as needed.\nClients are safe for concurrent use by multiple goroutines.\n\nA Client is higher-level than a RoundTripper (such as Transport) and\nadditionally handles HTTP details such as cookies and redirects.\n\nWhen following redirects, the Client will forward all headers set on the\ninitial Request except:\n\n• when forwarding sensitive headers like "Authorization",\n"WWW-Authenticate", and "Cookie" to untrusted targets. These headers will be\nignored when following a redirect to a domain that is not a subdomain match\nor exact match of the initial domain. For example, a redirect from "foo.com"\nto either "foo.com" or "sub.foo.com" will forward the sensitive headers, but\na redirect to "bar.com" will not.\n\n• when forwarding the "Cookie" header with a non-nil cookie Jar. Since each\nredirect may mutate the state of the cookie jar, a redirect may possibly\nalter a cookie set in the initial request. When forwarding the "Cookie"\nheader, any mutated cookies will be omitted, with the expectation that the\nJar will insert those mutated cookies with the updated values (assuming the\norigin matches). If Jar is nil, the initial cookies are forwarded without\nchange.\n
Clock Time.Clock() (hour, min, sec int)\n
Clone Request.Clone(ctx context.Context) *Request\n
Clone Template.Clone() (*Template, error)\n
Clone Template.Clone() (*Template, error)\n
Clone Transport.Clone() *Transport\n
Close File.Close() error\n
Close IPConn.Close() error\n
Close PipeReader.Close() error\n
Close PipeWriter.Close() error\n
Close Server.Close() error\n
Close TCPConn.Close() error\n
Close TCPListener.Close() error\n
Close UDPConn.Close() error\n
Close UnixConn.Close() error\n
Close UnixListener.Close() error\n
CloseIdleConnections Client.CloseIdleConnections()\n
CloseIdleConnections Transport.CloseIdleConnections()\n
CloseNotifier http.CloseNotifier\nThe CloseNotifier interface is implemented by ResponseWriters which allow\ndetecting when the underlying connection has gone away.\n\nThis mechanism can be used to cancel long operations on the server if the\nclient has disconnected before the response is ready.\n\nDeprecated: the CloseNotifier interface predates Go's context package. New\ncode should use Request.Context instead.\n
CloseRead TCPConn.CloseRead() error\n
CloseRead UnixConn.CloseRead() error\n
CloseWithError PipeReader.CloseWithError(err error) error\n
CloseWithError PipeWriter.CloseWithError(err error) error\n
CloseWrite TCPConn.CloseWrite() error\n
CloseWrite UnixConn.CloseWrite() error\n
Closer io.Closer\nCloser is the interface that wraps the basic Close method.\n\nThe behavior of Close after the first call is undefined. Specific\nimplementations may document their own behavior.\n
Cmd exec.Cmd\nCmd represents an external command being prepared or run.\n\nA Cmd cannot be reused after calling its Run, Output or CombinedOutput\nmethods.\n
CombinedOutput Cmd.CombinedOutput() ([]byte, error)\n
Command Cmd.Command(name string, arg ...string) *Cmd\n
Command exec.Command(name string, arg ...string) *Cmd\nCommand returns the Cmd struct to execute the named program with the given\narguments.\nIt sets only the Path and Args in the returned structure.\nIf name contains no path separators, Command uses LookPath to resolve name\nto a complete path if possible. Otherwise it uses name directly as Path.\nThe returned Cmd's Args field is constructed from the command name followed\nby the elements of arg, so arg should not include the command name itself.\nFor example, Command("echo", "hello"). Args[0] is always name, not the\npossibly resolved Path.\nOn Windows, processes receive the whole command line as a single string and\ndo their own parsing. Command combines and quotes Args into a command line\nstring with an algorithm compatible with applications using\nCommandLineToArgvW (which is the most common way). Notable exceptions are\nmsiexec.exe and cmd.exe (and thus, all batch files), which have a different\nunquoting algorithm. In these or other similar cases, you can do the quoting\nyourself and provide the full command line in SysProcAttr.CmdLine, leaving\nArgs empty.
CommandContext Cmd.CommandContext(ctx context.Context, name string, arg ...string) *Cmd\n
CommandContext exec.CommandContext(ctx context.Context, name string, arg ...string) *Cmd\nCommandContext is like Command but includes a context.\nThe provided context is used to kill the process (by calling\nos.Process.Kill) if the context becomes done before the command completes on\nits own.
CommandNode parse.CommandNode\nCommandNode holds a command (a pipeline inside an evaluating action).\n
CommentNode parse.CommentNode\nCommentNode holds a comment.\n
Compact json.Compact(dst *bytes.Buffer, src []byte) error\nCompact appends to dst the JSON-encoded src with insignificant space\ncharacters elided.
Compare bytes.Compare(a, b []byte) int\nCompare returns an integer comparing two byte slices lexicographically. The\nresult will be 0 if a==b, -1 if a < b, and +1 if a > b. A nil argument is\nequivalent to an empty slice.
Compare strings.Compare(a, b string) int\nCompare returns an integer comparing two strings lexicographically. The\nresult will be 0 if a==b, -1 if a < b, and +1 if a > b.\nCompare is included only for symmetry with package bytes. It is usually\nclearer and always faster to use the built-in string comparison operators\n==, <, >, and so on.
Compile Prog.Compile(re *Regexp) (*Prog, error)\n
Compile Regexp.Compile(expr string) (*Regexp, error)\n
Compile regexp.Compile(expr string) (*Regexp, error)\nCompile parses a regular expression and returns, if successful, a Regexp\nobject that can be used to match against text.\nWhen matching against text, the regexp returns a match that begins as early\nas possible in the input (leftmost), and among those it chooses the one that\na backtracking search would have found first. This so-called leftmost-first\nmatching is the same semantics that Perl, Python, and other implementations\nuse, although this package implements it without the expense of\nbacktracking. For POSIX leftmost-longest matching, see CompilePOSIX.
Compile syntax.Compile(re *Regexp) (*Prog, error)\nCompile compiles the regexp into a program to be executed. The regexp should\nhave been simplified already (returned from re.Simplify).
CompilePOSIX Regexp.CompilePOSIX(expr string) (*Regexp, error)\n
CompilePOSIX regexp.CompilePOSIX(expr string) (*Regexp, error)\nCompilePOSIX is like Compile but restricts the regular expression to POSIX\nERE (egrep) syntax and changes the match semantics to leftmost-longest.\nThat is, when matching against text, the regexp returns a match that begins\nas early as possible in the input (leftmost), and among those it chooses a\nmatch that is as long as possible. This so-called leftmost-longest matching\nis the same semantics that early regular expression implementations used and\nthat POSIX specifies.\nHowever, there can be multiple leftmost-longest matches, with different\nsubmatch choices, and here this package diverges from POSIX. Among the\npossible leftmost-longest matches, this package chooses the one that a\nbacktracking search would have found first, while POSIX specifies that the\nmatch be chosen to maximize the length of the first subexpression, then the\nsecond, and so on from left to right. The POSIX rule is computationally\nprohibitive and not even well-defined. See\nhttps://swtch.com/~rsc/regexp/regexp2.html#posix for details.
Cond sync.Cond\nCond implements a condition variable, a rendezvous point for goroutines\nwaiting for or announcing the occurrence of an event.\n\nEach Cond has an associated Locker L (often a *Mutex or *RWMutex), which\nmust be held when changing the condition and when calling the Wait method.\n\nA Cond must not be copied after first use.\n
Config quick.Config\nA Config structure contains options for running a test.\n
Conj cmplx.Conj(x complex128) complex128\nConj returns the complex conjugate of x.
Conn net.Conn\nConn is a generic stream-oriented network connection.\n\nMultiple goroutines may invoke methods on a Conn simultaneously.\n
Contains IPNet.Contains(ip IP) bool\n
Contains bytes.Contains(b, subslice []byte) bool\nContains reports whether subslice is within b.
Contains strings.Contains(s, substr string) bool\nContains reports whether substr is within s.
ContainsAny bytes.ContainsAny(b []byte, chars string) bool\nContainsAny reports whether any of the UTF-8-encoded code points in chars\nare within b.
ContainsAny strings.ContainsAny(s, chars string) bool\nContainsAny reports whether any Unicode code points in chars are within s.
ContainsRune bytes.ContainsRune(b []byte, r rune) bool\nContainsRune reports whether the rune is contained in the UTF-8-encoded byte\nslice b.
ContainsRune strings.ContainsRune(s string, r rune) bool\nContainsRune reports whether the Unicode code point r is within s.
Context Request.Context() context.Context\n
Cookie Request.Cookie(name string) (*Cookie, error)\n
Cookie http.Cookie\nA Cookie represents an HTTP cookie as sent in the Set-Cookie header of an\nHTTP response or the Cookie header of an HTTP request.\n\nSee https://tools.ietf.org/html/rfc6265 for details.\n
CookieJar http.CookieJar\nA CookieJar manages storage and use of cookies in HTTP requests.\n\nImplementations of CookieJar must be safe for concurrent use by multiple\ngoroutines.\n\nThe net/http/cookiejar package provides a CookieJar implementation.\n
Cookies Request.Cookies() []*Cookie\n
Cookies Response.Cookies() []*Cookie\n
Copy ActionNode.Copy() Node\n
Copy BoolNode.Copy() Node\n
Copy BranchNode.Copy() Node\n
Copy ChainNode.Copy() Node\n
Copy CommandNode.Copy() Node\n
Copy CommentNode.Copy() Node\n
Copy DotNode.Copy() Node\n
Copy FieldNode.Copy() Node\n
Copy IdentifierNode.Copy() Node\n
Copy IfNode.Copy() Node\n
Copy ListNode.Copy() Node\n
Copy NilNode.Copy() Node\n
Copy NumberNode.Copy() Node\n
Copy PipeNode.Copy() Node\n
Copy ProcInst.Copy() ProcInst\n
Copy RangeNode.Copy() Node\n
Copy Regexp.Copy() *Regexp\n
Copy StartElement.Copy() StartElement\n
Copy StringNode.Copy() Node\n
Copy TemplateNode.Copy() Node\n
Copy TextNode.Copy() Node\n
Copy Tree.Copy() *Tree\n
Copy VariableNode.Copy() Node\n
Copy WithNode.Copy() Node\n
Copy io.Copy(dst Writer, src Reader) (written int64, err error)\nCopy copies from src to dst until either EOF is reached on src or an error\noccurs. It returns the number of bytes copied and the first error\nencountered while copying, if any.\nA successful Copy returns err == nil, not err == EOF. Because Copy is\ndefined to read from src until EOF, it does not treat an EOF from Read as an\nerror to be reported.\nIf src implements the WriterTo interface, the copy is implemented by calling\nsrc.WriteTo(dst). Otherwise, if dst implements the ReaderFrom interface, the\ncopy is implemented by calling dst.ReadFrom(src).
CopyBuffer io.CopyBuffer(dst Writer, src Reader, buf []byte) (written int64, err error)\nCopyBuffer is identical to Copy except that it stages through the provided\nbuffer (if one is required) rather than allocating a temporary one. If buf\nis nil, one is allocated; otherwise if it has zero length, CopyBuffer\npanics.\nIf either src implements WriterTo or dst implements ReaderFrom, buf will not\nbe used to perform the copy.
CopyList ListNode.CopyList() *ListNode\n
CopyN io.CopyN(dst Writer, src Reader, n int64) (written int64, err error)\nCopyN copies n bytes (or until an error) from src to dst. It returns the\nnumber of bytes copied and the earliest error encountered while copying. On\nreturn, written == n if and only if err == nil.\nIf dst implements the ReaderFrom interface, the copy is implemented using\nit.
CopyPipe PipeNode.CopyPipe() *PipeNode\n
CopyToken Token.CopyToken(t Token) Token\n
CopyToken xml.CopyToken(t Token) Token\nCopyToken returns a copy of a Token.
Copysign math.Copysign(x, y float64) float64\nCopysign returns a value with the magnitude of x and the sign of y.
Cos cmplx.Cos(x complex128) complex128\nCos returns the cosine of x.
Cos math.Cos(x float64) float64\nCos returns the cosine of the radian argument x.\nSpecial cases are:\nCos(±Inf) = NaN\nCos(NaN) = NaN
Cosh cmplx.Cosh(x complex128) complex128\nCosh returns the hyperbolic cosine of x.
Cosh math.Cosh(x float64) float64\nCosh returns the hyperbolic cosine of x.\nSpecial cases are:\nCosh(±0) = 1\nCosh(±Inf) = +Inf\nCosh(NaN) = NaN
Cot cmplx.Cot(x complex128) complex128\nCot returns the cotangent of x.
Count bytes.Count(s, sep []byte) int\nCount counts the number of non-overlapping instances of sep in s. If sep is\nan empty slice, Count returns 1 + the number of UTF-8-encoded code points in\ns.
Count strings.Count(s, substr string) int\nCount counts the number of non-overlapping instances of substr in s. If\nsubstr is an empty string, Count returns 1 + the number of Unicode code\npoints in s.
Cover testing.Cover\nCover records information about test coverage checking. NOTE: This struct is\ninternal to the testing infrastructure and may change. It is not covered\n(yet) by the Go 1 compatibility guidelines.\n
CoverBlock testing.CoverBlock\nCoverBlock records the coverage data for a single basic block. The fields\nare 1-indexed, as in an editor: The opening line of the file is number 1,\nfor example. Columns are measured in bytes. NOTE: This struct is internal to\nthe testing infrastructure and may change. It is not covered (yet) by the Go\n1 compatibility guidelines.\n
CoverMode testing.CoverMode() string\nCoverMode reports what the test coverage mode is set to. The values are\n"set", "count", or "atomic". The return value will be empty if test coverage\nis not enabled.
Coverage testing.Coverage() float64\nCoverage reports the current code coverage as a fraction in the range [0,\n1]. If coverage is not enabled, Coverage returns 0.\nWhen running a large set of sequential test cases, checking Coverage after\neach one can be useful for identifying which test cases exercise new code\npaths. It is not a replacement for the reports generated by 'go test -cover'\nand 'go tool cover'.
Create File.Create(name string) (*File, error)\n
Create os.Create(name string) (*File, error)\nCreate creates or truncates the named file. If the file already exists, it\nis truncated. If the file does not exist, it is created with mode 0666\n(before umask). If successful, methods on the returned File can be used for\nI/O; the associated file descriptor has mode O_RDWR. If there is an error,\nit will be of type *PathError.
CreateTemp File.CreateTemp(dir, pattern string) (*File, error)\n
CreateTemp os.CreateTemp(dir, pattern string) (*File, error)\nCreateTemp creates a new temporary file in the directory dir, opens the file\nfor reading and writing, and returns the resulting file. The filename is\ngenerated by taking pattern and adding a random string to the end. If\npattern includes a "*", the random string replaces the last "*". If dir is\nthe empty string, CreateTemp uses the default directory for temporary files,\nas returned by TempDir. Multiple programs or goroutines calling CreateTemp\nsimultaneously will not choose the same file. The caller can use the file's\nName method to find the pathname of the file. It is the caller's\nresponsibility to remove the file when it is no longer needed.
DNSConfigError net.DNSConfigError\nDNSConfigError represents an error reading the machine's DNS configuration.\n(No longer used; kept for compatibility.)\n
DNSError net.DNSError\nDNSError represents a DNS lookup error.\n
DataErrReader iotest.DataErrReader(r io.Reader) io.Reader\nDataErrReader changes the way errors are handled by a Reader. Normally, a\nReader returns an error (typically EOF) from the first Read call after the\nlast piece of data is read. DataErrReader wraps a Reader and changes its\nbehavior so the final error is returned along with the final data, instead\nof in the first call after the final data.
Date Time.Date() (year int, month Month, day int)\n
Date Time.Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time\n
Date time.Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time\nDate returns the Time corresponding to\nyyyy-mm-dd hh:mm:ss + nsec nanoseconds\nin the appropriate zone for that time in the given location.\nThe month, day, hour, min, sec, and nsec values may be outside their usual\nranges and will be normalized during the conversion. For example, October 32\nconverts to November 1.\nA daylight savings time transition skips or repeats times. For example, in\nthe United States, March 13, 2011 2:15am never occurred, while November 6,\n2011 1:15am occurred twice. In such cases, the choice of time zone, and\ntherefore the time, is not well-defined. Date returns a time that is correct\nin one of the two zones involved in the transition, but it does not\nguarantee which.\nDate panics if loc is nil.
Day Time.Day() int\n
Deadline T.Deadline() (deadline time.Time, ok bool)\n
Decode Decoder.Decode(v interface{}) error\n
Decode Decoder.Decode(v interface{}) error\n
Decode Encoding.Decode(dst, src []byte) (n int, err error)\n
Decode Encoding.Decode(dst, src []byte) (n int, err error)\n
Decode hex.Decode(dst, src []byte) (int, error)\nDecode decodes src into DecodedLen(len(src)) bytes, returning the actual\nnumber of bytes written to dst.\nDecode expects that src contains only hexadecimal characters and that src\nhas even length. If the input is malformed, Decode returns the number of\nbytes decoded before the error.
Decode utf16.Decode(s []uint16) []rune\nDecode returns the Unicode code point sequence represented by the UTF-16\nencoding s.
DecodeElement Decoder.DecodeElement(v interface{}, start *StartElement) error\n
DecodeLastRune utf8.DecodeLastRune(p []byte) (r rune, size int)\nDecodeLastRune unpacks the last UTF-8 encoding in p and returns the rune and\nits width in bytes. If p is empty it returns (RuneError, 0). Otherwise, if\nthe encoding is invalid, it returns (RuneError, 1). Both are impossible\nresults for correct, non-empty UTF-8.\nAn encoding is invalid if it is incorrect UTF-8, encodes a rune that is out\nof range, or is not the shortest possible UTF-8 encoding for the value. No\nother validation is performed.
DecodeLastRuneInString utf8.DecodeLastRuneInString(s string) (r rune, size int)\nDecodeLastRuneInString is like DecodeLastRune but its input is a string. If\ns is empty it returns (RuneError, 0). Otherwise, if the encoding is invalid,\nit returns (RuneError, 1). Both are impossible results for correct,\nnon-empty UTF-8.\nAn encoding is invalid if it is incorrect UTF-8, encodes a rune that is out\nof range, or is not the shortest possible UTF-8 encoding for the value. No\nother validation is performed.
DecodeRune utf16.DecodeRune(r1, r2 rune) rune\nDecodeRune returns the UTF-16 decoding of a surrogate pair. If the pair is\nnot a valid UTF-16 surrogate pair, DecodeRune returns the Unicode\nreplacement code point U+FFFD.
DecodeRune utf8.DecodeRune(p []byte) (r rune, size int)\nDecodeRune unpacks the first UTF-8 encoding in p and returns the rune and\nits width in bytes. If p is empty it returns (RuneError, 0). Otherwise, if\nthe encoding is invalid, it returns (RuneError, 1). Both are impossible\nresults for correct, non-empty UTF-8.\nAn encoding is invalid if it is incorrect UTF-8, encodes a rune that is out\nof range, or is not the shortest possible UTF-8 encoding for the value. No\nother validation is performed.
DecodeRuneInString utf8.DecodeRuneInString(s string) (r rune, size int)\nDecodeRuneInString is like DecodeRune but its input is a string. If s is\nempty it returns (RuneError, 0). Otherwise, if the encoding is invalid, it\nreturns (RuneError, 1). Both are impossible results for correct, non-empty\nUTF-8.\nAn encoding is invalid if it is incorrect UTF-8, encodes a rune that is out\nof range, or is not the shortest possible UTF-8 encoding for the value. No\nother validation is performed.
DecodeString Encoding.DecodeString(s string) ([]byte, error)\n
DecodeString Encoding.DecodeString(s string) ([]byte, error)\n
DecodeString hex.DecodeString(s string) ([]byte, error)\nDecodeString returns the bytes represented by the hexadecimal string s.\nDecodeString expects that src contains only hexadecimal characters and that\nsrc has even length. If the input is malformed, DecodeString returns the\nbytes decoded before the error.
DecodedLen Encoding.DecodedLen(n int) int\n
DecodedLen Encoding.DecodedLen(n int) int\n
DecodedLen hex.DecodedLen(x int) int\nDecodedLen returns the length of a decoding of x source bytes. Specifically,\nit returns x / 2.
Decoder json.Decoder\nA Decoder reads and decodes JSON values from an input stream.\n
Decoder xml.Decoder\nA Decoder represents an XML parser reading a particular input stream. The\nparser assumes that its input is encoded in UTF-8.\n
Default Logger.Default() *Logger\n
Default log.Default() *Logger\nDefault returns the standard logger used by the package-level output\nfunctions.
DefinedTemplates Template.DefinedTemplates() string\n
DefinedTemplates Template.DefinedTemplates() string\n
Delete Map.Delete(key interface{})\n
Delims Template.Delims(left, right string) *Template\n
Delims Template.Delims(left, right string) *Template\n
DetectContentType http.DetectContentType(data []byte) string\nDetectContentType implements the algorithm described at\nhttps://mimesniff.spec.whatwg.org/ to determine the Content-Type of the\ngiven data. It considers at most the first 512 bytes of data.\nDetectContentType always returns a valid MIME type: if it cannot determine a\nmore specific one, it returns "application/octet-stream".
Dial Dialer.Dial(network, address string) (Conn, error)\n
Dial net.Dial(network, address string) (Conn, error)\nDial connects to the address on the named network.\nKnown networks are "tcp", "tcp4" (IPv4-only), "tcp6" (IPv6-only), "udp",\n"udp4" (IPv4-only), "udp6" (IPv6-only), "ip", "ip4" (IPv4-only), "ip6"\n(IPv6-only), "unix", "unixgram" and "unixpacket".\nFor TCP and UDP networks, the address has the form "host:port". The host\nmust be a literal IP address, or a host name that can be resolved to IP\naddresses. The port must be a literal port number or a service name. If the\nhost is a literal IPv6 address it must be enclosed in square brackets, as in\n"[2001:db8::1]:80" or "[fe80::1%zone]:80". The zone specifies the scope of\nthe literal IPv6 address as defined in RFC 4007. The functions JoinHostPort\nand SplitHostPort manipulate a pair of host and port in this form. When\nusing TCP, and the host resolves to multiple IP addresses, Dial will try\neach IP address in order until one succeeds.\nExamples:\nDial("tcp", "golang.org:http")\nDial("tcp", "192.0.2.1:http")\nDial("tcp", "198.51.100.1:80")\nDial("udp", "[2001:db8::1]:domain")\nDial("udp", "[fe80::1%lo0]:53")\nDial("tcp", ":80")\nFor IP networks, the network must be "ip", "ip4" or "ip6" followed by a\ncolon and a literal protocol number or a protocol name, and the address has\nthe form "host". The host must be a literal IP address or a literal IPv6\naddress with zone. It depends on each operating system how the operating\nsystem behaves with a non-well known protocol number such as "0" or "255".\nExamples:\nDial("ip4:1", "192.0.2.1")\nDial("ip6:ipv6-icmp", "2001:db8::1")\nDial("ip6:58", "fe80::1%lo0")\nFor TCP, UDP and IP networks, if the host is empty or a literal unspecified\nIP address, as in ":80", "0.0.0.0:80" or "[::]:80" for TCP and UDP, "",\n"0.0.0.0" or "::" for IP, the local system is assumed.\nFor Unix networks, the address must be a file system path.
DialContext Dialer.DialContext(ctx context.Context, network, address string) (Conn, error)\n
DialIP net.DialIP(network string, laddr, raddr *IPAddr) (*IPConn, error)\nDialIP acts like Dial for IP networks.\nThe network must be an IP network name; see func Dial for details.\nIf laddr is nil, a local address is automatically chosen. If the IP field of\nraddr is nil or an unspecified IP address, the local system is assumed.
DialTCP net.DialTCP(network string, laddr, raddr *TCPAddr) (*TCPConn, error)\nDialTCP acts like Dial for TCP networks.\nThe network must be a TCP network name; see func Dial for details.\nIf laddr is nil, a local address is automatically chosen. If the IP field of\nraddr is nil or an unspecified IP address, the local system is assumed.
DialTimeout net.DialTimeout(network, address string, timeout time.Duration) (Conn, error)\nDialTimeout acts like Dial but takes a timeout.\nThe timeout includes name resolution, if required. When using TCP, and the\nhost in the address parameter resolves to multiple IP addresses, the timeout\nis spread over each consecutive dial, such that each is given an appropriate\nfraction of the time to connect.\nSee func Dial for a description of the network and address parameters.
DialUDP net.DialUDP(network string, laddr, raddr *UDPAddr) (*UDPConn, error)\nDialUDP acts like Dial for UDP networks.\nThe network must be a UDP network name; see func Dial for details.\nIf laddr is nil, a local address is automatically chosen. If the IP field of\nraddr is nil or an unspecified IP address, the local system is assumed.
DialUnix net.DialUnix(network string, laddr, raddr *UnixAddr) (*UnixConn, error)\nDialUnix acts like Dial for Unix networks.\nThe network must be a Unix network name; see func Dial for details.\nIf laddr is non-nil, it is used as the local address for the connection.
Dialer net.Dialer\nA Dialer contains options for connecting to an address.\n\nThe zero value for each field is equivalent to dialing without that option.\nDialing with the zero value of Dialer is therefore equivalent to just\ncalling the Dial function.\n\nIt is safe to call Dialer's methods concurrently.\n
Dim math.Dim(x, y float64) float64\nDim returns the maximum of x-y or 0.\nSpecial cases are:\nDim(+Inf, +Inf) = NaN\nDim(-Inf, -Inf) = NaN\nDim(x, NaN) = Dim(NaN, x) = NaN
Dir filepath.Dir(path string) string\nDir returns all but the last element of path, typically the path's\ndirectory. After dropping the final element, Dir calls Clean on the path and\ntrailing slashes are removed. If the path is empty, Dir returns ".". If the\npath consists entirely of separators, Dir returns a single separator. The\nreturned path does not end in a separator unless it is the root directory.
Dir path.Dir(path string) string\nDir returns all but the last element of path, typically the path's\ndirectory. After dropping the final element using Split, the path is Cleaned\nand trailing slashes are removed. If the path is empty, Dir returns ".". If\nthe path consists entirely of slashes followed by non-slash bytes, Dir\nreturns a single slash. In any other case, the returned path does not end in\na slash.
DirEntry fs.DirEntry\nA DirEntry is an entry read from a directory (using the ReadDir function or\na ReadDirFile's ReadDir method).\n
DirFS os.DirFS(dir string) fs.FS\nDirFS returns a file system (an fs.FS) for the tree of files rooted at the\ndirectory dir.\nNote that DirFS("/prefix") only guarantees that the Open calls it makes to\nthe operating system will begin with "/prefix":\nDirFS("/prefix").Open("file") is the same as os.Open("/prefix/file"). So if\n/prefix/file is a symbolic link pointing outside the /prefix tree, then\nusing DirFS does not stop the access any more than using os.Open does. DirFS\nis therefore not a general substitute for a chroot-style security mechanism\nwhen the directory tree contains arbitrary content.
DisallowUnknownFields Decoder.DisallowUnknownFields()\n
Discard Reader.Discard(n int) (discarded int, err error)\n
Do Client.Do(req *Request) (*Response, error)\n
Do Once.Do(f func())\n
Done WaitGroup.Done()\n
DotNode parse.DotNode\nDotNode holds the special identifier '.'.\n
Dump hex.Dump(data []byte) string\nDump returns a string that contains a hex dump of the given data. The format\nof the hex dump matches the output of `hexdump -C` on the command line.
Dumper hex.Dumper(w io.Writer) io.WriteCloser\nDumper returns a WriteCloser that writes a hex dump of all written data to\nw. The format of the dump matches the output of `hexdump -C` on the command\nline.
Duration FlagSet.Duration(name string, value time.Duration, usage string) *time.Duration\n
Duration flag.Duration(name string, value time.Duration, usage string) *time.Duration\nDuration defines a time.Duration flag with specified name, default value,\nand usage string. The return value is the address of a time.Duration\nvariable that stores the value of the flag. The flag accepts a value\nacceptable to time.ParseDuration.
DurationVar FlagSet.DurationVar(p *time.Duration, name string, value time.Duration, usage string)\n
DurationVar flag.DurationVar(p *time.Duration, name string, value time.Duration, usage string)\nDurationVar defines a time.Duration flag with specified name, default value,\nand usage string. The argument p points to a time.Duration variable in which\nto store the value of the flag. The flag accepts a value acceptable to\ntime.ParseDuration.
EmptyOpContext syntax.EmptyOpContext(r1, r2 rune) EmptyOp\nEmptyOpContext returns the zero-width assertions satisfied at the position\nbetween the runes r1 and r2. Passing r1 == -1 indicates that the position is\nat the beginning of the text. Passing r2 == -1 indicates that the position\nis at the end of the text.
Encode Encoder.Encode(v interface{}) error\n
Encode Encoder.Encode(v interface{}) error\n
Encode Encoding.Encode(dst, src []byte)\n
Encode Encoding.Encode(dst, src []byte)\n
Encode hex.Encode(dst, src []byte) int\nEncode encodes src into EncodedLen(len(src)) bytes of dst. As a convenience,\nit returns the number of bytes written to dst, but this value is always\nEncodedLen(len(src)). Encode implements hexadecimal encoding.
Encode utf16.Encode(s []rune) []uint16\nEncode returns the UTF-16 encoding of the Unicode code point sequence s.
EncodeElement Encoder.EncodeElement(v interface{}, start StartElement) error\n
EncodeRune utf16.EncodeRune(r rune) (r1, r2 rune)\nEncodeRune returns the UTF-16 surrogate pair r1, r2 for the given rune. If\nthe rune is not a valid Unicode code point or does not need encoding,\nEncodeRune returns U+FFFD, U+FFFD.
EncodeRune utf8.EncodeRune(p []byte, r rune) int\nEncodeRune writes into p (which must be large enough) the UTF-8 encoding of\nthe rune. If the rune is out of range, it writes the encoding of RuneError.\nIt returns the number of bytes written.
EncodeToString Encoding.EncodeToString(src []byte) string\n
EncodeToString Encoding.EncodeToString(src []byte) string\n
EncodeToString hex.EncodeToString(src []byte) string\nEncodeToString returns the hexadecimal encoding of src.
EncodeToken Encoder.EncodeToken(t Token) error\n
EncodedLen Encoding.EncodedLen(n int) int\n
EncodedLen Encoding.EncodedLen(n int) int\n
EncodedLen hex.EncodedLen(n int) int\nEncodedLen returns the length of an encoding of n source bytes.\nSpecifically, it returns n * 2.
Encoder json.Encoder\nAn Encoder writes JSON values to an output stream.\n
Encoder xml.Encoder\nAn Encoder writes XML data to an output stream.\n
Encoding base32.Encoding\nAn Encoding is a radix 32 encoding/decoding scheme, defined by a\n32-character alphabet. The most common is the "base32" encoding introduced\nfor SASL GSSAPI and standardized in RFC 4648. The alternate "base32hex"\nencoding is used in DNSSEC.\n
Encoding base64.Encoding\nAn Encoding is a radix 64 encoding/decoding scheme, defined by a\n64-character alphabet. The most common encoding is the "base64" encoding\ndefined in RFC 4648 and used in MIME (RFC 2045) and PEM (RFC 1421). RFC 4648\nalso defines an alternate encoding, which is the standard encoding with -\nand _ substituted for + and /.\n
End StartElement.End() EndElement\n
EndElement xml.EndElement\nAn EndElement represents an XML end element.\n
Entry Func.Entry() uintptr\n
Environ os.Environ() []string\nEnviron returns a copy of strings representing the environment, in the form\n"key=value".
Equal Regexp.Equal(y *Regexp) bool\n
Equal Time.Equal(u Time) bool\n
Equal bytes.Equal(a, b []byte) bool\nEqual reports whether a and b are the same length and contain the same\nbytes. A nil argument is equivalent to an empty slice.
EqualFold bytes.EqualFold(s, t []byte) bool\nEqualFold reports whether s and t, interpreted as UTF-8 strings, are equal\nunder Unicode case-folding, which is a more general form of\ncase-insensitivity.
EqualFold strings.EqualFold(s, t string) bool\nEqualFold reports whether s and t, interpreted as UTF-8 strings, are equal\nunder Unicode case-folding, which is a more general form of\ncase-insensitivity.
Erf math.Erf(x float64) float64\nErf returns the error function of x.\nSpecial cases are:\nErf(+Inf) = 1\nErf(-Inf) = -1\nErf(NaN) = NaN
Erfc math.Erfc(x float64) float64\nErfc returns the complementary error function of x.\nSpecial cases are:\nErfc(+Inf) = 0\nErfc(-Inf) = 2\nErfc(NaN) = NaN
Erfcinv math.Erfcinv(x float64) float64\nErfcinv returns the inverse of Erfc(x).\nSpecial cases are:\nErfcinv(0) = +Inf\nErfcinv(2) = -Inf\nErfcinv(x) = NaN if x < 0 or x > 2\nErfcinv(NaN) = NaN
Erfinv math.Erfinv(x float64) float64\nErfinv returns the inverse error function of x.\nSpecial cases are:\nErfinv(1) = +Inf\nErfinv(-1) = -Inf\nErfinv(x) = NaN if x < -1 or x > 1\nErfinv(NaN) = NaN
Err Scanner.Err() error\n
ErrReader iotest.ErrReader(err error) io.Reader\nErrReader returns an io.Reader that returns 0, err from all Read calls.
Error AddrError.Error() string\n
Error B.Error(args ...interface{})\n
Error CheckEqualError.Error() string\n
Error CheckError.Error() string\n
Error DNSConfigError.Error() string\n
Error DNSError.Error() string\n
Error Error.Error() string\n
Error Error.Error() string\n
Error Error.Error() string\n
Error Error.Error() string\n
Error ExecError.Error() string\n
Error ExitError.Error() string\n
Error InvalidUTF8Error.Error() string\n
Error InvalidUnmarshalError.Error() string\n
Error LinkError.Error() string\n
Error MarshalerError.Error() string\n
Error NumError.Error() string\n
Error OpError.Error() string\n
Error ParseError.Error() string\n
Error ParseError.Error() string\n
Error ParseError.Error() string\n
Error PathError.Error() string\n
Error ProtocolError.Error() string\n
Error SyntaxError.Error() string\n
Error SyntaxError.Error() string\n
Error SyscallError.Error() string\n
Error T.Error(args ...interface{})\n
Error TagPathError.Error() string\n
Error TypeAssertionError.Error() string\n
Error UnmarshalFieldError.Error() string\n
Error UnmarshalTypeError.Error() string\n
Error UnsupportedTypeError.Error() string\n
Error UnsupportedTypeError.Error() string\n
Error UnsupportedValueError.Error() string\n
Error Writer.Error() error\n
Error exec.Error\nError is returned by LookPath when it fails to classify a file as an\nexecutable.\n
Error http.Error(w ResponseWriter, error string, code int)\nError replies to the request with the specified error message and HTTP code.\nIt does not otherwise end the request; the caller should ensure no further\nwrites are done to w. The error message should be plain text.
Error net.Error\nAn Error represents a network error.\n
Error runtime.Error\nThe Error interface identifies a run time error.\n
Error syntax.Error\nAn Error describes a failure to parse a regular expression and gives the\noffending expression.\n
Error template.Error\nError describes a problem encountered during template Escaping.\n
Error url.Error\nError reports an error and the operation and URL that caused it.\n
ErrorContext Tree.ErrorContext(n Node) (location, context string)\n
ErrorHandling FlagSet.ErrorHandling() ErrorHandling\n
Errorf B.Errorf(format string, args ...interface{})\n
Errorf T.Errorf(format string, args ...interface{})\n
Errorf fmt.Errorf(format string, a ...interface{}) error\nErrorf formats according to a format specifier and returns the string as a\nvalue that satisfies error.\nIf the format specifier includes a %w verb with an error operand, the\nreturned error will implement an Unwrap method returning the operand. It is\ninvalid to include more than one %w verb or to supply it with an operand\nthat does not implement the error interface. The %w verb is otherwise a\nsynonym for %v.
Escape xml.Escape(w io.Writer, s []byte)\nEscape is like EscapeText but omits the error return value. It is provided\nfor backwards compatibility with Go 1.0. Code targeting Go 1.1 or later\nshould use EscapeText.
EscapeString html.EscapeString(s string) string\nEscapeString escapes special characters like "<" to become "&lt;". It\nescapes only five such characters: <, >, &, ' and ".\nUnescapeString(EscapeString(s)) == s always holds, but the converse isn't\nalways true.
EscapeText xml.EscapeText(w io.Writer, s []byte) error\nEscapeText writes to w the properly escaped XML equivalent of the plain text\ndata s.
EscapedFragment URL.EscapedFragment() string\n
EscapedPath URL.EscapedPath() string\n
EvalSymlinks filepath.EvalSymlinks(path string) (string, error)\nEvalSymlinks returns the path name after the evaluation of any symbolic\nlinks. If path is relative the result will be relative to the current\ndirectory, unless one of the components is an absolute symbolic link.\nEvalSymlinks calls Clean on the result.
ExecError template.ExecError\nExecError is the custom error type returned when Execute has an error\nevaluating its template. (If a write error occurs, the actual error is\nreturned; it will not be of type ExecError.)\n
Executable os.Executable() (string, error)\nExecutable returns the path name for the executable that started the current\nprocess. There is no guarantee that the path is still pointing to the\ncorrect executable. If a symlink was used to start the process, depending on\nthe operating system, the result might be the symlink or the path it pointed\nto. If a stable result is needed, path/filepath.EvalSymlinks might help.\nExecutable returns an absolute path unless an error occurred.\nThe main use case is finding resources located relative to an executable.
Execute Template.Execute(wr io.Writer, data interface{}) error\n
Execute Template.Execute(wr io.Writer, data interface{}) error\n
ExecuteTemplate Template.ExecuteTemplate(wr io.Writer, name string, data interface{}) error\n
ExecuteTemplate Template.ExecuteTemplate(wr io.Writer, name string, data interface{}) error\n
Exit os.Exit(code int)\nExit causes the current program to exit with the given status code.\nConventionally, code zero indicates success, non-zero an error. The program\nterminates immediately; deferred functions are not run.\nFor portability, the status code should be in the range [0, 125].
ExitCode ProcessState.ExitCode() int\n
ExitError exec.ExitError\nAn ExitError reports an unsuccessful exit by a command.\n
Exited ProcessState.Exited() bool\n
Exp cmplx.Exp(x complex128) complex128\nExp returns e**x, the base-e exponential of x.
Exp math.Exp(x float64) float64\nExp returns e**x, the base-e exponential of x.\nSpecial cases are:\nExp(+Inf) = +Inf\nExp(NaN) = NaN\nVery large values overflow to 0 or +Inf. Very small values underflow to 1.
Exp2 math.Exp2(x float64) float64\nExp2 returns 2**x, the base-2 exponential of x.\nSpecial cases are the same as Exp.
ExpFloat64 Rand.ExpFloat64() float64\n
ExpFloat64 rand.ExpFloat64() float64\nExpFloat64 returns an exponentially distributed float64 in the range (0,\n+math.MaxFloat64] with an exponential distribution whose rate parameter\n(lambda) is 1 and whose mean is 1/lambda (1) from the default Source. To\nproduce a distribution with a different rate parameter, callers can adjust\nthe output using:\nsample = ExpFloat64() / desiredRateParameter
Expand Regexp.Expand(dst []byte, template []byte, src []byte, match []int) []byte\n
Expand os.Expand(s string, mapping func(string) string) string\nExpand replaces ${var} or $var in the string based on the mapping function.\nFor example, os.ExpandEnv(s) is equivalent to os.Expand(s, os.Getenv).
ExpandEnv os.ExpandEnv(s string) string\nExpandEnv replaces ${var} or $var in the string according to the values of\nthe current environment variables. References to undefined variables are\nreplaced by the empty string.
ExpandString Regexp.ExpandString(dst []byte, template string, src string, match []int) []byte\n
Expm1 math.Expm1(x float64) float64\nExpm1 returns e**x - 1, the base-e exponential of x minus 1. It is more\naccurate than Exp(x) - 1 when x is near zero.\nSpecial cases are:\nExpm1(+Inf) = +Inf\nExpm1(-Inf) = -1\nExpm1(NaN) = NaN\nVery large values overflow to -1 or +Inf.
Ext filepath.Ext(path string) string\nExt returns the file name extension used by path. The extension is the\nsuffix beginning at the final dot in the final element of path; it is empty\nif there is no dot.
Ext path.Ext(path string) string\nExt returns the file name extension used by path. The extension is the\nsuffix beginning at the final dot in the final slash-separated element of\npath; it is empty if there is no dot.
FMA math.FMA(x, y, z float64) float64\nFMA returns x * y + z, computed with only one rounding. (That is, FMA\nreturns the fused multiply-add of x, y, and z.)
FS FileSystem.FS(fsys fs.FS) FileSystem\n
FS embed.FS\nAn FS is a read-only collection of files, usually initialized with a\n//go:embed directive. When declared without a //go:embed directive, an FS is\nan empty file system.\n\nAn FS is a read-only value, so it is safe to use from multiple goroutines\nsimultaneously and also safe to assign values of type FS to each other.\n\nFS implements fs.FS, so it can be used with any package that understands\nfile system interfaces, including net/http, text/template, and\nhtml/template.\n\nSee the package documentation for more details about initializing an FS.\n
FS fs.FS\nAn FS provides access to a hierarchical file system.\n\nThe FS interface is the minimum implementation required of the file system.\nA file system may implement additional interfaces, such as ReadFileFS, to\nprovide additional or optimized functionality.\n
FS http.FS(fsys fs.FS) FileSystem\nFS converts fsys to a FileSystem implementation, for use with FileServer and\nNewFileTransport.
Fail B.Fail()\n
Fail T.Fail()\n
FailNow B.FailNow()\n
FailNow T.FailNow()\n
Failed B.Failed() bool\n
Failed T.Failed() bool\n
Fatal B.Fatal(args ...interface{})\n
Fatal Logger.Fatal(v ...interface{})\n
Fatal T.Fatal(args ...interface{})\n
Fatal log.Fatal(v ...interface{})\nFatal is equivalent to Print() followed by a call to os.Exit(1).
Fatalf B.Fatalf(format string, args ...interface{})\n
Fatalf Logger.Fatalf(format string, v ...interface{})\n
Fatalf T.Fatalf(format string, args ...interface{})\n
Fatalf log.Fatalf(format string, v ...interface{})\nFatalf is equivalent to Printf() followed by a call to os.Exit(1).
Fatalln Logger.Fatalln(v ...interface{})\n
Fatalln log.Fatalln(v ...interface{})\nFatalln is equivalent to Println() followed by a call to os.Exit(1).
Fd File.Fd() uintptr\n
FieldNode parse.FieldNode\nFieldNode holds a field (identifier starting with '.'). The names may be\nchained ('.x.y'). The period is dropped from each ident.\n
FieldPos Reader.FieldPos(field int) (line, column int)\n
Fields bytes.Fields(s []byte) [][]byte\nFields interprets s as a sequence of UTF-8-encoded code points. It splits\nthe slice s around each instance of one or more consecutive white space\ncharacters, as defined by unicode.IsSpace, returning a slice of subslices of\ns or an empty slice if s contains only white space.
Fields strings.Fields(s string) []string\nFields splits the string s around each instance of one or more consecutive\nwhite space characters, as defined by unicode.IsSpace, returning a slice of\nsubstrings of s or an empty slice if s contains only white space.
FieldsFunc bytes.FieldsFunc(s []byte, f func(rune) bool) [][]byte\nFieldsFunc interprets s as a sequence of UTF-8-encoded code points. It\nsplits the slice s at each run of code points c satisfying f(c) and returns\na slice of subslices of s. If all code points in s satisfy f(c), or len(s)\n== 0, an empty slice is returned.\nFieldsFunc makes no guarantees about the order in which it calls f(c) and\nassumes that f always returns the same value for a given c.
FieldsFunc strings.FieldsFunc(s string, f func(rune) bool) []string\nFieldsFunc splits the string s at each run of Unicode code points c\nsatisfying f(c) and returns an array of slices of s. If all code points in s\nsatisfy f(c) or the string is empty, an empty slice is returned.\nFieldsFunc makes no guarantees about the order in which it calls f(c) and\nassumes that f always returns the same value for a given c.
File IPConn.File() (f *os.File, err error)\n
File TCPConn.File() (f *os.File, err error)\n
File TCPListener.File() (f *os.File, err error)\n
File UDPConn.File() (f *os.File, err error)\n
File UnixConn.File() (f *os.File, err error)\n
File UnixListener.File() (f *os.File, err error)\n
File fs.File\nA File provides access to a single file. The File interface is the minimum\nimplementation required of the file. Directory files should also implement\nReadDirFile. A file may implement io.ReaderAt or io.Seeker as optimizations.\n
File http.File\nA File is returned by a FileSystem's Open method and can be served by the\nFileServer implementation.\n\nThe methods should behave the same as those on an *os.File.\n
File os.File\nFile represents an open file descriptor.\n
FileConn net.FileConn(f *os.File) (c Conn, err error)\nFileConn returns a copy of the network connection corresponding to the open\nfile f. It is the caller's responsibility to close f when finished. Closing\nc does not affect f, and closing f does not affect c.
FileInfo fs.FileInfo\nA FileInfo describes a file and is returned by Stat.\n
FileInfoToDirEntry DirEntry.FileInfoToDirEntry(info FileInfo) DirEntry\n
FileInfoToDirEntry fs.FileInfoToDirEntry(info FileInfo) DirEntry\nFileInfoToDirEntry returns a DirEntry that returns information from info. If\ninfo is nil, FileInfoToDirEntry returns nil.
FileLine Func.FileLine(pc uintptr) (file string, line int)\n
FileListener net.FileListener(f *os.File) (ln Listener, err error)\nFileListener returns a copy of the network listener corresponding to the\nopen file f. It is the caller's responsibility to close ln when finished.\nClosing ln does not affect f, and closing f does not affect ln.
FilePacketConn net.FilePacketConn(f *os.File) (c PacketConn, err error)\nFilePacketConn returns a copy of the packet network connection corresponding\nto the open file f. It is the caller's responsibility to close f when\nfinished. Closing c does not affect f, and closing f does not affect c.
FileServer Handler.FileServer(root FileSystem) Handler\n
FileServer http.FileServer(root FileSystem) Handler\nFileServer returns a handler that serves HTTP requests with the contents of\nthe file system rooted at root.\nAs a special case, the returned file server redirects any request ending in\n"/index.html" to the same path, without the final "index.html".\nTo use the operating system's file system implementation, use http.Dir:\nhttp.Handle("/", http.FileServer(http.Dir("/tmp")))\nTo use an fs.FS implementation, use http.FS to convert it:\nhttp.Handle("/", http.FileServer(http.FS(fsys)))
FileSystem http.FileSystem\nA FileSystem implements access to a collection of named files. The elements\nin a file path are separated by slash ('/', U+002F) characters, regardless\nof host operating system convention. See the FileServer function to convert\na FileSystem to a Handler.\n\nThis interface predates the fs.FS interface, which can be used instead: the\nFS adapter function converts an fs.FS to a FileSystem.\n
Find Regexp.Find(b []byte) []byte\n
FindAll Regexp.FindAll(b []byte, n int) [][]byte\n
FindAllIndex Regexp.FindAllIndex(b []byte, n int) [][]int\n
FindAllString Regexp.FindAllString(s string, n int) []string\n
FindAllStringIndex Regexp.FindAllStringIndex(s string, n int) [][]int\n
FindAllStringSubmatch Regexp.FindAllStringSubmatch(s string, n int) [][]string\n
FindAllStringSubmatchIndex Regexp.FindAllStringSubmatchIndex(s string, n int) [][]int\n
FindAllSubmatch Regexp.FindAllSubmatch(b []byte, n int) [][][]byte\n
FindAllSubmatchIndex Regexp.FindAllSubmatchIndex(b []byte, n int) [][]int\n
FindIndex Regexp.FindIndex(b []byte) (loc []int)\n
FindProcess Process.FindProcess(pid int) (*Process, error)\n
FindProcess os.FindProcess(pid int) (*Process, error)\nFindProcess looks for a running process by its pid.\nThe Process it returns can be used to obtain information about the\nunderlying operating system process.\nOn Unix systems, FindProcess always succeeds and returns a Process for the\ngiven pid, regardless of whether the process exists.
FindReaderIndex Regexp.FindReaderIndex(r io.RuneReader) (loc []int)\n
FindReaderSubmatchIndex Regexp.FindReaderSubmatchIndex(r io.RuneReader) []int\n
FindString Regexp.FindString(s string) string\n
FindStringIndex Regexp.FindStringIndex(s string) (loc []int)\n
FindStringSubmatch Regexp.FindStringSubmatch(s string) []string\n
FindStringSubmatchIndex Regexp.FindStringSubmatchIndex(s string) []int\n
FindSubmatch Regexp.FindSubmatch(b []byte) [][]byte\n
FindSubmatchIndex Regexp.FindSubmatchIndex(b []byte) []int\n
FixedZone Location.FixedZone(name string, offset int) *Location\n
FixedZone time.FixedZone(name string, offset int) *Location\nFixedZone returns a Location that always uses the given zone name and offset\n(seconds east of UTC).
Flag flag.Flag\nA Flag represents the state of a flag.\n
FlagSet flag.FlagSet\nA FlagSet represents a set of defined flags. The zero value of a FlagSet has\nno name and has ContinueOnError error handling.\n\nFlag names must be unique within a FlagSet. An attempt to define a flag\nwhose name is already in use will cause a panic.\n
Flags Logger.Flags() int\n
Flags log.Flags() int\nFlags returns the output flags for the standard logger. The flag bits are\nLdate, Ltime, and so on.
Float32 Rand.Float32() float32\n
Float32 rand.Float32() float32\nFloat32 returns, as a float32, a pseudo-random number in the half-open\ninterval [0.0,1.0) from the default Source.
Float32bits math.Float32bits(f float32) uint32\nFloat32bits returns the IEEE 754 binary representation of f, with the sign\nbit of f and the result in the same bit position.\nFloat32bits(Float32frombits(x)) == x.
Float32frombits math.Float32frombits(b uint32) float32\nFloat32frombits returns the floating-point number corresponding to the IEEE\n754 binary representation b, with the sign bit of b and the result in the\nsame bit position. Float32frombits(Float32bits(x)) == x.
Float64 FlagSet.Float64(name string, value float64, usage string) *float64\n
Float64 Rand.Float64() float64\n
Float64 flag.Float64(name string, value float64, usage string) *float64\nFloat64 defines a float64 flag with specified name, default value, and usage\nstring. The return value is the address of a float64 variable that stores\nthe value of the flag.
Float64 rand.Float64() float64\nFloat64 returns, as a float64, a pseudo-random number in the half-open\ninterval [0.0,1.0) from the default Source.
Float64Var FlagSet.Float64Var(p *float64, name string, value float64, usage string)\n
Float64Var flag.Float64Var(p *float64, name string, value float64, usage string)\nFloat64Var defines a float64 flag with specified name, default value, and\nusage string. The argument p points to a float64 variable in which to store\nthe value of the flag.
Float64bits math.Float64bits(f float64) uint64\nFloat64bits returns the IEEE 754 binary representation of f, with the sign\nbit of f and the result in the same bit position, and\nFloat64bits(Float64frombits(x)) == x.
Float64frombits math.Float64frombits(b uint64) float64\nFloat64frombits returns the floating-point number corresponding to the IEEE\n754 binary representation b, with the sign bit of b and the result in the\nsame bit position. Float64frombits(Float64bits(x)) == x.
Float64s sort.Float64s(x []float64)\nFloat64s sorts a slice of float64s in increasing order. Not-a-number (NaN)\nvalues are ordered before other values.
Float64sAreSorted sort.Float64sAreSorted(x []float64) bool\nFloat64sAreSorted reports whether the slice x is sorted in increasing order,\nwith not-a-number (NaN) values before any other values.
Floor math.Floor(x float64) float64\nFloor returns the greatest integer value less than or equal to x.\nSpecial cases are:\nFloor(±0) = ±0\nFloor(±Inf) = ±Inf\nFloor(NaN) = NaN
Flush Encoder.Flush() error\n
Flush Writer.Flush() error\n
Flush Writer.Flush()\n
Flusher http.Flusher\nThe Flusher interface is implemented by ResponseWriters that allow an HTTP\nhandler to flush buffered data to the client.\n\nThe default HTTP/1.x and HTTP/2 ResponseWriter implementations support\nFlusher, but ResponseWriter wrappers may not. Handlers should always test\nfor this ability at runtime.\n\nNote that even for ResponseWriters that support Flush, if the client is\nconnected through an HTTP proxy, the buffered data may not reach the client\nuntil the response completes.\n
FormFile Request.FormFile(key string) (multipart.File, *multipart.FileHeader, error)\n
FormValue Request.FormValue(key string) string\n
Format Time.Format(layout string) string\n
FormatBool strconv.FormatBool(b bool) string\nFormatBool returns "true" or "false" according to the value of b.
FormatComplex strconv.FormatComplex(c complex128, fmt byte, prec, bitSize int) string\nFormatComplex converts the complex number c to a string of the form (a+bi)\nwhere a and b are the real and imaginary parts, formatted according to the\nformat fmt and precision prec.\nThe format fmt and precision prec have the same meaning as in FormatFloat.\nIt rounds the result assuming that the original was obtained from a complex\nvalue of bitSize bits, which must be 64 for complex64 and 128 for\ncomplex128.
FormatFloat strconv.FormatFloat(f float64, fmt byte, prec, bitSize int) string\nFormatFloat converts the floating-point number f to a string, according to\nthe format fmt and precision prec. It rounds the result assuming that the\noriginal was obtained from a floating-point value of bitSize bits (32 for\nfloat32, 64 for float64).\nThe format fmt is one of 'b' (-ddddp±ddd, a binary exponent), 'e'\n(-d.dddde±dd, a decimal exponent), 'E' (-d.ddddE±dd, a decimal exponent),\n'f' (-ddd.dddd, no exponent), 'g' ('e' for large exponents, 'f' otherwise),\n'G' ('E' for large exponents, 'f' otherwise), 'x' (-0xd.ddddp±ddd, a\nhexadecimal fraction and binary exponent), or 'X' (-0Xd.ddddP±ddd, a\nhexadecimal fraction and binary exponent).\nThe precision prec controls the number of digits (excluding the exponent)\nprinted by the 'e', 'E', 'f', 'g', 'G', 'x', and 'X' formats. For 'e', 'E',\n'f', 'x', and 'X', it is the number of digits after the decimal point. For\n'g' and 'G' it is the maximum number of significant digits (trailing zeros\nare removed). The special precision -1 uses the smallest number of digits\nnecessary such that ParseFloat will return f exactly.
FormatInt strconv.FormatInt(i int64, base int) string\nFormatInt returns the string representation of i in the given base, for 2 <=\nbase <= 36. The result uses the lower-case letters 'a' to 'z' for digit\nvalues >= 10.
FormatUint strconv.FormatUint(i uint64, base int) string\nFormatUint returns the string representation of i in the given base, for 2\n<= base <= 36. The result uses the lower-case letters 'a' to 'z' for digit\nvalues >= 10.
Formatter fmt.Formatter\nFormatter is implemented by any value that has a Format method. The\nimplementation controls how State and rune are interpreted, and may call\nSprint(f) or Fprint(f) etc. to generate its output.\n
Fprint fmt.Fprint(w io.Writer, a ...interface{}) (n int, err error)\nFprint formats using the default formats for its operands and writes to w.\nSpaces are added between operands when neither is a string. It returns the\nnumber of bytes written and any write error encountered.
Fprintf fmt.Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error)\nFprintf formats according to a format specifier and writes to w. It returns\nthe number of bytes written and any write error encountered.
Fprintln fmt.Fprintln(w io.Writer, a ...interface{}) (n int, err error)\nFprintln formats using the default formats for its operands and writes to w.\nSpaces are always added between operands and a newline is appended. It\nreturns the number of bytes written and any write error encountered.
Frame runtime.Frame\nFrame is the information returned by Frames for each call frame.\n
Frames runtime.Frames\nFrames may be used to get function/file/line information for a slice of PC\nvalues returned by Callers.\n
Frexp math.Frexp(f float64) (frac float64, exp int)\nFrexp breaks f into a normalized fraction and an integral power of two. It\nreturns frac and exp satisfying f == frac × 2**exp, with the absolute value\nof frac in the interval [½, 1).\nSpecial cases are:\nFrexp(±0) = ±0, 0\nFrexp(±Inf) = ±Inf, 0\nFrexp(NaN) = NaN, 0
FromSlash filepath.FromSlash(path string) string\nFromSlash returns the result of replacing each slash ('/') character in path\nwith a separator character. Multiple slashes are replaced by multiple\nseparators.
Fscan fmt.Fscan(r io.Reader, a ...interface{}) (n int, err error)\nFscan scans text read from r, storing successive space-separated values into\nsuccessive arguments. Newlines count as space. It returns the number of\nitems successfully scanned. If that is less than the number of arguments,\nerr will report why.
Fscanf fmt.Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error)\nFscanf scans text read from r, storing successive space-separated values\ninto successive arguments as determined by the format. It returns the number\nof items successfully parsed. Newlines in the input must match newlines in\nthe format.
Fscanln fmt.Fscanln(r io.Reader, a ...interface{}) (n int, err error)\nFscanln is similar to Fscan, but stops scanning at a newline and after the\nfinal item there must be a newline or EOF.
FullRune utf8.FullRune(p []byte) bool\nFullRune reports whether the bytes in p begin with a full UTF-8 encoding of\na rune. An invalid encoding is considered a full Rune since it will convert\nas a width-1 error rune.
FullRuneInString utf8.FullRuneInString(s string) bool\nFullRuneInString is like FullRune but its input is a string.
Func FlagSet.Func(name, usage string, fn func(string) error)\n
Func flag.Func(name, usage string, fn func(string) error)\nFunc defines a flag with the specified name and usage string. Each time the\nflag is seen, fn is called with the value of the flag. If fn returns a\nnon-nil error, it will be treated as a flag value parsing error.
Func runtime.Func\nA Func represents a Go function in the running binary.\n
FuncForPC Func.FuncForPC(pc uintptr) *Func\n
FuncForPC runtime.FuncForPC(pc uintptr) *Func\nFuncForPC returns a *Func describing the function that contains the given\nprogram counter address, or else nil.\nIf pc represents multiple functions because of inlining, it returns the\n*Func describing the innermost function, but with an entry of the outermost\nfunction.
Funcs Template.Funcs(funcMap FuncMap) *Template\n
Funcs Template.Funcs(funcMap FuncMap) *Template\n
GC runtime.GC()\nGC runs a garbage collection and blocks the caller until the garbage\ncollection is complete. It may also block the entire program.
GOMAXPROCS runtime.GOMAXPROCS(n int) int\nGOMAXPROCS sets the maximum number of CPUs that can be executing\nsimultaneously and returns the previous setting. It defaults to the value of\nruntime.NumCPU. If n < 1, it does not change the current setting. This call\nwill go away when the scheduler improves.
GOROOT runtime.GOROOT() string\nGOROOT returns the root of the Go tree. It uses the GOROOT environment\nvariable, if set at process start, or else the root used during the Go\nbuild.
Gamma math.Gamma(x float64) float64\nGamma returns the Gamma function of x.\nSpecial cases are:\nGamma(+Inf) = +Inf\nGamma(+0) = +Inf\nGamma(-0) = -Inf\nGamma(x) = NaN for integer x < 0\nGamma(-Inf) = NaN\nGamma(NaN) = NaN
Generator quick.Generator\nA Generator can generate random values of its own type.\n
Get Client.Get(url string) (resp *Response, err error)\n
Get Pool.Get() interface{}\n
Get http.Get(url string) (resp *Response, err error)\nGet issues a GET to the specified URL. If the response is one of the\nfollowing redirect codes, Get follows the redirect, up to a maximum of 10\nredirects:\n301 (Moved Permanently)\n302 (Found)\n303 (See Other)\n307 (Temporary Redirect)\n308 (Permanent Redirect)\nAn error is returned if there were too many redirects or if there was an\nHTTP protocol error. A non-2xx response doesn't cause an error. Any returned\nerror will be of type *url.Error. The url.Error value's Timeout method will\nreport true if the request timed out.\nWhen err is nil, resp always contains a non-nil resp.Body. Caller should\nclose resp.Body when done reading from it.\nGet is a wrapper around DefaultClient.Get.\nTo make a request with custom headers, use NewRequest and DefaultClient.Do.\nTo make a request with a specified context.Context, use\nNewRequestWithContext and DefaultClient.Do.
Getegid os.Getegid() int\nGetegid returns the numeric effective group id of the caller.\nOn Windows, it returns -1.
Getenv os.Getenv(key string) string\nGetenv retrieves the value of the environment variable named by the key. It\nreturns the value, which will be empty if the variable is not present. To\ndistinguish between an empty value and an unset value, use LookupEnv.
Geteuid os.Geteuid() int\nGeteuid returns the numeric effective user id of the caller.\nOn Windows, it returns -1.
Getgid os.Getgid() int\nGetgid returns the numeric group id of the caller.\nOn Windows, it returns -1.
Getgroups os.Getgroups() ([]int, error)\nGetgroups returns a list of the numeric ids of groups that the caller\nbelongs to.\nOn Windows, it returns syscall.EWINDOWS. See the os/user package for a\npossible alternative.
Getpagesize os.Getpagesize() int\nGetpagesize returns the underlying system's memory page size.
Getpid os.Getpid() int\nGetpid returns the process id of the caller.
Getppid os.Getppid() int\nGetppid returns the process id of the caller's parent.
Getter flag.Getter\nGetter is an interface that allows the contents of a Value to be retrieved.\nIt wraps the Value interface, rather than being part of it, because it\nappeared after Go 1 and its compatibility rules. All Value types provided by\nthis package satisfy the Getter interface, except the type used by Func.\n
Getuid os.Getuid() int\nGetuid returns the numeric user id of the caller.\nOn Windows, it returns -1.
Getwd os.Getwd() (dir string, err error)\nGetwd returns a rooted path name corresponding to the current directory. If\nthe current directory can be reached via multiple paths (due to symbolic\nlinks), Getwd may return any one of them.
Glob filepath.Glob(pattern string) (matches []string, err error)\nGlob returns the names of all files matching pattern or nil if there is no\nmatching file. The syntax of patterns is the same as in Match. The pattern\nmay describe hierarchical names such as /usr/*/bin/ed (assuming the\nSeparator is '/').\nGlob ignores file system errors such as I/O errors reading directories. The\nonly possible returned error is ErrBadPattern, when pattern is malformed.
Glob fs.Glob(fsys FS, pattern string) (matches []string, err error)\nGlob returns the names of all files matching pattern or nil if there is no\nmatching file. The syntax of patterns is the same as in path.Match. The\npattern may describe hierarchical names such as usr/*/bin/ed.\nGlob ignores file system errors such as I/O errors reading directories. The\nonly possible returned error is path.ErrBadPattern, reporting that the\npattern is malformed.\nIf fs implements GlobFS, Glob calls fs.Glob. Otherwise, Glob uses ReadDir to\ntraverse the directory tree and look for matches for the pattern.
GlobFS fs.GlobFS\nA GlobFS is a file system with a Glob method.\n
GoString Time.GoString() string\n
GoStringer fmt.GoStringer\nGoStringer is implemented by any value that has a GoString method, which\ndefines the Go syntax for that value. The GoString method is used to print\nvalues passed as an operand to a %#v format.\n
GobDecode Time.GobDecode(data []byte) error\n
GobEncode Time.GobEncode() ([]byte, error)\n
Goexit runtime.Goexit()\nGoexit terminates the goroutine that calls it. No other goroutine is\naffected. Goexit runs all deferred calls before terminating the goroutine.\nBecause Goexit is not a panic, any recover calls in those deferred functions\nwill return nil.\nCalling Goexit from the main goroutine terminates that goroutine without\nfunc main returning. Since func main has not returned, the program continues\nexecution of other goroutines. If all other goroutines exit, the program\ncrashes.
GoroutineProfile runtime.GoroutineProfile(p []StackRecord) (n int, ok bool)\nGoroutineProfile returns n, the number of records in the active goroutine\nstack profile. If len(p) >= n, GoroutineProfile copies the profile into p\nand returns n, true. If len(p) < n, GoroutineProfile does not change p and\nreturns n, false.\nMost clients should use the runtime/pprof package instead of calling\nGoroutineProfile directly.
Gosched runtime.Gosched()\nGosched yields the processor, allowing other goroutines to run. It does not\nsuspend the current goroutine, so execution resumes automatically.
Grow Buffer.Grow(n int)\n
Grow Builder.Grow(n int)\n
HTMLEscape json.HTMLEscape(dst *bytes.Buffer, src []byte)\nHTMLEscape appends to dst the JSON-encoded src with <, >, &, U+2028 and\nU+2029 characters inside string literals changed to \u003c, \u003e, \u0026,\n\u2028, \u2029 so that the JSON will be safe to embed inside HTML <script>\ntags. For historical reasons, web browsers don't honor standard HTML\nescaping within <script> tags, so an alternative JSON encoding must be used.
HTMLEscape template.HTMLEscape(w io.Writer, b []byte)\nHTMLEscape writes to w the escaped HTML equivalent of the plain text data b.
HTMLEscape template.HTMLEscape(w io.Writer, b []byte)\nHTMLEscape writes to w the escaped HTML equivalent of the plain text data b.
HTMLEscapeString template.HTMLEscapeString(s string) string\nHTMLEscapeString returns the escaped HTML equivalent of the plain text data\ns.
HTMLEscapeString template.HTMLEscapeString(s string) string\nHTMLEscapeString returns the escaped HTML equivalent of the plain text data\ns.
HTMLEscaper template.HTMLEscaper(args ...interface{}) string\nHTMLEscaper returns the escaped HTML equivalent of the textual\nrepresentation of its arguments.
HTMLEscaper template.HTMLEscaper(args ...interface{}) string\nHTMLEscaper returns the escaped HTML equivalent of the textual\nrepresentation of its arguments.
HalfReader iotest.HalfReader(r io.Reader) io.Reader\nHalfReader returns a Reader that implements Read by reading half as many\nrequested bytes from r.
Handle ServeMux.Handle(pattern string, handler Handler)\n
Handle http.Handle(pattern string, handler Handler)\nHandle registers the handler for the given pattern in the DefaultServeMux.\nThe documentation for ServeMux explains how patterns are matched.
HandleFunc ServeMux.HandleFunc(pattern string, handler func(ResponseWriter, *Request))\n
HandleFunc http.HandleFunc(pattern string, handler func(ResponseWriter, *Request))\nHandleFunc registers the handler function for the given pattern in the\nDefaultServeMux. The documentation for ServeMux explains how patterns are\nmatched.
Handler ServeMux.Handler(r *Request) (h Handler, pattern string)\n
Handler http.Handler\nA Handler responds to an HTTP request.\n\nServeHTTP should write reply headers and data to the ResponseWriter and then\nreturn. Returning signals that the request is finished; it is not valid to\nuse the ResponseWriter or read from the Request.Body after or concurrently\nwith the completion of the ServeHTTP call.\n\nDepending on the HTTP client software, HTTP protocol version, and any\nintermediaries between the client and the Go server, it may not be possible\nto read from the Request.Body after writing to the ResponseWriter. Cautious\nhandlers should read the Request.Body first, and then reply.\n\nExcept for reading the body, handlers should not modify the provided\nRequest.\n\nIf ServeHTTP panics, the server (the caller of ServeHTTP) assumes that the\neffect of the panic was isolated to the active request. It recovers the\npanic, logs a stack trace to the server error log, and either closes the\nnetwork connection or sends an HTTP/2 RST_STREAM, depending on the HTTP\nprotocol. To abort a handler so the client sees an interrupted response but\nthe server doesn't log an error, panic with the value ErrAbortHandler.\n
HasPrefix bytes.HasPrefix(s, prefix []byte) bool\nHasPrefix tests whether the byte slice s begins with prefix.
HasPrefix filepath.HasPrefix(p, prefix string) bool\nHasPrefix exists for historical compatibility and should not be used.\nDeprecated: HasPrefix does not respect path boundaries and does not ignore\ncase when required.
HasPrefix strings.HasPrefix(s, prefix string) bool\nHasPrefix tests whether the string s begins with prefix.
HasSuffix bytes.HasSuffix(s, suffix []byte) bool\nHasSuffix tests whether the byte slice s ends with suffix.
HasSuffix strings.HasSuffix(s, suffix string) bool\nHasSuffix tests whether the string s ends with suffix.
Head Client.Head(url string) (resp *Response, err error)\n
Head http.Head(url string) (resp *Response, err error)\nHead issues a HEAD to the specified URL. If the response is one of the\nfollowing redirect codes, Head follows the redirect, up to a maximum of 10\nredirects:\n301 (Moved Permanently)\n302 (Found)\n303 (See Other)\n307 (Temporary Redirect)\n308 (Permanent Redirect)\nHead is a wrapper around DefaultClient.Head\nTo make a request with a specified context.Context, use\nNewRequestWithContext and DefaultClient.Do.
Helper B.Helper()\n
Helper T.Helper()\n
Hijacker http.Hijacker\nThe Hijacker interface is implemented by ResponseWriters that allow an HTTP\nhandler to take over the connection.\n\nThe default ResponseWriter for HTTP/1.x connections supports Hijacker, but\nHTTP/2 connections intentionally do not. ResponseWriter wrappers may also\nnot support Hijacker. Handlers should always test for this ability at\nruntime.\n
Hostname URL.Hostname() string\n
Hostname os.Hostname() (name string, err error)\nHostname returns the host name reported by the kernel.
Hour Time.Hour() int\n
Hypot math.Hypot(p, q float64) float64\nHypot returns Sqrt(p*p + q*q), taking care to avoid unnecessary overflow and\nunderflow.\nSpecial cases are:\nHypot(±Inf, q) = +Inf\nHypot(p, ±Inf) = +Inf\nHypot(NaN, q) = NaN\nHypot(p, NaN) = NaN
IPAddr net.IPAddr\nIPAddr represents the address of an IP end point.\n
IPConn net.IPConn\nIPConn is the implementation of the Conn and PacketConn interfaces for IP\nnetwork connections.\n
IPNet net.IPNet\nAn IPNet represents an IP network.\n
IPv4 net.IPv4(a, b, c, d byte) IP\nIPv4 returns the IP address (in 16-byte form) of the IPv4 address a.b.c.d.
IPv4Mask net.IPv4Mask(a, b, c, d byte) IPMask\nIPv4Mask returns the IP mask (in 4-byte form) of the IPv4 mask a.b.c.d.
ISOWeek Time.ISOWeek() (year, week int)\n
IdentifierNode parse.IdentifierNode\nIdentifierNode holds an identifier.\n
IfNode parse.IfNode\nIfNode represents an {{if}} action and its commands.\n
Ignore signal.Ignore(sig ...os.Signal)\nIgnore causes the provided signals to be ignored. If they are received by\nthe program, nothing will happen. Ignore undoes the effect of any prior\ncalls to Notify for the provided signals. If no signals are provided, all\nincoming signals will be ignored.
Ignored signal.Ignored(sig os.Signal) bool\nIgnored reports whether sig is currently ignored.
Ilogb math.Ilogb(x float64) int\nIlogb returns the binary exponent of x as an integer.\nSpecial cases are:\nIlogb(±Inf) = MaxInt32\nIlogb(0) = MinInt32\nIlogb(NaN) = MaxInt32
In Time.In(loc *Location) Time\n
In unicode.In(r rune, ranges ...*RangeTable) bool\nIn reports whether the rune is a member of one of the ranges.
InUseBytes MemProfileRecord.InUseBytes() int64\n
InUseObjects MemProfileRecord.InUseObjects() int64\n
Indent Encoder.Indent(prefix, indent string)\n
Indent json.Indent(dst *bytes.Buffer, src []byte, prefix, indent string) error\nIndent appends to dst an indented form of the JSON-encoded src. Each element\nin a JSON object or array begins on a new, indented line beginning with\nprefix followed by one or more copies of indent according to the indentation\nnesting. The data appended to dst does not begin with the prefix nor any\nindentation, to make it easier to embed inside other formatted JSON data.\nAlthough leading space characters (space, tab, carriage return, newline) at\nthe beginning of src are dropped, trailing space characters at the end of\nsrc are preserved and copied to dst. For example, if src has no trailing\nspaces, neither will dst; if src ends in a trailing newline, so will dst.
Index bytes.Index(s, sep []byte) int\nIndex returns the index of the first instance of sep in s, or -1 if sep is\nnot present in s.
Index strings.Index(s, substr string) int\nIndex returns the index of the first instance of substr in s, or -1 if\nsubstr is not present in s.
IndexAny bytes.IndexAny(s []byte, chars string) int\nIndexAny interprets s as a sequence of UTF-8-encoded Unicode code points. It\nreturns the byte index of the first occurrence in s of any of the Unicode\ncode points in chars. It returns -1 if chars is empty or if there is no code\npoint in common.
IndexAny strings.IndexAny(s, chars string) int\nIndexAny returns the index of the first instance of any Unicode code point\nfrom chars in s, or -1 if no Unicode code point from chars is present in s.
IndexByte bytes.IndexByte(b []byte, c byte) int\nIndexByte returns the index of the first instance of c in b, or -1 if c is\nnot present in b.
IndexByte strings.IndexByte(s string, c byte) int\nIndexByte returns the index of the first instance of c in s, or -1 if c is\nnot present in s.
IndexFunc bytes.IndexFunc(s []byte, f func(r rune) bool) int\nIndexFunc interprets s as a sequence of UTF-8-encoded code points. It\nreturns the byte index in s of the first Unicode code point satisfying f(c),\nor -1 if none do.
IndexFunc strings.IndexFunc(s string, f func(rune) bool) int\nIndexFunc returns the index into s of the first Unicode code point\nsatisfying f(c), or -1 if none do.
IndexRune bytes.IndexRune(s []byte, r rune) int\nIndexRune interprets s as a sequence of UTF-8-encoded code points. It\nreturns the byte index of the first occurrence in s of the given rune. It\nreturns -1 if rune is not present in s. If r is utf8.RuneError, it returns\nthe first instance of any invalid UTF-8 byte sequence.
IndexRune strings.IndexRune(s string, r rune) int\nIndexRune returns the index of the first instance of the Unicode code point\nr, or -1 if rune is not present in s. If r is utf8.RuneError, it returns the\nfirst instance of any invalid UTF-8 byte sequence.
Inf cmplx.Inf() complex128\nInf returns a complex infinity, complex(+Inf, +Inf).
Inf math.Inf(sign int) float64\nInf returns positive infinity if sign >= 0, negative infinity if sign < 0.
Init FlagSet.Init(name string, errorHandling ErrorHandling)\n
Init Scanner.Init(src io.Reader) *Scanner\n
Init testing.Init()\nInit registers testing flags. These flags are automatically registered by\nthe "go test" command before running test functions, so Init is only needed\nwhen calling functions such as Benchmark without using "go test".\nInit has no effect if it was already called.
InputOffset Decoder.InputOffset() int64\n
InputOffset Decoder.InputOffset() int64\n
Inst syntax.Inst\nAn Inst is a single instruction in a regular expression program.\n
Int FlagSet.Int(name string, value int, usage string) *int\n
Int Rand.Int() int\n
Int flag.Int(name string, value int, usage string) *int\nInt defines an int flag with specified name, default value, and usage\nstring. The return value is the address of an int variable that stores the\nvalue of the flag.
Int rand.Int() int\nInt returns a non-negative pseudo-random int from the default Source.
Int31 Rand.Int31() int32\n
Int31 rand.Int31() int32\nInt31 returns a non-negative pseudo-random 31-bit integer as an int32 from\nthe default Source.
Int31n Rand.Int31n(n int32) int32\n
Int31n rand.Int31n(n int32) int32\nInt31n returns, as an int32, a non-negative pseudo-random number in the\nhalf-open interval [0,n) from the default Source. It panics if n <= 0.
Int63 Rand.Int63() int64\n
Int63 rand.Int63() int64\nInt63 returns a non-negative pseudo-random 63-bit integer as an int64 from\nthe default Source.
Int63n Rand.Int63n(n int64) int64\n
Int63n rand.Int63n(n int64) int64\nInt63n returns, as an int64, a non-negative pseudo-random number in the\nhalf-open interval [0,n) from the default Source. It panics if n <= 0.
Int64 FlagSet.Int64(name string, value int64, usage string) *int64\n
Int64 flag.Int64(name string, value int64, usage string) *int64\nInt64 defines an int64 flag with specified name, default value, and usage\nstring. The return value is the address of an int64 variable that stores the\nvalue of the flag.
Int64Var FlagSet.Int64Var(p *int64, name string, value int64, usage string)\n
Int64Var flag.Int64Var(p *int64, name string, value int64, usage string)\nInt64Var defines an int64 flag with specified name, default value, and usage\nstring. The argument p points to an int64 variable in which to store the\nvalue of the flag.
IntVar FlagSet.IntVar(p *int, name string, value int, usage string)\n
IntVar flag.IntVar(p *int, name string, value int, usage string)\nIntVar defines an int flag with specified name, default value, and usage\nstring. The argument p points to an int variable in which to store the value\nof the flag.
Interface net.Interface\nInterface represents a mapping between network interface name and index. It\nalso represents network interface facility information.\n
Interface sort.Interface\nAn implementation of Interface can be sorted by the routines in this\npackage. The methods refer to elements of the underlying collection by\ninteger index.\n
InterfaceAddrs net.InterfaceAddrs() ([]Addr, error)\nInterfaceAddrs returns a list of the system's unicast interface addresses.\nThe returned list does not identify the associated interface; use Interfaces\nand Interface.Addrs for more detail.
InterfaceByIndex net.InterfaceByIndex(index int) (*Interface, error)\nInterfaceByIndex returns the interface specified by index.\nOn Solaris, it returns one of the logical network interfaces sharing the\nlogical data link; for more precision use InterfaceByName.
InterfaceByName net.InterfaceByName(name string) (*Interface, error)\nInterfaceByName returns the interface specified by name.
Interfaces net.Interfaces() ([]Interface, error)\nInterfaces returns a list of the system's network interfaces.
InternalBenchmark testing.InternalBenchmark\nInternalBenchmark is an internal type but exported because it is\ncross-package; it is part of the implementation of the "go test" command.\n
InternalExample testing.InternalExample\n
InternalTest testing.InternalTest\nInternalTest is an internal type but exported because it is cross-package;\nit is part of the implementation of the "go test" command.\n
Intn Rand.Intn(n int) int\n
Intn rand.Intn(n int) int\nIntn returns, as an int, a non-negative pseudo-random number in the\nhalf-open interval [0,n) from the default Source. It panics if n <= 0.
Ints sort.Ints(x []int)\nInts sorts a slice of ints in increasing order.
IntsAreSorted sort.IntsAreSorted(x []int) bool\nIntsAreSorted reports whether the slice x is sorted in increasing order.
InvalidUTF8Error json.InvalidUTF8Error\nBefore Go 1.2, an InvalidUTF8Error was returned by Marshal when attempting\nto encode a string value with invalid UTF-8 sequences. As of Go 1.2, Marshal\ninstead coerces the string to valid UTF-8 by replacing invalid bytes with\nthe Unicode replacement rune U+FFFD.\n\nDeprecated: No longer used; kept for compatibility.\n
InvalidUnmarshalError json.InvalidUnmarshalError\nAn InvalidUnmarshalError describes an invalid argument passed to Unmarshal.\n(The argument to Unmarshal must be a non-nil pointer.)\n
Is errors.Is(err, target error) bool\nIs reports whether any error in err's chain matches target.\nThe chain consists of err itself followed by the sequence of errors obtained\nby repeatedly calling Unwrap.\nAn error is considered to match a target if it is equal to that target or if\nit implements a method Is(error) bool such that Is(target) returns true.\nAn error type might provide an Is method so it can be treated as equivalent\nto an existing error. For example, if MyError defines\nfunc (m MyError) Is(target error) bool { return target == fs.ErrExist }\nthen Is(MyError{}, fs.ErrExist) returns true. See syscall.Errno.Is for an\nexample in the standard library.
Is unicode.Is(rangeTab *RangeTable, r rune) bool\nIs reports whether the rune is in the specified table of ranges.
IsAbs URL.IsAbs() bool\n
IsAbs filepath.IsAbs(path string) bool\nIsAbs reports whether the path is absolute.
IsAbs path.IsAbs(path string) bool\nIsAbs reports whether the path is absolute.
IsControl unicode.IsControl(r rune) bool\nIsControl reports whether the rune is a control character. The C (Other)\nUnicode category includes more code points such as surrogates; use Is(C, r)\nto test for them.
IsDST Time.IsDST() bool\n
IsDigit unicode.IsDigit(r rune) bool\nIsDigit reports whether the rune is a decimal digit.
IsEmptyTree parse.IsEmptyTree(n Node) bool\nIsEmptyTree reports whether this tree (node) is empty of everything but\nspace or comments.
IsExist os.IsExist(err error) bool\nIsExist returns a boolean indicating whether the error is known to report\nthat a file or directory already exists. It is satisfied by ErrExist as well\nas some syscall errors.\nThis function predates errors.Is. It only supports errors returned by the os\npackage. New code should use errors.Is(err, fs.ErrExist).
IsGraphic strconv.IsGraphic(r rune) bool\nIsGraphic reports whether the rune is defined as a Graphic by Unicode. Such\ncharacters include letters, marks, numbers, punctuation, symbols, and\nspaces, from categories L, M, N, P, S, and Zs.
IsGraphic unicode.IsGraphic(r rune) bool\nIsGraphic reports whether the rune is defined as a Graphic by Unicode. Such\ncharacters include letters, marks, numbers, punctuation, symbols, and\nspaces, from categories L, M, N, P, S, Zs.
IsInf cmplx.IsInf(x complex128) bool\nIsInf reports whether either real(x) or imag(x) is an infinity.
IsInf math.IsInf(f float64, sign int) bool\nIsInf reports whether f is an infinity, according to sign. If sign > 0,\nIsInf reports whether f is positive infinity. If sign < 0, IsInf reports\nwhether f is negative infinity. If sign == 0, IsInf reports whether f is\neither infinity.
IsLetter unicode.IsLetter(r rune) bool\nIsLetter reports whether the rune is a letter (category L).
IsLower unicode.IsLower(r rune) bool\nIsLower reports whether the rune is a lower case letter.
IsMark unicode.IsMark(r rune) bool\nIsMark reports whether the rune is a mark character (category M).
IsNaN cmplx.IsNaN(x complex128) bool\nIsNaN reports whether either real(x) or imag(x) is NaN and neither is an\ninfinity.
IsNaN math.IsNaN(f float64) (is bool)\nIsNaN reports whether f is an IEEE 754 “not-a-number” value.
IsNotExist os.IsNotExist(err error) bool\nIsNotExist returns a boolean indicating whether the error is known to report\nthat a file or directory does not exist. It is satisfied by ErrNotExist as\nwell as some syscall errors.\nThis function predates errors.Is. It only supports errors returned by the os\npackage. New code should use errors.Is(err, fs.ErrNotExist).
IsNumber unicode.IsNumber(r rune) bool\nIsNumber reports whether the rune is a number (category N).
IsOneOf unicode.IsOneOf(ranges []*RangeTable, r rune) bool\nIsOneOf reports whether the rune is a member of one of the ranges. The\nfunction "In" provides a nicer signature and should be used in preference to\nIsOneOf.
IsPathSeparator os.IsPathSeparator(c uint8) bool\nIsPathSeparator reports whether c is a directory separator character.
IsPermission os.IsPermission(err error) bool\nIsPermission returns a boolean indicating whether the error is known to\nreport that permission is denied. It is satisfied by ErrPermission as well\nas some syscall errors.\nThis function predates errors.Is. It only supports errors returned by the os\npackage. New code should use errors.Is(err, fs.ErrPermission).
IsPrint strconv.IsPrint(r rune) bool\nIsPrint reports whether the rune is defined as printable by Go, with the\nsame definition as unicode.IsPrint: letters, numbers, punctuation, symbols\nand ASCII space.
IsPrint unicode.IsPrint(r rune) bool\nIsPrint reports whether the rune is defined as printable by Go. Such\ncharacters include letters, marks, numbers, punctuation, symbols, and the\nASCII space character, from categories L, M, N, P, S and the ASCII space\ncharacter. This categorization is the same as IsGraphic except that the only\nspacing character is ASCII space, U+0020.
IsPunct unicode.IsPunct(r rune) bool\nIsPunct reports whether the rune is a Unicode punctuation character\n(category P).
IsSorted sort.IsSorted(data Interface) bool\nIsSorted reports whether data is sorted.
IsSpace unicode.IsSpace(r rune) bool\nIsSpace reports whether the rune is a space character as defined by\nUnicode's White Space property; in the Latin-1 space this is\n'\t', '\n', '\v', '\f', '\r', ' ', U+0085 (NEL), U+00A0 (NBSP).\nOther definitions of spacing characters are set by category Z and property\nPattern_White_Space.
IsSurrogate utf16.IsSurrogate(r rune) bool\nIsSurrogate reports whether the specified Unicode code point can appear in a\nsurrogate pair.
IsSymbol unicode.IsSymbol(r rune) bool\nIsSymbol reports whether the rune is a symbolic character.
IsTimeout os.IsTimeout(err error) bool\nIsTimeout returns a boolean indicating whether the error is known to report\nthat a timeout occurred.\nThis function predates errors.Is, and the notion of whether an error\nindicates a timeout can be ambiguous. For example, the Unix error\nEWOULDBLOCK sometimes indicates a timeout and sometimes does not. New code\nshould use errors.Is with a value appropriate to the call returning the\nerror, such as os.ErrDeadlineExceeded.
IsTitle unicode.IsTitle(r rune) bool\nIsTitle reports whether the rune is a title case letter.
IsTrue template.IsTrue(val interface{}) (truth, ok bool)\nIsTrue reports whether the value is 'true', in the sense of not the zero of\nits type, and whether the value has a meaningful truth value. This is the\ndefinition of truth used by if and other such actions.
IsTrue template.IsTrue(val interface{}) (truth, ok bool)\nIsTrue reports whether the value is 'true', in the sense of not the zero of\nits type, and whether the value has a meaningful truth value. This is the\ndefinition of truth used by if and other such actions.
IsUpper unicode.IsUpper(r rune) bool\nIsUpper reports whether the rune is an upper case letter.
IsValid Position.IsValid() bool\n
IsWordChar syntax.IsWordChar(r rune) bool\nIsWordChar reports whether r is consider a “word character” during the\nevaluation of the \b and \B zero-width assertions. These assertions are\nASCII-only: the word characters are [A-Za-z0-9_].
IsZero Time.IsZero() bool\n
Itoa strconv.Itoa(i int) string\nItoa is equivalent to FormatInt(int64(i), 10).
J0 math.J0(x float64) float64\nJ0 returns the order-zero Bessel function of the first kind.\nSpecial cases are:\nJ0(±Inf) = 0\nJ0(0) = 1\nJ0(NaN) = NaN
J1 math.J1(x float64) float64\nJ1 returns the order-one Bessel function of the first kind.\nSpecial cases are:\nJ1(±Inf) = 0\nJ1(NaN) = NaN
JSEscape template.JSEscape(w io.Writer, b []byte)\nJSEscape writes to w the escaped JavaScript equivalent of the plain text\ndata b.
JSEscape template.JSEscape(w io.Writer, b []byte)\nJSEscape writes to w the escaped JavaScript equivalent of the plain text\ndata b.
JSEscapeString template.JSEscapeString(s string) string\nJSEscapeString returns the escaped JavaScript equivalent of the plain text\ndata s.
JSEscapeString template.JSEscapeString(s string) string\nJSEscapeString returns the escaped JavaScript equivalent of the plain text\ndata s.
JSEscaper template.JSEscaper(args ...interface{}) string\nJSEscaper returns the escaped JavaScript equivalent of the textual\nrepresentation of its arguments.
JSEscaper template.JSEscaper(args ...interface{}) string\nJSEscaper returns the escaped JavaScript equivalent of the textual\nrepresentation of its arguments.
Jn math.Jn(n int, x float64) float64\nJn returns the order-n Bessel function of the first kind.\nSpecial cases are:\nJn(n, ±Inf) = 0\nJn(n, NaN) = NaN
Join bytes.Join(s [][]byte, sep []byte) []byte\nJoin concatenates the elements of s to create a new byte slice. The\nseparator sep is placed between elements in the resulting slice.
Join filepath.Join(elem ...string) string\nJoin joins any number of path elements into a single path, separating them\nwith an OS specific Separator. Empty elements are ignored. The result is\nCleaned. However, if the argument list is empty or all its elements are\nempty, Join returns an empty string. On Windows, the result will only be a\nUNC path if the first non-empty element is a UNC path.
Join path.Join(elem ...string) string\nJoin joins any number of path elements into a single path, separating them\nwith slashes. Empty elements are ignored. The result is Cleaned. However, if\nthe argument list is empty or all its elements are empty, Join returns an\nempty string.
Join strings.Join(elems []string, sep string) string\nJoin concatenates the elements of its first argument to create a single\nstring. The separator string sep is placed between elements in the resulting\nstring.
JoinHostPort net.JoinHostPort(host, port string) string\nJoinHostPort combines host and port into a network address of the form\n"host:port". If host contains a colon, as found in literal IPv6 addresses,\nthen JoinHostPort returns "[host]:port".\nSee func Dial for a description of the host and port parameters.
KeepAlive runtime.KeepAlive(x interface{})\nKeepAlive marks its argument as currently reachable. This ensures that the\nobject is not freed, and its finalizer is not run, before the point in the\nprogram where KeepAlive is called.\nA very simplified example showing where KeepAlive is required:\ntype File struct { d int }\nd, err := syscall.Open("/file/path", syscall.O_RDONLY, 0)\n// ... do something if err != nil ...\np := &File{d}\nruntime.SetFinalizer(p, func(p *File) { syscall.Close(p.d) })\nvar buf [10]byte\nn, err := syscall.Read(p.d, buf[:])\n// Ensure p is not finalized until Read returns.\nruntime.KeepAlive(p)\n// No more uses of p after this point.\nWithout the KeepAlive call, the finalizer could run at the start of\nsyscall.Read, closing the file descriptor before syscall.Read makes the\nactual system call.\nNote: KeepAlive should only be used to prevent finalizers from running\nprematurely. In particular, when used with unsafe.Pointer, the rules for\nvalid uses of unsafe.Pointer still apply.
Kill Process.Kill() error\n
LastIndex bytes.LastIndex(s, sep []byte) int\nLastIndex returns the index of the last instance of sep in s, or -1 if sep\nis not present in s.
LastIndex strings.LastIndex(s, substr string) int\nLastIndex returns the index of the last instance of substr in s, or -1 if\nsubstr is not present in s.
LastIndexAny bytes.LastIndexAny(s []byte, chars string) int\nLastIndexAny interprets s as a sequence of UTF-8-encoded Unicode code\npoints. It returns the byte index of the last occurrence in s of any of the\nUnicode code points in chars. It returns -1 if chars is empty or if there is\nno code point in common.
LastIndexAny strings.LastIndexAny(s, chars string) int\nLastIndexAny returns the index of the last instance of any Unicode code\npoint from chars in s, or -1 if no Unicode code point from chars is present\nin s.
LastIndexByte bytes.LastIndexByte(s []byte, c byte) int\nLastIndexByte returns the index of the last instance of c in s, or -1 if c\nis not present in s.
LastIndexByte strings.LastIndexByte(s string, c byte) int\nLastIndexByte returns the index of the last instance of c in s, or -1 if c\nis not present in s.
LastIndexFunc bytes.LastIndexFunc(s []byte, f func(r rune) bool) int\nLastIndexFunc interprets s as a sequence of UTF-8-encoded code points. It\nreturns the byte index in s of the last Unicode code point satisfying f(c),\nor -1 if none do.
LastIndexFunc strings.LastIndexFunc(s string, f func(rune) bool) int\nLastIndexFunc returns the index into s of the last Unicode code point\nsatisfying f(c), or -1 if none do.
Lchown os.Lchown(name string, uid, gid int) error\nLchown changes the numeric uid and gid of the named file. If the file is a\nsymbolic link, it changes the uid and gid of the link itself. If there is an\nerror, it will be of type *PathError.\nOn Windows, it always returns the syscall.EWINDOWS error, wrapped in\n*PathError.
Ldexp math.Ldexp(frac float64, exp int) float64\nLdexp is the inverse of Frexp. It returns frac × 2**exp.\nSpecial cases are:\nLdexp(±0, exp) = ±0\nLdexp(±Inf, exp) = ±Inf\nLdexp(NaN, exp) = NaN
Len Buffer.Len() int\n
Len Builder.Len() int\n
Len Reader.Len() int\n
Len Reader.Len() int\n
Lgamma math.Lgamma(x float64) (lgamma float64, sign int)\nLgamma returns the natural logarithm and sign (-1 or +1) of Gamma(x).\nSpecial cases are:\nLgamma(+Inf) = +Inf\nLgamma(0) = +Inf\nLgamma(-integer) = +Inf\nLgamma(-Inf) = -Inf\nLgamma(NaN) = NaN
LimitReader Reader.LimitReader(r Reader, n int64) Reader\n
LimitReader io.LimitReader(r Reader, n int64) Reader\nLimitReader returns a Reader that reads from r but stops with EOF after n\nbytes. The underlying implementation is a *LimitedReader.
LimitedReader io.LimitedReader\nA LimitedReader reads from R but limits the amount of data returned to just\nN bytes. Each call to Read updates N to reflect the new amount remaining.\nRead returns EOF when N <= 0 or when the underlying R returns EOF.\n
Link os.Link(oldname, newname string) error\nLink creates newname as a hard link to the oldname file. If there is an\nerror, it will be of type *LinkError.
LinkError os.LinkError\nLinkError records an error during a link or symlink or rename system call\nand the paths that caused it.\n
ListNode parse.ListNode\nListNode holds a sequence of nodes.\n
Listen ListenConfig.Listen(ctx context.Context, network, address string) (Listener, error)\n
Listen net.Listen(network, address string) (Listener, error)\nListen announces on the local network address.\nThe network must be "tcp", "tcp4", "tcp6", "unix" or "unixpacket".\nFor TCP networks, if the host in the address parameter is empty or a literal\nunspecified IP address, Listen listens on all available unicast and anycast\nIP addresses of the local system. To only use IPv4, use network "tcp4". The\naddress can use a host name, but this is not recommended, because it will\ncreate a listener for at most one of the host's IP addresses. If the port in\nthe address parameter is empty or "0", as in "127.0.0.1:" or "[::1]:0", a\nport number is automatically chosen. The Addr method of Listener can be used\nto discover the chosen port.\nSee func Dial for a description of the network and address parameters.\nListen uses context.Background internally; to specify the context, use\nListenConfig.Listen.
ListenAndServe Server.ListenAndServe() error\n
ListenAndServe http.ListenAndServe(addr string, handler Handler) error\nListenAndServe listens on the TCP network address addr and then calls Serve\nwith handler to handle requests on incoming connections. Accepted\nconnections are configured to enable TCP keep-alives.\nThe handler is typically nil, in which case the DefaultServeMux is used.\nListenAndServe always returns a non-nil error.
ListenAndServeTLS Server.ListenAndServeTLS(certFile, keyFile string) error\n
ListenAndServeTLS http.ListenAndServeTLS(addr, certFile, keyFile string, handler Handler) error\nListenAndServeTLS acts identically to ListenAndServe, except that it expects\nHTTPS connections. Additionally, files containing a certificate and matching\nprivate key for the server must be provided. If the certificate is signed by\na certificate authority, the certFile should be the concatenation of the\nserver's certificate, any intermediates, and the CA's certificate.
ListenConfig net.ListenConfig\nListenConfig contains options for listening to an address.\n
ListenIP net.ListenIP(network string, laddr *IPAddr) (*IPConn, error)\nListenIP acts like ListenPacket for IP networks.\nThe network must be an IP network name; see func Dial for details.\nIf the IP field of laddr is nil or an unspecified IP address, ListenIP\nlistens on all available IP addresses of the local system except multicast\nIP addresses.
ListenMulticastUDP net.ListenMulticastUDP(network string, ifi *Interface, gaddr *UDPAddr) (*UDPConn, error)\nListenMulticastUDP acts like ListenPacket for UDP networks but takes a group\naddress on a specific network interface.\nThe network must be a UDP network name; see func Dial for details.\nListenMulticastUDP listens on all available IP addresses of the local system\nincluding the group, multicast IP address. If ifi is nil, ListenMulticastUDP\nuses the system-assigned multicast interface, although this is not\nrecommended because the assignment depends on platforms and sometimes it\nmight require routing configuration. If the Port field of gaddr is 0, a port\nnumber is automatically chosen.\nListenMulticastUDP is just for convenience of simple, small applications.\nThere are golang.org/x/net/ipv4 and golang.org/x/net/ipv6 packages for\ngeneral purpose uses.\nNote that ListenMulticastUDP will set the IP_MULTICAST_LOOP socket option to\n0 under IPPROTO_IP, to disable loopback of multicast packets.
ListenPacket ListenConfig.ListenPacket(ctx context.Context, network, address string) (PacketConn, error)\n
ListenPacket net.ListenPacket(network, address string) (PacketConn, error)\nListenPacket announces on the local network address.\nThe network must be "udp", "udp4", "udp6", "unixgram", or an IP transport.\nThe IP transports are "ip", "ip4", or "ip6" followed by a colon and a\nliteral protocol number or a protocol name, as in "ip:1" or "ip:icmp".\nFor UDP and IP networks, if the host in the address parameter is empty or a\nliteral unspecified IP address, ListenPacket listens on all available IP\naddresses of the local system except multicast IP addresses. To only use\nIPv4, use network "udp4" or "ip4:proto". The address can use a host name,\nbut this is not recommended, because it will create a listener for at most\none of the host's IP addresses. If the port in the address parameter is\nempty or "0", as in "127.0.0.1:" or "[::1]:0", a port number is\nautomatically chosen. The LocalAddr method of PacketConn can be used to\ndiscover the chosen port.\nSee func Dial for a description of the network and address parameters.\nListenPacket uses context.Background internally; to specify the context, use\nListenConfig.ListenPacket.
ListenTCP net.ListenTCP(network string, laddr *TCPAddr) (*TCPListener, error)\nListenTCP acts like Listen for TCP networks.\nThe network must be a TCP network name; see func Dial for details.\nIf the IP field of laddr is nil or an unspecified IP address, ListenTCP\nlistens on all available unicast and anycast IP addresses of the local\nsystem. If the Port field of laddr is 0, a port number is automatically\nchosen.
ListenUDP net.ListenUDP(network string, laddr *UDPAddr) (*UDPConn, error)\nListenUDP acts like ListenPacket for UDP networks.\nThe network must be a UDP network name; see func Dial for details.\nIf the IP field of laddr is nil or an unspecified IP address, ListenUDP\nlistens on all available IP addresses of the local system except multicast\nIP addresses. If the Port field of laddr is 0, a port number is\nautomatically chosen.
ListenUnix net.ListenUnix(network string, laddr *UnixAddr) (*UnixListener, error)\nListenUnix acts like Listen for Unix networks.\nThe network must be "unix" or "unixpacket".
ListenUnixgram net.ListenUnixgram(network string, laddr *UnixAddr) (*UnixConn, error)\nListenUnixgram acts like ListenPacket for Unix networks.\nThe network must be "unixgram".
Listener net.Listener\nA Listener is a generic network listener for stream-oriented protocols.\n\nMultiple goroutines may invoke methods on a Listener simultaneously.\n
LiteralPrefix Regexp.LiteralPrefix() (prefix string, complete bool)\n
Load Map.Load(key interface{}) (value interface{}, ok bool)\n
LoadAndDelete Map.LoadAndDelete(key interface{}) (value interface{}, loaded bool)\n
LoadLocation Location.LoadLocation(name string) (*Location, error)\n
LoadLocation time.LoadLocation(name string) (*Location, error)\nLoadLocation returns the Location with the given name.\nIf the name is "" or "UTC", LoadLocation returns UTC. If the name is\n"Local", LoadLocation returns Local.\nOtherwise, the name is taken to be a location name corresponding to a file\nin the IANA Time Zone database, such as "America/New_York".\nThe time zone database needed by LoadLocation may not be present on all\nsystems, especially non-Unix systems. LoadLocation looks in the directory or\nuncompressed zip file named by the ZONEINFO environment variable, if any,\nthen looks in known installation locations on Unix systems, and finally\nlooks in $GOROOT/lib/time/zoneinfo.zip.
LoadLocationFromTZData Location.LoadLocationFromTZData(name string, data []byte) (*Location, error)\n
LoadLocationFromTZData time.LoadLocationFromTZData(name string, data []byte) (*Location, error)\nLoadLocationFromTZData returns a Location with the given name initialized\nfrom the IANA Time Zone database-formatted data. The data should be in the\nformat of a standard IANA time zone file (for example, the content of\n/etc/localtime on Unix systems).
LoadOrStore Map.LoadOrStore(key, value interface{}) (actual interface{}, loaded bool)\n
Local Time.Local() Time\n
LocalAddr IPConn.LocalAddr() Addr\n
LocalAddr TCPConn.LocalAddr() Addr\n
LocalAddr UDPConn.LocalAddr() Addr\n
LocalAddr UnixConn.LocalAddr() Addr\n
Location Response.Location() (*url.URL, error)\n
Location Time.Location() *Location\n
Location time.Location\nA Location maps time instants to the zone in use at that time. Typically,\nthe Location represents the collection of time offsets in use in a\ngeographical area. For many Locations the time offset varies depending on\nwhether daylight savings time is in use at the time instant.\n
Lock Mutex.Lock()\n
Lock RWMutex.Lock()\n
LockOSThread runtime.LockOSThread()\nLockOSThread wires the calling goroutine to its current operating system\nthread. The calling goroutine will always execute in that thread, and no\nother goroutine will execute in it, until the calling goroutine has made as\nmany calls to UnlockOSThread as to LockOSThread. If the calling goroutine\nexits without unlocking the thread, the thread will be terminated.\nAll init functions are run on the startup thread. Calling LockOSThread from\nan init function will cause the main function to be invoked on that thread.\nA goroutine should call LockOSThread before calling OS services or non-Go\nlibrary functions that depend on per-thread state.
Locker sync.Locker\nA Locker represents an object that can be locked and unlocked.\n
Log B.Log(args ...interface{})\n
Log T.Log(args ...interface{})\n
Log cmplx.Log(x complex128) complex128\nLog returns the natural logarithm of x.
Log math.Log(x float64) float64\nLog returns the natural logarithm of x.\nSpecial cases are:\nLog(+Inf) = +Inf\nLog(0) = -Inf\nLog(x < 0) = NaN\nLog(NaN) = NaN
Log10 cmplx.Log10(x complex128) complex128\nLog10 returns the decimal logarithm of x.
Log10 math.Log10(x float64) float64\nLog10 returns the decimal logarithm of x. The special cases are the same as\nfor Log.
Log1p math.Log1p(x float64) float64\nLog1p returns the natural logarithm of 1 plus its argument x. It is more\naccurate than Log(1 + x) when x is near zero.\nSpecial cases are:\nLog1p(+Inf) = +Inf\nLog1p(±0) = ±0\nLog1p(-1) = -Inf\nLog1p(x < -1) = NaN\nLog1p(NaN) = NaN
Log2 math.Log2(x float64) float64\nLog2 returns the binary logarithm of x. The special cases are the same as\nfor Log.
Logb math.Logb(x float64) float64\nLogb returns the binary exponent of x.\nSpecial cases are:\nLogb(±Inf) = +Inf\nLogb(0) = -Inf\nLogb(NaN) = NaN
Logf B.Logf(format string, args ...interface{})\n
Logf T.Logf(format string, args ...interface{})\n
Logger log.Logger\nA Logger represents an active logging object that generates lines of output\nto an io.Writer. Each logging operation makes a single call to the Writer's\nWrite method. A Logger can be used simultaneously from multiple goroutines;\nit guarantees to serialize access to the Writer.\n
Longest Regexp.Longest()\n
LookPath exec.LookPath(file string) (string, error)\nLookPath searches for an executable named file in the directories named by\nthe PATH environment variable. If file contains a slash, it is tried\ndirectly and the PATH is not consulted. The result may be an absolute path\nor a path relative to the current directory.
Lookup Flag.Lookup(name string) *Flag\n
Lookup FlagSet.Lookup(name string) *Flag\n
Lookup Template.Lookup(name string) *Template\n
Lookup Template.Lookup(name string) *Template\n
Lookup flag.Lookup(name string) *Flag\nLookup returns the Flag structure of the named command-line flag, returning\nnil if none exists.
LookupAddr Resolver.LookupAddr(ctx context.Context, addr string) ([]string, error)\n
LookupAddr net.LookupAddr(addr string) (names []string, err error)\nLookupAddr performs a reverse lookup for the given address, returning a list\nof names mapping to that address.\nThe returned names are validated to be properly formatted\npresentation-format domain names. If the response contains invalid names,\nthose records are filtered out and an error will be returned alongside the\nthe remaining results, if any.\nWhen using the host C library resolver, at most one result will be returned.\nTo bypass the host resolver, use a custom Resolver.\nLookupAddr uses context.Background internally; to specify the context, use\nResolver.LookupAddr.
LookupCNAME Resolver.LookupCNAME(ctx context.Context, host string) (string, error)\n
LookupCNAME net.LookupCNAME(host string) (cname string, err error)\nLookupCNAME returns the canonical name for the given host. Callers that do\nnot care about the canonical name can call LookupHost or LookupIP directly;\nboth take care of resolving the canonical name as part of the lookup.\nA canonical name is the final name after following zero or more CNAME\nrecords. LookupCNAME does not return an error if host does not contain DNS\n"CNAME" records, as long as host resolves to address records.\nThe returned canonical name is validated to be a properly formatted\npresentation-format domain name.\nLookupCNAME uses context.Background internally; to specify the context, use\nResolver.LookupCNAME.
LookupEnv os.LookupEnv(key string) (string, bool)\nLookupEnv retrieves the value of the environment variable named by the key.\nIf the variable is present in the environment the value (which may be empty)\nis returned and the boolean is true. Otherwise the returned value will be\nempty and the boolean will be false.
LookupHost Resolver.LookupHost(ctx context.Context, host string) (addrs []string, err error)\n
LookupHost net.LookupHost(host string) (addrs []string, err error)\nLookupHost looks up the given host using the local resolver. It returns a\nslice of that host's addresses.\nLookupHost uses context.Background internally; to specify the context, use\nResolver.LookupHost.
LookupIP Resolver.LookupIP(ctx context.Context, network, host string) ([]IP, error)\n
LookupIP net.LookupIP(host string) ([]IP, error)\nLookupIP looks up host using the local resolver. It returns a slice of that\nhost's IPv4 and IPv6 addresses.
LookupIPAddr Resolver.LookupIPAddr(ctx context.Context, host string) ([]IPAddr, error)\n
LookupMX Resolver.LookupMX(ctx context.Context, name string) ([]*MX, error)\n
LookupMX net.LookupMX(name string) ([]*MX, error)\nLookupMX returns the DNS MX records for the given domain name sorted by\npreference.\nThe returned mail server names are validated to be properly formatted\npresentation-format domain names. If the response contains invalid names,\nthose records are filtered out and an error will be returned alongside the\nthe remaining results, if any.\nLookupMX uses context.Background internally; to specify the context, use\nResolver.LookupMX.
LookupNS Resolver.LookupNS(ctx context.Context, name string) ([]*NS, error)\n
LookupNS net.LookupNS(name string) ([]*NS, error)\nLookupNS returns the DNS NS records for the given domain name.\nThe returned name server names are validated to be properly formatted\npresentation-format domain names. If the response contains invalid names,\nthose records are filtered out and an error will be returned alongside the\nthe remaining results, if any.\nLookupNS uses context.Background internally; to specify the context, use\nResolver.LookupNS.
LookupPort Resolver.LookupPort(ctx context.Context, network, service string) (port int, err error)\n
LookupPort net.LookupPort(network, service string) (port int, err error)\nLookupPort looks up the port for the given network and service.\nLookupPort uses context.Background internally; to specify the context, use\nResolver.LookupPort.
LookupSRV Resolver.LookupSRV(ctx context.Context, service, proto, name string) (string, []*SRV, error)\n
LookupSRV net.LookupSRV(service, proto, name string) (cname string, addrs []*SRV, err error)\nLookupSRV tries to resolve an SRV query of the given service, protocol, and\ndomain name. The proto is "tcp" or "udp". The returned records are sorted by\npriority and randomized by weight within a priority.\nLookupSRV constructs the DNS name to look up following RFC 2782. That is, it\nlooks up _service._proto.name. To accommodate services publishing SRV\nrecords under non-standard names, if both service and proto are empty\nstrings, LookupSRV looks up name directly.\nThe returned service names are validated to be properly formatted\npresentation-format domain names. If the response contains invalid names,\nthose records are filtered out and an error will be returned alongside the\nthe remaining results, if any.
LookupTXT Resolver.LookupTXT(ctx context.Context, name string) ([]string, error)\n
LookupTXT net.LookupTXT(name string) ([]string, error)\nLookupTXT returns the DNS TXT records for the given domain name.\nLookupTXT uses context.Background internally; to specify the context, use\nResolver.LookupTXT.
Lstat os.Lstat(name string) (FileInfo, error)\nLstat returns a FileInfo describing the named file. If the file is a\nsymbolic link, the returned FileInfo describes the symbolic link. Lstat\nmakes no attempt to follow the link. If there is an error, it will be of\ntype *PathError.
M testing.M\nM is a type passed to a TestMain function to run the actual tests.\n
MX net.MX\nAn MX represents a single DNS MX record.\n
Main testing.Main(matchString func(pat, str string) (bool, error), tests []InternalTest)\nMain is an internal function, part of the implementation of the "go test"\ncommand. It was exported because it is cross-package and predates "internal"\npackages. It is no longer used by "go test" but preserved, as much as\npossible, for other systems that simulate "go test" using Main, but Main\nsometimes cannot be updated as new functionality is added to the testing\npackage. Systems simulating "go test" should be updated to use MainStart.
MainStart M.MainStart(deps testDeps, tests []InternalTest, benchmarks []InternalBenchmark) *M\n
MainStart testing.MainStart(deps testDeps, tests []InternalTest, benchmarks []InternalBenchmark) *M\nMainStart is meant for use by tests generated by 'go test'. It is not meant\nto be called directly and is not subject to the Go 1 compatibility document.\nIt may change signature from release to release.
Map bytes.Map(mapping func(r rune) rune, s []byte) []byte\nMap returns a copy of the byte slice s with all its characters modified\naccording to the mapping function. If mapping returns a negative value, the\ncharacter is dropped from the byte slice with no replacement. The characters\nin s and the output are interpreted as UTF-8-encoded code points.
Map strings.Map(mapping func(rune) rune, s string) string\nMap returns a copy of the string s with all its characters modified\naccording to the mapping function. If mapping returns a negative value, the\ncharacter is dropped from the string with no replacement.
Map sync.Map\nMap is like a Go map[interface{}]interface{} but is safe for concurrent use\nby multiple goroutines without additional locking or coordination. Loads,\nstores, and deletes run in amortized constant time.\n\nThe Map type is specialized. Most code should use a plain Go map instead,\nwith separate locking or coordination, for better type safety and to make it\neasier to maintain other invariants along with the map content.\n\nThe Map type is optimized for two common use cases: (1) when the entry for a\ngiven key is only ever written once but read many times, as in caches that\nonly grow, or (2) when multiple goroutines read, write, and overwrite\nentries for disjoint sets of keys. In these two cases, use of a Map may\nsignificantly reduce lock contention compared to a Go map paired with a\nseparate Mutex or RWMutex.\n\nThe zero Map is empty and ready for use. A Map must not be copied after\nfirst use.\n
MapFile fstest.MapFile\nA MapFile describes a single file in a MapFS.\n
Marshal json.Marshal(v interface{}) ([]byte, error)\nMarshal returns the JSON encoding of v.\nMarshal traverses the value v recursively. If an encountered value\nimplements the Marshaler interface and is not a nil pointer, Marshal calls\nits MarshalJSON method to produce JSON. If no MarshalJSON method is present\nbut the value implements encoding.TextMarshaler instead, Marshal calls its\nMarshalText method and encodes the result as a JSON string. The nil pointer\nexception is not strictly necessary but mimics a similar, necessary\nexception in the behavior of UnmarshalJSON.\nOtherwise, Marshal uses the following type-dependent default encodings:\nBoolean values encode as JSON booleans.\nFloating point, integer, and Number values encode as JSON numbers.\nString values encode as JSON strings coerced to valid UTF-8, replacing\ninvalid bytes with the Unicode replacement rune. So that the JSON will be\nsafe to embed inside HTML <script> tags, the string is encoded using\nHTMLEscape, which replaces "<", ">", "&", U+2028, and U+2029 are escaped to\n"\u003c","\u003e", "\u0026", "\u2028", and "\u2029". This replacement can be\ndisabled when using an Encoder, by calling SetEscapeHTML(false).\nArray and slice values encode as JSON arrays, except that []byte encodes as\na base64-encoded string, and a nil slice encodes as the null JSON value.\nStruct values encode as JSON objects. Each exported struct field becomes a\nmember of the object, using the field name as the object key, unless the\nfield is omitted for one of the reasons given below.\nThe encoding of each struct field can be customized by the format string\nstored under the "json" key in the struct field's tag. The format string\ngives the name of the field, possibly followed by a comma-separated list of\noptions. The name may be empty in order to specify options without\noverriding the default field name.\nThe "omitempty" option specifies that the field should be omitted from the\nencoding if the field has an empty value, defined as false, 0, a nil\npointer, a nil interface value, and any empty array, slice, map, or string.\nAs a special case, if the field tag is "-", the field is always omitted.\nNote that a field with name "-" can still be generated using the tag "-,".\nExamples of struct field tags and their meanings:\n// Field appears in JSON as key "myName".\nField int `json:"myName"`\n// Field appears in JSON as key "myName" and\n// the field is omitted from the object if its value is empty,\n// as defined above.\nField int `json:"myName,omitempty"`\n// Field appears in JSON as key "Field" (the default), but\n// the field is skipped if empty.\n// Note the leading comma.\nField int `json:",omitempty"`\n// Field is ignored by this package.\nField int `json:"-"`\n// Field appears in JSON as key "-".\nField int `json:"-,"`\nThe "string" option signals that a field is stored as JSON inside a\nJSON-encoded string. It applies only to fields of string, floating point,\ninteger, or boolean types. This extra level of encoding is sometimes used\nwhen communicating with JavaScript programs:\nInt64String int64 `json:",string"`\nThe key name will be used if it's a non-empty string consisting of only\nUnicode letters, digits, and ASCII punctuation except quotation marks,\nbackslash, and comma.\nAnonymous struct fields are usually marshaled as if their inner exported\nfields were fields in the outer struct, subject to the usual Go visibility\nrules amended as described in the next paragraph. An anonymous struct field\nwith a name given in its JSON tag is treated as having that name, rather\nthan being anonymous. An anonymous struct field of interface type is treated\nthe same as having that type as its name, rather than being anonymous.\nThe Go visibility rules for struct fields are amended for JSON when deciding\nwhich field to marshal or unmarshal. If there are multiple fields at the\nsame level, and that level is the least nested (and would therefore be the\nnesting level selected by the usual Go rules), the following extra rules\napply:\n1) Of those fields, if any are JSON-tagged, only tagged fields are\nconsidered, even if there are multiple untagged fields that would otherwise\nconflict.\n2) If there is exactly one field (tagged or not according to the first\nrule), that is selected.\n3) Otherwise there are multiple fields, and all are ignored; no error\noccurs.\nHandling of anonymous struct fields is new in Go 1.1. Prior to Go 1.1,\nanonymous struct fields were ignored. To force ignoring of an anonymous\nstruct field in both current and earlier versions, give the field a JSON tag\nof "-".\nMap values encode as JSON objects. The map's key type must either be a\nstring, an integer type, or implement encoding.TextMarshaler. The map keys\nare sorted and used as JSON object keys by applying the following rules,\nsubject to the UTF-8 coercion described for string values above:\n- keys of any string type are used directly\n- encoding.TextMarshalers are marshaled\n- integer keys are converted to strings\nPointer values encode as the value pointed to. A nil pointer encodes as the\nnull JSON value.\nInterface values encode as the value contained in the interface. A nil\ninterface value encodes as the null JSON value.\nChannel, complex, and function values cannot be encoded in JSON. Attempting\nto encode such a value causes Marshal to return an UnsupportedTypeError.\nJSON cannot represent cyclic data structures and Marshal does not handle\nthem. Passing cyclic structures to Marshal will result in an error.
Marshal xml.Marshal(v interface{}) ([]byte, error)\nMarshal returns the XML encoding of v.\nMarshal handles an array or slice by marshaling each of the elements.\nMarshal handles a pointer by marshaling the value it points at or, if the\npointer is nil, by writing nothing. Marshal handles an interface value by\nmarshaling the value it contains or, if the interface value is nil, by\nwriting nothing. Marshal handles all other data by writing one or more XML\nelements containing the data.\nThe name for the XML elements is taken from, in order of preference:\n- the tag on the XMLName field, if the data is a struct\n- the value of the XMLName field of type Name\n- the tag of the struct field used to obtain the data\n- the name of the struct field used to obtain the data\n- the name of the marshaled type\nThe XML element for a struct contains marshaled elements for each of the\nexported fields of the struct, with these exceptions:\n- the XMLName field, described above, is omitted.\n- a field with tag "-" is omitted.\n- a field with tag "name,attr" becomes an attribute with\nthe given name in the XML element.\n- a field with tag ",attr" becomes an attribute with the\nfield name in the XML element.\n- a field with tag ",chardata" is written as character data,\nnot as an XML element.\n- a field with tag ",cdata" is written as character data\nwrapped in one or more <![CDATA[ ... ]]> tags, not as an XML element.\n- a field with tag ",innerxml" is written verbatim, not subject\nto the usual marshaling procedure.\n- a field with tag ",comment" is written as an XML comment, not\nsubject to the usual marshaling procedure. It must not contain\nthe "--" string within it.\n- a field with a tag including the "omitempty" option is omitted\nif the field value is empty. The empty values are false, 0, any\nnil pointer or interface value, and any array, slice, map, or\nstring of length zero.\n- an anonymous struct field is handled as if the fields of its\nvalue were part of the outer struct.\n- a field implementing Marshaler is written by calling its MarshalXML\nmethod.\n- a field implementing encoding.TextMarshaler is written by encoding the\nresult of its MarshalText method as text.\nIf a field uses a tag "a>b>c", then the element c will be nested inside\nparent elements a and b. Fields that appear next to each other that name the\nsame parent will be enclosed in one XML element.\nIf the XML name for a struct field is defined by both the field tag and the\nstruct's XMLName field, the names must match.\nSee MarshalIndent for an example.\nMarshal will return an error if asked to marshal a channel, function, or\nmap.
MarshalBinary Time.MarshalBinary() ([]byte, error)\n
MarshalBinary URL.MarshalBinary() (text []byte, err error)\n
MarshalIndent json.MarshalIndent(v interface{}, prefix, indent string) ([]byte, error)\nMarshalIndent is like Marshal but applies Indent to format the output. Each\nJSON element in the output will begin on a new line beginning with prefix\nfollowed by one or more copies of indent according to the indentation\nnesting.
MarshalIndent xml.MarshalIndent(v interface{}, prefix, indent string) ([]byte, error)\nMarshalIndent works like Marshal, but each XML element begins on a new\nindented line that starts with prefix and is followed by one or more copies\nof indent according to the nesting depth.
MarshalJSON Time.MarshalJSON() ([]byte, error)\n
MarshalText Time.MarshalText() ([]byte, error)\n
Marshaler json.Marshaler\nMarshaler is the interface implemented by types that can marshal themselves\ninto valid JSON.\n
Marshaler xml.Marshaler\nMarshaler is the interface implemented by objects that can marshal\nthemselves into valid XML elements.\n\nMarshalXML encodes the receiver as zero or more XML elements. By convention,\narrays or slices are typically encoded as a sequence of elements, one per\nentry. Using start as the element tag is not required, but doing so will\nenable Unmarshal to match the XML elements to the correct struct field. One\ncommon implementation strategy is to construct a separate value with a\nlayout corresponding to the desired XML and then to encode it using\ne.EncodeElement. Another common strategy is to use repeated calls to\ne.EncodeToken to generate the XML output one token at a time. The sequence\nof encoded tokens must make up zero or more valid XML elements.\n
MarshalerAttr xml.MarshalerAttr\nMarshalerAttr is the interface implemented by objects that can marshal\nthemselves into valid XML attributes.\n\nMarshalXMLAttr returns an XML attribute with the encoded value of the\nreceiver. Using name as the attribute name is not required, but doing so\nwill enable Unmarshal to match the attribute to the correct struct field. If\nMarshalXMLAttr returns the zero attribute Attr{}, no attribute will be\ngenerated in the output. MarshalXMLAttr is used only for struct fields with\nthe "attr" option in the field tag.\n
MarshalerError json.MarshalerError\nA MarshalerError represents an error from calling a MarshalJSON or\nMarshalText method.\n
Match Regexp.Match(b []byte) bool\n
Match filepath.Match(pattern, name string) (matched bool, err error)\nMatch reports whether name matches the shell file name pattern. The pattern\nsyntax is:\npattern:\n{ term }\nterm:\n'*'         matches any sequence of non-Separator characters\n'?'         matches any single non-Separator character\n'[' [ '^' ] { character-range } ']'\ncharacter class (must be non-empty)\nc           matches character c (c != '*', '?', '\\', '[')\n'\\' c      matches character c\ncharacter-range:\nc           matches character c (c != '\\', '-', ']')\n'\\' c      matches character c\nlo '-' hi   matches character c for lo <= c <= hi\nMatch requires pattern to match all of name, not just a substring. The only\npossible returned error is ErrBadPattern, when pattern is malformed.\nOn Windows, escaping is disabled. Instead, '\\' is treated as path\nseparator.
Match path.Match(pattern, name string) (matched bool, err error)\nMatch reports whether name matches the shell pattern. The pattern syntax is:\npattern:\n{ term }\nterm:\n'*'         matches any sequence of non-/ characters\n'?'         matches any single non-/ character\n'[' [ '^' ] { character-range } ']'\ncharacter class (must be non-empty)\nc           matches character c (c != '*', '?', '\\', '[')\n'\\' c      matches character c\ncharacter-range:\nc           matches character c (c != '\\', '-', ']')\n'\\' c      matches character c\nlo '-' hi   matches character c for lo <= c <= hi\nMatch requires pattern to match all of name, not just a substring. The only\npossible returned error is ErrBadPattern, when pattern is malformed.
Match regexp.Match(pattern string, b []byte) (matched bool, err error)\nMatch reports whether the byte slice b contains any match of the regular\nexpression pattern. More complicated queries need to use Compile and the\nfull Regexp interface.
MatchEmptyWidth Inst.MatchEmptyWidth(before rune, after rune) bool\n
MatchReader Regexp.MatchReader(r io.RuneReader) bool\n
MatchReader regexp.MatchReader(pattern string, r io.RuneReader) (matched bool, err error)\nMatchReader reports whether the text returned by the RuneReader contains any\nmatch of the regular expression pattern. More complicated queries need to\nuse Compile and the full Regexp interface.
MatchRune Inst.MatchRune(r rune) bool\n
MatchRunePos Inst.MatchRunePos(r rune) int\n
MatchString Regexp.MatchString(s string) bool\n
MatchString regexp.MatchString(pattern string, s string) (matched bool, err error)\nMatchString reports whether the string s contains any match of the regular\nexpression pattern. More complicated queries need to use Compile and the\nfull Regexp interface.
Max math.Max(x, y float64) float64\nMax returns the larger of x or y.\nSpecial cases are:\nMax(x, +Inf) = Max(+Inf, x) = +Inf\nMax(x, NaN) = Max(NaN, x) = NaN\nMax(+0, ±0) = Max(±0, +0) = +0\nMax(-0, -0) = -0
MaxBytesReader http.MaxBytesReader(w ResponseWriter, r io.ReadCloser, n int64) io.ReadCloser\nMaxBytesReader is similar to io.LimitReader but is intended for limiting the\nsize of incoming request bodies. In contrast to io.LimitReader,\nMaxBytesReader's result is a ReadCloser, returns a non-EOF error for a Read\nbeyond the limit, and closes the underlying reader when its Close method is\ncalled.\nMaxBytesReader prevents clients from accidentally or maliciously sending a\nlarge request and wasting server resources.
MaxCap Regexp.MaxCap() int\n
MemProfile runtime.MemProfile(p []MemProfileRecord, inuseZero bool) (n int, ok bool)\nMemProfile returns a profile of memory allocated and freed per allocation\nsite.\nMemProfile returns n, the number of records in the current memory profile.\nIf len(p) >= n, MemProfile copies the profile into p and returns n, true. If\nlen(p) < n, MemProfile does not change p and returns n, false.\nIf inuseZero is true, the profile includes allocation records where\nr.AllocBytes > 0 but r.AllocBytes == r.FreeBytes. These are sites where\nmemory was allocated, but it has all been released back to the runtime.\nThe returned profile may be up to two garbage collection cycles old. This is\nto avoid skewing the profile toward allocations; because allocations happen\nin real time but frees are delayed until the garbage collector performs\nsweeping, the profile only accounts for allocations that have had a chance\nto be freed by the garbage collector.\nMost clients should use the runtime/pprof package or the testing package's\n-test.memprofile flag instead of calling MemProfile directly.
MemProfileRecord runtime.MemProfileRecord\nA MemProfileRecord describes the live objects allocated by a particular call\nsequence (stack trace).\n
MemStats runtime.MemStats\nA MemStats records statistics about the memory allocator.\n
MemString BenchmarkResult.MemString() string\n
Min math.Min(x, y float64) float64\nMin returns the smaller of x or y.\nSpecial cases are:\nMin(x, -Inf) = Min(-Inf, x) = -Inf\nMin(x, NaN) = Min(NaN, x) = NaN\nMin(-0, ±0) = Min(±0, -0) = -0
Minute Time.Minute() int\n
Mkdir os.Mkdir(name string, perm FileMode) error\nMkdir creates a new directory with the specified name and permission bits\n(before umask). If there is an error, it will be of type *PathError.
MkdirAll os.MkdirAll(path string, perm FileMode) error\nMkdirAll creates a directory named path, along with any necessary parents,\nand returns nil, or else returns an error. The permission bits perm (before\numask) are used for all directories that MkdirAll creates. If path is\nalready a directory, MkdirAll does nothing and returns nil.
MkdirTemp os.MkdirTemp(dir, pattern string) (string, error)\nMkdirTemp creates a new temporary directory in the directory dir and returns\nthe pathname of the new directory. The new directory's name is generated by\nadding a random string to the end of pattern. If pattern includes a "*", the\nrandom string replaces the last "*" instead. If dir is the empty string,\nMkdirTemp uses the default directory for temporary files, as returned by\nTempDir. Multiple programs or goroutines calling MkdirTemp simultaneously\nwill not choose the same directory. It is the caller's responsibility to\nremove the directory when it is no longer needed.
Mod math.Mod(x, y float64) float64\nMod returns the floating-point remainder of x/y. The magnitude of the result\nis less than y and its sign agrees with that of x.\nSpecial cases are:\nMod(±Inf, y) = NaN\nMod(NaN, y) = NaN\nMod(x, 0) = NaN\nMod(x, ±Inf) = x\nMod(x, NaN) = NaN
Modf math.Modf(f float64) (int float64, frac float64)\nModf returns integer and fractional floating-point numbers that sum to f.\nBoth values have the same sign as f.\nSpecial cases are:\nModf(±Inf) = ±Inf, NaN\nModf(NaN) = NaN, NaN
Month Time.Month() Month\n
More Decoder.More() bool\n
MultiReader Reader.MultiReader(readers ...Reader) Reader\n
MultiReader io.MultiReader(readers ...Reader) Reader\nMultiReader returns a Reader that's the logical concatenation of the\nprovided input readers. They're read sequentially. Once all inputs have\nreturned EOF, Read will return EOF. If any of the readers return a non-nil,\nnon-EOF error, Read will return that error.
MultiWriter Writer.MultiWriter(writers ...Writer) Writer\n
MultiWriter io.MultiWriter(writers ...Writer) Writer\nMultiWriter creates a writer that duplicates its writes to all the provided\nwriters, similar to the Unix tee(1) command.\nEach write is written to each listed writer, one at a time. If a listed\nwriter returns an error, that overall write operation stops and returns the\nerror; it does not continue down the list.
MulticastAddrs Interface.MulticastAddrs() ([]Addr, error)\n
MultipartReader Request.MultipartReader() (*multipart.Reader, error)\n
Must Template.Must(t *Template, err error) *Template\n
Must Template.Must(t *Template, err error) *Template\n
Must template.Must(t *Template, err error) *Template\nMust is a helper that wraps a call to a function returning (*Template,\nerror) and panics if the error is non-nil. It is intended for use in\nvariable initializations such as\nvar t = template.Must(template.New("name").Parse("html"))
Must template.Must(t *Template, err error) *Template\nMust is a helper that wraps a call to a function returning (*Template,\nerror) and panics if the error is non-nil. It is intended for use in\nvariable initializations such as\nvar t = template.Must(template.New("name").Parse("text"))
MustCompile Regexp.MustCompile(str string) *Regexp\n
MustCompile regexp.MustCompile(str string) *Regexp\nMustCompile is like Compile but panics if the expression cannot be parsed.\nIt simplifies safe initialization of global variables holding compiled\nregular expressions.
MustCompilePOSIX Regexp.MustCompilePOSIX(str string) *Regexp\n
MustCompilePOSIX regexp.MustCompilePOSIX(str string) *Regexp\nMustCompilePOSIX is like CompilePOSIX but panics if the expression cannot be\nparsed. It simplifies safe initialization of global variables holding\ncompiled regular expressions.
Mutex sync.Mutex\nA Mutex is a mutual exclusion lock. The zero value for a Mutex is an\nunlocked mutex.\n\nA Mutex must not be copied after first use.\n
MutexProfile runtime.MutexProfile(p []BlockProfileRecord) (n int, ok bool)\nMutexProfile returns n, the number of records in the current mutex profile.\nIf len(p) >= n, MutexProfile copies the profile into p and returns n, true.\nOtherwise, MutexProfile does not change p, and returns n, false.\nMost clients should use the runtime/pprof package instead of calling\nMutexProfile directly.
NArg FlagSet.NArg() int\n
NArg flag.NArg() int\nNArg is the number of arguments remaining after flags have been processed.
NFlag FlagSet.NFlag() int\n
NFlag flag.NFlag() int\nNFlag returns the number of command-line flags that have been set.
NS net.NS\nAn NS represents a single DNS NS record.\n
NaN cmplx.NaN() complex128\nNaN returns a complex “not-a-number” value.
NaN math.NaN() float64\nNaN returns an IEEE 754 “not-a-number” value.
Name B.Name() string\n
Name File.Name() string\n
Name FlagSet.Name() string\n
Name Func.Name() string\n
Name T.Name() string\n
Name Template.Name() string\n
Name Template.Name() string\n
Name xml.Name\nA Name represents an XML name (Local) annotated with a name space identifier\n(Space). In tokens returned by Decoder.Token, the Space identifier is given\nas a canonical URL, not the short prefix used in the document being parsed.\n
Nanosecond Time.Nanosecond() int\n
Network IPAddr.Network() string\n
Network IPNet.Network() string\n
Network TCPAddr.Network() string\n
Network UDPAddr.Network() string\n
Network UnixAddr.Network() string\n
New Logger.New(out io.Writer, prefix string, flag int) *Logger\n
New Rand.New(src Source) *Rand\n
New Template.New(name string) *Template\n
New Template.New(name string) *Template\n
New Template.New(name string) *Template\n
New Template.New(name string) *Template\n
New Tree.New(name string, funcs ...map[string]interface{}) *Tree\n
New errors.New(text string) error\nNew returns an error that formats as the given text. Each call to New\nreturns a distinct error value even if the text is identical.
New log.New(out io.Writer, prefix string, flag int) *Logger\nNew creates a new Logger. The out variable sets the destination to which log\ndata will be written. The prefix appears at the beginning of each generated\nlog line, or after the log header if the Lmsgprefix flag is provided. The\nflag argument defines the logging properties.
New parse.New(name string, funcs ...map[string]interface{}) *Tree\nNew allocates a new parse tree with the given name.
New rand.New(src Source) *Rand\nNew returns a new Rand that uses random values from src to generate other\nrandom values.
New template.New(name string) *Template\nNew allocates a new HTML template with the given name.
New template.New(name string) *Template\nNew allocates a new, undefined template with the given name.
NewBuffer Buffer.NewBuffer(buf []byte) *Buffer\n
NewBuffer bytes.NewBuffer(buf []byte) *Buffer\nNewBuffer creates and initializes a new Buffer using buf as its initial\ncontents. The new Buffer takes ownership of buf, and the caller should not\nuse buf after this call. NewBuffer is intended to prepare a Buffer to read\nexisting data. It can also be used to set the initial size of the internal\nbuffer for writing. To do that, buf should have the desired capacity but a\nlength of zero.\nIn most cases, new(Buffer) (or just declaring a Buffer variable) is\nsufficient to initialize a Buffer.
NewBufferString Buffer.NewBufferString(s string) *Buffer\n
NewBufferString bytes.NewBufferString(s string) *Buffer\nNewBufferString creates and initializes a new Buffer using string s as its\ninitial contents. It is intended to prepare a buffer to read an existing\nstring.\nIn most cases, new(Buffer) (or just declaring a Buffer variable) is\nsufficient to initialize a Buffer.
NewCond Cond.NewCond(l Locker) *Cond\n
NewCond sync.NewCond(l Locker) *Cond\nNewCond returns a new Cond with Locker l.
NewDecoder Decoder.NewDecoder(r io.Reader) *Decoder\n
NewDecoder Decoder.NewDecoder(r io.Reader) *Decoder\n
NewDecoder base32.NewDecoder(enc *Encoding, r io.Reader) io.Reader\nNewDecoder constructs a new base32 stream decoder.
NewDecoder base64.NewDecoder(enc *Encoding, r io.Reader) io.Reader\nNewDecoder constructs a new base64 stream decoder.
NewDecoder hex.NewDecoder(r io.Reader) io.Reader\nNewDecoder returns an io.Reader that decodes hexadecimal characters from r.\nNewDecoder expects that r contain only an even number of hexadecimal\ncharacters.
NewDecoder json.NewDecoder(r io.Reader) *Decoder\nNewDecoder returns a new decoder that reads from r.\nThe decoder introduces its own buffering and may read data from r beyond the\nJSON values requested.
NewDecoder xml.NewDecoder(r io.Reader) *Decoder\nNewDecoder creates a new XML parser reading from r. If r does not implement\nio.ByteReader, NewDecoder will do its own buffering.
NewEncoder Encoder.NewEncoder(w io.Writer) *Encoder\n
NewEncoder Encoder.NewEncoder(w io.Writer) *Encoder\n
NewEncoder base32.NewEncoder(enc *Encoding, w io.Writer) io.WriteCloser\nNewEncoder returns a new base32 stream encoder. Data written to the returned\nwriter will be encoded using enc and then written to w. Base32 encodings\noperate in 5-byte blocks; when finished writing, the caller must Close the\nreturned encoder to flush any partially written blocks.
NewEncoder base64.NewEncoder(enc *Encoding, w io.Writer) io.WriteCloser\nNewEncoder returns a new base64 stream encoder. Data written to the returned\nwriter will be encoded using enc and then written to w. Base64 encodings\noperate in 4-byte blocks; when finished writing, the caller must Close the\nreturned encoder to flush any partially written blocks.
NewEncoder hex.NewEncoder(w io.Writer) io.Writer\nNewEncoder returns an io.Writer that writes lowercase hexadecimal characters\nto w.
NewEncoder json.NewEncoder(w io.Writer) *Encoder\nNewEncoder returns a new encoder that writes to w.
NewEncoder xml.NewEncoder(w io.Writer) *Encoder\nNewEncoder returns a new encoder that writes to w.
NewEncoding Encoding.NewEncoding(encoder string) *Encoding\n
NewEncoding Encoding.NewEncoding(encoder string) *Encoding\n
NewEncoding base32.NewEncoding(encoder string) *Encoding\nNewEncoding returns a new Encoding defined by the given alphabet, which must\nbe a 32-byte string.
NewEncoding base64.NewEncoding(encoder string) *Encoding\nNewEncoding returns a new padded Encoding defined by the given alphabet,\nwhich must be a 64-byte string that does not contain the padding character\nor CR / LF ('\r', '\n'). The resulting Encoding uses the default padding\ncharacter ('='), which may be changed or disabled via WithPadding.
NewFile File.NewFile(fd uintptr, name string) *File\n
NewFile os.NewFile(fd uintptr, name string) *File\nNewFile returns a new File with the given file descriptor and name. The\nreturned value will be nil if fd is not a valid file descriptor. On Unix\nsystems, if the file descriptor is in non-blocking mode, NewFile will\nattempt to return a pollable File (one for which the SetDeadline methods\nwork).\nAfter passing it to NewFile, fd may become invalid under the same conditions\ndescribed in the comments of the Fd method, and the same constraints apply.
NewFileTransport RoundTripper.NewFileTransport(fs FileSystem) RoundTripper\n
NewFileTransport http.NewFileTransport(fs FileSystem) RoundTripper\nNewFileTransport returns a new RoundTripper, serving the provided\nFileSystem. The returned RoundTripper ignores the URL host in its incoming\nrequests, as well as most other properties of the request.\nThe typical use case for NewFileTransport is to register the "file" protocol\nwith a Transport, as in:\nt := &http.Transport{}\nt.RegisterProtocol("file", http.NewFileTransport(http.Dir("/")))\nc := &http.Client{Transport: t}\nres, err := c.Get("file:///etc/passwd")\n...
NewFlagSet FlagSet.NewFlagSet(name string, errorHandling ErrorHandling) *FlagSet\n
NewFlagSet flag.NewFlagSet(name string, errorHandling ErrorHandling) *FlagSet\nNewFlagSet returns a new, empty flag set with the specified name and error\nhandling property. If the name is not empty, it will be printed in the\ndefault usage message and in error messages.
NewIdentifier IdentifierNode.NewIdentifier(ident string) *IdentifierNode\n
NewIdentifier parse.NewIdentifier(ident string) *IdentifierNode\nNewIdentifier returns a new IdentifierNode with the given identifier name.
NewReadLogger iotest.NewReadLogger(prefix string, r io.Reader) io.Reader\nNewReadLogger returns a reader that behaves like r except that it logs\n(using log.Printf) each read to standard error, printing the prefix and the\nhexadecimal data read.
NewReadWriter ReadWriter.NewReadWriter(r *Reader, w *Writer) *ReadWriter\n
NewReadWriter bufio.NewReadWriter(r *Reader, w *Writer) *ReadWriter\nNewReadWriter allocates a new ReadWriter that dispatches to r and w.
NewReader Reader.NewReader(b []byte) *Reader\n
NewReader Reader.NewReader(r io.Reader) *Reader\n
NewReader Reader.NewReader(rd io.Reader) *Reader\n
NewReader Reader.NewReader(s string) *Reader\n
NewReader bufio.NewReader(rd io.Reader) *Reader\nNewReader returns a new Reader whose buffer has the default size.
NewReader bytes.NewReader(b []byte) *Reader\nNewReader returns a new Reader reading from b.
NewReader csv.NewReader(r io.Reader) *Reader\nNewReader returns a new Reader that reads from r.
NewReader strings.NewReader(s string) *Reader\nNewReader returns a new Reader reading from s. It is similar to\nbytes.NewBufferString but more efficient and read-only.
NewReaderSize Reader.NewReaderSize(rd io.Reader, size int) *Reader\n
NewReaderSize bufio.NewReaderSize(rd io.Reader, size int) *Reader\nNewReaderSize returns a new Reader whose buffer has at least the specified\nsize. If the argument io.Reader is already a Reader with large enough size,\nit returns the underlying Reader.
NewReplacer Replacer.NewReplacer(oldnew ...string) *Replacer\n
NewReplacer strings.NewReplacer(oldnew ...string) *Replacer\nNewReplacer returns a new Replacer from a list of old, new string pairs.\nReplacements are performed in the order they appear in the target string,\nwithout overlapping matches. The old string comparisons are done in argument\norder.\nNewReplacer panics if given an odd number of arguments.
NewRequest http.NewRequest(method, url string, body io.Reader) (*Request, error)\nNewRequest wraps NewRequestWithContext using context.Background.
NewRequestWithContext http.NewRequestWithContext(ctx context.Context, method, url string, body io.Reader) (*Request, error)\nNewRequestWithContext returns a new Request given a method, URL, and\noptional body.\nIf the provided body is also an io.Closer, the returned Request.Body is set\nto body and will be closed by the Client methods Do, Post, and PostForm, and\nTransport.RoundTrip.\nNewRequestWithContext returns a Request suitable for use with Client.Do or\nTransport.RoundTrip. To create a request for use with testing a Server\nHandler, either use the NewRequest function in the net/http/httptest\npackage, use ReadRequest, or manually update the Request fields. For an\noutgoing client request, the context controls the entire lifetime of a\nrequest and its response: obtaining a connection, sending the request, and\nreading the response headers and body. See the Request type's documentation\nfor the difference between inbound and outbound request fields.\nIf body is of type *bytes.Buffer, *bytes.Reader, or *strings.Reader, the\nreturned request's ContentLength is set to its exact value (instead of -1),\nGetBody is populated (so 307 and 308 redirects can replay the body), and\nBody is set to NoBody if the ContentLength is 0.
NewScanner Scanner.NewScanner(r io.Reader) *Scanner\n
NewScanner bufio.NewScanner(r io.Reader) *Scanner\nNewScanner returns a new Scanner to read from r. The split function defaults\nto ScanLines.
NewSectionReader SectionReader.NewSectionReader(r ReaderAt, off int64, n int64) *SectionReader\n
NewSectionReader io.NewSectionReader(r ReaderAt, off int64, n int64) *SectionReader\nNewSectionReader returns a SectionReader that reads from r starting at\noffset off and stops with EOF after n bytes.
NewServeMux ServeMux.NewServeMux() *ServeMux\n
NewServeMux http.NewServeMux() *ServeMux\nNewServeMux allocates and returns a new ServeMux.
NewSource Source.NewSource(seed int64) Source\n
NewSource rand.NewSource(seed int64) Source\nNewSource returns a new pseudo-random Source seeded with the given value.\nUnlike the default Source used by top-level functions, this source is not\nsafe for concurrent use by multiple goroutines.
NewSyscallError os.NewSyscallError(syscall string, err error) error\nNewSyscallError returns, as an error, a new SyscallError with the given\nsystem call name and error details. As a convenience, if err is nil,\nNewSyscallError returns nil.
NewTicker Ticker.NewTicker(d Duration) *Ticker\n
NewTicker time.NewTicker(d Duration) *Ticker\nNewTicker returns a new Ticker containing a channel that will send the time\non the channel after each tick. The period of the ticks is specified by the\nduration argument. The ticker will adjust the time interval or drop ticks to\nmake up for slow receivers. The duration d must be greater than zero; if\nnot, NewTicker will panic. Stop the ticker to release associated resources.
NewTimer Timer.NewTimer(d Duration) *Timer\n
NewTimer time.NewTimer(d Duration) *Timer\nNewTimer creates a new Timer that will send the current time on its channel\nafter at least duration d.
NewTokenDecoder Decoder.NewTokenDecoder(t TokenReader) *Decoder\n
NewTokenDecoder xml.NewTokenDecoder(t TokenReader) *Decoder\nNewTokenDecoder creates a new XML parser using an underlying token stream.
NewWriteLogger iotest.NewWriteLogger(prefix string, w io.Writer) io.Writer\nNewWriteLogger returns a writer that behaves like w except that it logs\n(using log.Printf) each write to standard error, printing the prefix and the\nhexadecimal data written.
NewWriter Writer.NewWriter(w io.Writer) *Writer\n
NewWriter Writer.NewWriter(w io.Writer) *Writer\n
NewWriter bufio.NewWriter(w io.Writer) *Writer\nNewWriter returns a new Writer whose buffer has the default size.
NewWriter csv.NewWriter(w io.Writer) *Writer\nNewWriter returns a new Writer that writes to w.
NewWriterSize Writer.NewWriterSize(w io.Writer, size int) *Writer\n
NewWriterSize bufio.NewWriterSize(w io.Writer, size int) *Writer\nNewWriterSize returns a new Writer whose buffer has at least the specified\nsize. If the argument io.Writer is already a Writer with large enough size,\nit returns the underlying Writer.
NewZipf Zipf.NewZipf(r *Rand, s float64, v float64, imax uint64) *Zipf\n
NewZipf rand.NewZipf(r *Rand, s float64, v float64, imax uint64) *Zipf\nNewZipf returns a Zipf variate generator. The generator generates values k ∈\n[0, imax] such that P(k) is proportional to (v + k) ** (-s). Requirements: s\n> 1 and v >= 1.
Next Buffer.Next(n int) []byte\n
Next Frames.Next() (frame Frame, more bool)\n
Next PB.Next() bool\n
Next Scanner.Next() rune\n
Nextafter math.Nextafter(x, y float64) (r float64)\nNextafter returns the next representable float64 value after x towards y.\nSpecial cases are:\nNextafter(x, x)   = x\nNextafter(NaN, y) = NaN\nNextafter(x, NaN) = NaN
Nextafter32 math.Nextafter32(x, y float32) (r float32)\nNextafter32 returns the next representable float32 value after x towards y.\nSpecial cases are:\nNextafter32(x, x)   = x\nNextafter32(NaN, y) = NaN\nNextafter32(x, NaN) = NaN
NilNode parse.NilNode\nNilNode holds the special identifier 'nil' representing an untyped nil\nconstant.\n
Node parse.Node\nA Node is an element in the parse tree. The interface is trivial. The\ninterface contains an unexported method so that only types local to this\npackage can satisfy it.\n
NopCloser ReadCloser.NopCloser(r Reader) ReadCloser\n
NopCloser io.NopCloser(r Reader) ReadCloser\nNopCloser returns a ReadCloser with a no-op Close method wrapping the\nprovided Reader r.
NopCloser ioutil.NopCloser(r io.Reader) io.ReadCloser\nNopCloser returns a ReadCloser with a no-op Close method wrapping the\nprovided Reader r.\nAs of Go 1.16, this function simply calls io.NopCloser.
NormFloat64 Rand.NormFloat64() float64\n
NormFloat64 rand.NormFloat64() float64\nNormFloat64 returns a normally distributed float64 in the range\n[-math.MaxFloat64, +math.MaxFloat64] with standard normal distribution (mean\n= 0, stddev = 1) from the default Source. To produce a different normal\ndistribution, callers can adjust the output using:\nsample = NormFloat64() * desiredStdDev + desiredMean
NotFound http.NotFound(w ResponseWriter, r *Request)\nNotFound replies to the request with an HTTP 404 not found error.
NotFoundHandler Handler.NotFoundHandler() Handler\n
NotFoundHandler http.NotFoundHandler() Handler\nNotFoundHandler returns a simple request handler that replies to each\nrequest with a “404 page not found” reply.
Notify signal.Notify(c chan<- os.Signal, sig ...os.Signal)\nNotify causes package signal to relay incoming signals to c. If no signals\nare provided, all incoming signals will be relayed to c. Otherwise, just the\nprovided signals will.\nPackage signal will not block sending to c: the caller must ensure that c\nhas sufficient buffer space to keep up with the expected signal rate. For a\nchannel used for notification of just one signal value, a buffer of size 1\nis sufficient.\nIt is allowed to call Notify multiple times with the same channel: each call\nexpands the set of signals sent to that channel. The only way to remove\nsignals from the set is to call Stop.\nIt is allowed to call Notify multiple times with different channels and the\nsame signals: each channel receives copies of incoming signals\nindependently.
NotifyContext signal.NotifyContext(parent context.Context, signals ...os.Signal) (ctx context.Context, stop context.CancelFunc)\nNotifyContext returns a copy of the parent context that is marked done (its\nDone channel is closed) when one of the listed signals arrives, when the\nreturned stop function is called, or when the parent context's Done channel\nis closed, whichever happens first.\nThe stop function unregisters the signal behavior, which, like signal.Reset,\nmay restore the default behavior for a given signal. For example, the\ndefault behavior of a Go program receiving os.Interrupt is to exit. Calling\nNotifyContext(parent, os.Interrupt) will change the behavior to cancel the\nreturned context. Future interrupts received will not trigger the default\n(exit) behavior until the returned stop function is called.\nThe stop function releases resources associated with it, so code should call\nstop as soon as the operations running in this Context complete and signals\nno longer need to be diverted to the context.
Now Time.Now() Time\n
Now time.Now() Time\nNow returns the current local time.
NsPerOp BenchmarkResult.NsPerOp() int64\n
NumCPU runtime.NumCPU() int\nNumCPU returns the number of logical CPUs usable by the current process.\nThe set of available CPUs is checked by querying the operating system at\nprocess startup. Changes to operating system CPU allocation after process\nstartup are not reflected.
NumCgoCall runtime.NumCgoCall() int64\nNumCgoCall returns the number of cgo calls made by the current process.
NumError strconv.NumError\nA NumError records a failed conversion.\n
NumGoroutine runtime.NumGoroutine() int\nNumGoroutine returns the number of goroutines that currently exist.
NumSubexp Regexp.NumSubexp() int\n
NumberNode parse.NumberNode\nNumberNode holds a number: signed or unsigned integer, float, or complex.\nThe value is parsed and stored under all the types that can represent the\nvalue. This simulates in a small amount of code the behavior of Go's ideal\nconstants.\n
Once sync.Once\nOnce is an object that will perform exactly one action.\n\nA Once must not be copied after first use.\n
OneByteReader iotest.OneByteReader(r io.Reader) io.Reader\nOneByteReader returns a Reader that implements each non-empty Read by\nreading one byte from r.
OpError net.OpError\nOpError is the error type usually returned by functions in the net package.\nIt describes the operation, network type, and address of an error.\n
Open FS.Open(name string) (fs.File, error)\n
Open File.Open(name string) (*File, error)\n
Open os.Open(name string) (*File, error)\nOpen opens the named file for reading. If successful, methods on the\nreturned file can be used for reading; the associated file descriptor has\nmode O_RDONLY. If there is an error, it will be of type *PathError.
OpenFile File.OpenFile(name string, flag int, perm FileMode) (*File, error)\n
OpenFile os.OpenFile(name string, flag int, perm FileMode) (*File, error)\nOpenFile is the generalized open call; most users will use Open or Create\ninstead. It opens the named file with specified flag (O_RDONLY etc.). If the\nfile does not exist, and the O_CREATE flag is passed, it is created with\nmode perm (before umask). If successful, methods on the returned File can be\nused for I/O. If there is an error, it will be of type *PathError.
Option Template.Option(opt ...string) *Template\n
Option Template.Option(opt ...string) *Template\n
Output Cmd.Output() ([]byte, error)\n
Output FlagSet.Output() io.Writer\n
Output Logger.Output(calldepth int, s string) error\n
Output log.Output(calldepth int, s string) error\nOutput writes the output for a logging event. The string s contains the text\nto print after the prefix specified by the flags of the Logger. A newline is\nappended if the last character of s is not already a newline. Calldepth is\nthe count of the number of frames to skip when computing the file name and\nline number if Llongfile or Lshortfile is set; a value of 1 will print the\ndetails for the caller of Output.
PB testing.PB\nA PB is used by RunParallel for running parallel benchmarks.\n
PacketConn net.PacketConn\nPacketConn is a generic packet-oriented network connection.\n\nMultiple goroutines may invoke methods on a PacketConn simultaneously.\n
Panic Logger.Panic(v ...interface{})\n
Panic log.Panic(v ...interface{})\nPanic is equivalent to Print() followed by a call to panic().
Panicf Logger.Panicf(format string, v ...interface{})\n
Panicf log.Panicf(format string, v ...interface{})\nPanicf is equivalent to Printf() followed by a call to panic().
Panicln Logger.Panicln(v ...interface{})\n
Panicln log.Panicln(v ...interface{})\nPanicln is equivalent to Println() followed by a call to panic().
Parallel T.Parallel()\n
Parse FlagSet.Parse(arguments []string) error\n
Parse Regexp.Parse(s string, flags Flags) (*Regexp, error)\n
Parse Template.Parse(text string) (*Template, error)\n
Parse Template.Parse(text string) (*Template, error)\n
Parse Time.Parse(layout, value string) (Time, error)\n
Parse Tree.Parse(text, leftDelim, rightDelim string, treeSet map[string]*Tree) (tree *Tree, err error)\n
Parse URL.Parse(rawURL string) (*URL, error)\n
Parse URL.Parse(ref string) (*URL, error)\n
Parse flag.Parse()\nParse parses the command-line flags from os.Args[1:]. Must be called after\nall flags are defined and before flags are accessed by the program.
Parse parse.Parse(name, text, leftDelim, rightDelim string, funcs ...map[string]interface{}) (map[string]*Tree, error)\nParse returns a map from template name to parse.Tree, created by parsing the\ntemplates described in the argument string. The top-level template will be\ngiven the specified name. If an error is encountered, parsing stops and an\nempty map is returned with the error.
Parse syntax.Parse(s string, flags Flags) (*Regexp, error)\nParse parses a regular expression string s, controlled by the specified\nFlags, and returns a regular expression parse tree. The syntax is described\nin the top-level comment.
Parse time.Parse(layout, value string) (Time, error)\nParse parses a formatted string and returns the time value it represents.\nSee the documentation for the constant called Layout to see how to represent\nthe format. The second argument must be parseable using the format string\n(layout) provided as the first argument.\nThe example for Time.Format demonstrates the working of the layout string in\ndetail and is a good reference.\nWhen parsing (only), the input may contain a fractional second field\nimmediately after the seconds field, even if the layout does not signify its\npresence. In that case either a comma or a decimal point followed by a\nmaximal series of digits is parsed as a fractional second.\nElements omitted from the layout are assumed to be zero or, when zero is\nimpossible, one, so parsing "3:04pm" returns the time corresponding to Jan\n1, year 0, 15:04:00 UTC (note that because the year is 0, this time is\nbefore the zero Time). Years must be in the range 0000..9999. The day of the\nweek is checked for syntax but it is otherwise ignored.\nFor layouts specifying the two-digit year 06, a value NN >= 69 will be\ntreated as 19NN and a value NN < 69 will be treated as 20NN.\nThe remainder of this comment describes the handling of time zones.\nIn the absence of a time zone indicator, Parse returns a time in UTC.\nWhen parsing a time with a zone offset like -0700, if the offset corresponds\nto a time zone used by the current location (Local), then Parse uses that\nlocation and zone in the returned time. Otherwise it records the time as\nbeing in a fabricated location with time fixed at the given zone offset.\nWhen parsing a time with a zone abbreviation like MST, if the zone\nabbreviation has a defined offset in the current location, then that offset\nis used. The zone abbreviation "UTC" is recognized as UTC regardless of\nlocation. If the zone abbreviation is unknown, Parse records the time as\nbeing in a fabricated location with the given zone abbreviation and a zero\noffset. This choice means that such a time can be parsed and reformatted\nwith the same layout losslessly, but the exact instant used in the\nrepresentation will differ by the actual zone offset. To avoid such\nproblems, prefer time layouts that use a numeric zone offset, or use\nParseInLocation.
Parse url.Parse(rawURL string) (*URL, error)\nParse parses a raw url into a URL structure.\nThe url may be relative (a path, without a host) or absolute (starting with\na scheme). Trying to parse a hostname and path without a scheme is invalid\nbut may not necessarily return an error, due to parsing ambiguities.
ParseBool strconv.ParseBool(str string) (bool, error)\nParseBool returns the boolean value represented by the string. It accepts 1,\nt, T, TRUE, true, True, 0, f, F, FALSE, false, False. Any other value\nreturns an error.
ParseCIDR net.ParseCIDR(s string) (IP, *IPNet, error)\nParseCIDR parses s as a CIDR notation IP address and prefix length, like\n"192.0.2.0/24" or "2001:db8::/32", as defined in RFC 4632 and RFC 4291.\nIt returns the IP address and the network implied by the IP and prefix\nlength. For example, ParseCIDR("192.0.2.1/24") returns the IP address\n192.0.2.1 and the network 192.0.2.0/24.
ParseComplex strconv.ParseComplex(s string, bitSize int) (complex128, error)\nParseComplex converts the string s to a complex number with the precision\nspecified by bitSize: 64 for complex64, or 128 for complex128. When\nbitSize=64, the result still has type complex128, but it will be convertible\nto complex64 without changing its value.\nThe number represented by s must be of the form N, Ni, or N±Ni, where N\nstands for a floating-point number as recognized by ParseFloat, and i is the\nimaginary component. If the second N is unsigned, a + sign is required\nbetween the two components as indicated by the ±. If the second N is NaN,\nonly a + sign is accepted. The form may be parenthesized and cannot contain\nany spaces. The resulting complex number consists of the two components\nconverted by ParseFloat.\nThe errors that ParseComplex returns have concrete type *NumError and\ninclude err.Num = s.\nIf s is not syntactically well-formed, ParseComplex returns err.Err =\nErrSyntax.\nIf s is syntactically well-formed but either component is more than 1/2 ULP\naway from the largest floating point number of the given component's size,\nParseComplex returns err.Err = ErrRange and c = ±Inf for the respective\ncomponent.
ParseDuration time.ParseDuration(s string) (Duration, error)\nParseDuration parses a duration string. A duration string is a possibly\nsigned sequence of decimal numbers, each with optional fraction and a unit\nsuffix, such as "300ms", "-1.5h" or "2h45m". Valid time units are "ns", "us"\n(or "µs"), "ms", "s", "m", "h".
ParseError csv.ParseError\nA ParseError is returned for parsing errors. Line numbers are 1-indexed and\ncolumns are 0-indexed.\n
ParseError net.ParseError\nA ParseError is the error type of literal network address parsers.\n
ParseError time.ParseError\nParseError describes a problem parsing a time string.\n
ParseFS Template.ParseFS(fs fs.FS, patterns ...string) (*Template, error)\n
ParseFS Template.ParseFS(fs fs.FS, patterns ...string) (*Template, error)\n
ParseFS Template.ParseFS(fsys fs.FS, patterns ...string) (*Template, error)\n
ParseFS Template.ParseFS(fsys fs.FS, patterns ...string) (*Template, error)\n
ParseFS template.ParseFS(fs fs.FS, patterns ...string) (*Template, error)\nParseFS is like ParseFiles or ParseGlob but reads from the file system fs\ninstead of the host operating system's file system. It accepts a list of\nglob patterns. (Note that most file names serve as glob patterns matching\nonly themselves.)
ParseFS template.ParseFS(fsys fs.FS, patterns ...string) (*Template, error)\nParseFS is like ParseFiles or ParseGlob but reads from the file system fsys\ninstead of the host operating system's file system. It accepts a list of\nglob patterns. (Note that most file names serve as glob patterns matching\nonly themselves.)
ParseFiles Template.ParseFiles(filenames ...string) (*Template, error)\n
ParseFiles Template.ParseFiles(filenames ...string) (*Template, error)\n
ParseFiles Template.ParseFiles(filenames ...string) (*Template, error)\n
ParseFiles Template.ParseFiles(filenames ...string) (*Template, error)\n
ParseFiles template.ParseFiles(filenames ...string) (*Template, error)\nParseFiles creates a new Template and parses the template definitions from\nthe named files. The returned template's name will have the (base) name and\n(parsed) contents of the first file. There must be at least one file. If an\nerror occurs, parsing stops and the returned *Template is nil.\nWhen parsing multiple files with the same name in different directories, the\nlast one mentioned will be the one that results. For instance,\nParseFiles("a/foo", "b/foo") stores "b/foo" as the template named "foo",\nwhile "a/foo" is unavailable.
ParseFiles template.ParseFiles(filenames ...string) (*Template, error)\nParseFiles creates a new Template and parses the template definitions from\nthe named files. The returned template's name will have the base name and\nparsed contents of the first file. There must be at least one file. If an\nerror occurs, parsing stops and the returned *Template is nil.\nWhen parsing multiple files with the same name in different directories, the\nlast one mentioned will be the one that results. For instance,\nParseFiles("a/foo", "b/foo") stores "b/foo" as the template named "foo",\nwhile "a/foo" is unavailable.
ParseFloat strconv.ParseFloat(s string, bitSize int) (float64, error)\nParseFloat converts the string s to a floating-point number with the\nprecision specified by bitSize: 32 for float32, or 64 for float64. When\nbitSize=32, the result still has type float64, but it will be convertible to\nfloat32 without changing its value.\nParseFloat accepts decimal and hexadecimal floating-point number syntax. If\ns is well-formed and near a valid floating-point number, ParseFloat returns\nthe nearest floating-point number rounded using IEEE754 unbiased rounding.\n(Parsing a hexadecimal floating-point value only rounds when there are more\nbits in the hexadecimal representation than will fit in the mantissa.)\nThe errors that ParseFloat returns have concrete type *NumError and include\nerr.Num = s.\nIf s is not syntactically well-formed, ParseFloat returns err.Err =\nErrSyntax.\nIf s is syntactically well-formed but is more than 1/2 ULP away from the\nlargest floating point number of the given size, ParseFloat returns f =\n±Inf, err.Err = ErrRange.\nParseFloat recognizes the strings "NaN", and the (possibly signed) strings\n"Inf" and "Infinity" as their respective special floating point values. It\nignores case when matching.
ParseForm Request.ParseForm() error\n
ParseGlob Template.ParseGlob(pattern string) (*Template, error)\n
ParseGlob Template.ParseGlob(pattern string) (*Template, error)\n
ParseGlob Template.ParseGlob(pattern string) (*Template, error)\n
ParseGlob Template.ParseGlob(pattern string) (*Template, error)\n
ParseGlob template.ParseGlob(pattern string) (*Template, error)\nParseGlob creates a new Template and parses the template definitions from\nthe files identified by the pattern. The files are matched according to the\nsemantics of filepath.Match, and the pattern must match at least one file.\nThe returned template will have the (base) name and (parsed) contents of the\nfirst file matched by the pattern. ParseGlob is equivalent to calling\nParseFiles with the list of files matched by the pattern.\nWhen parsing multiple files with the same name in different directories, the\nlast one mentioned will be the one that results.
ParseGlob template.ParseGlob(pattern string) (*Template, error)\nParseGlob creates a new Template and parses the template definitions from\nthe files identified by the pattern. The files are matched according to the\nsemantics of filepath.Match, and the pattern must match at least one file.\nThe returned template will have the (base) name and (parsed) contents of the\nfirst file matched by the pattern. ParseGlob is equivalent to calling\nParseFiles with the list of files matched by the pattern.\nWhen parsing multiple files with the same name in different directories, the\nlast one mentioned will be the one that results.
ParseHTTPVersion http.ParseHTTPVersion(vers string) (major, minor int, ok bool)\nParseHTTPVersion parses an HTTP version string. "HTTP/1.0" returns (1, 0,\ntrue). Note that strings without a minor version, such as "HTTP/2", are not\nvalid.
ParseIP net.ParseIP(s string) IP\nParseIP parses s as an IP address, returning the result. The string s can be\nin IPv4 dotted decimal ("192.0.2.1"), IPv6 ("2001:db8::68"), or IPv4-mapped\nIPv6 ("::ffff:192.0.2.1") form. If s is not a valid textual representation\nof an IP address, ParseIP returns nil.
ParseInLocation Time.ParseInLocation(layout, value string, loc *Location) (Time, error)\n
ParseInLocation time.ParseInLocation(layout, value string, loc *Location) (Time, error)\nParseInLocation is like Parse but differs in two important ways. First, in\nthe absence of time zone information, Parse interprets a time as UTC;\nParseInLocation interprets the time as in the given location. Second, when\ngiven a zone offset or abbreviation, Parse tries to match it against the\nLocal location; ParseInLocation uses the given location.
ParseInt strconv.ParseInt(s string, base int, bitSize int) (i int64, err error)\nParseInt interprets a string s in the given base (0, 2 to 36) and bit size\n(0 to 64) and returns the corresponding value i.\nThe string may begin with a leading sign: "+" or "-".\nIf the base argument is 0, the true base is implied by the string's prefix\nfollowing the sign (if present): 2 for "0b", 8 for "0" or "0o", 16 for "0x",\nand 10 otherwise. Also, for argument base 0 only, underscore characters are\npermitted as defined by the Go syntax for integer literals.\nThe bitSize argument specifies the integer type that the result must fit\ninto. Bit sizes 0, 8, 16, 32, and 64 correspond to int, int8, int16, int32,\nand int64. If bitSize is below 0 or above 64, an error is returned.\nThe errors that ParseInt returns have concrete type *NumError and include\nerr.Num = s. If s is empty or contains invalid digits, err.Err = ErrSyntax\nand the returned value is 0; if the value corresponding to s cannot be\nrepresented by a signed integer of the given size, err.Err = ErrRange and\nthe returned value is the maximum magnitude integer of the appropriate\nbitSize and sign.
ParseMAC net.ParseMAC(s string) (hw HardwareAddr, err error)\nParseMAC parses s as an IEEE 802 MAC-48, EUI-48, EUI-64, or a 20-octet IP\nover InfiniBand link-layer address using one of the following formats:\n00:00:5e:00:53:01\n02:00:5e:10:00:00:00:01\n00:00:00:00:fe:80:00:00:00:00:00:00:02:00:5e:10:00:00:00:01\n00-00-5e-00-53-01\n02-00-5e-10-00-00-00-01\n00-00-00-00-fe-80-00-00-00-00-00-00-02-00-5e-10-00-00-00-01\n0000.5e00.5301\n0200.5e10.0000.0001\n0000.0000.fe80.0000.0000.0000.0200.5e10.0000.0001
ParseMultipartForm Request.ParseMultipartForm(maxMemory int64) error\n
ParseQuery url.ParseQuery(query string) (Values, error)\nParseQuery parses the URL-encoded query string and returns a map listing the\nvalues specified for each key. ParseQuery always returns a non-nil map\ncontaining all the valid query parameters found; err describes the first\ndecoding error encountered, if any.\nQuery is expected to be a list of key=value settings separated by\nampersands. A setting without an equals sign is interpreted as a key set to\nan empty value. Settings containing a non-URL-encoded semicolon are\nconsidered invalid.
ParseRequestURI URL.ParseRequestURI(rawURL string) (*URL, error)\n
ParseRequestURI url.ParseRequestURI(rawURL string) (*URL, error)\nParseRequestURI parses a raw url into a URL structure. It assumes that url\nwas received in an HTTP request, so the url is interpreted only as an\nabsolute URI or an absolute path. The string url is assumed not to have a\n#fragment suffix. (Web browsers strip #fragment before sending the URL to a\nweb server.)
ParseTime http.ParseTime(text string) (t time.Time, err error)\nParseTime parses a time header (such as the Date: header), trying each of\nthe three formats allowed by HTTP/1.1: TimeFormat, time.RFC850, and\ntime.ANSIC.
ParseUint strconv.ParseUint(s string, base int, bitSize int) (uint64, error)\nParseUint is like ParseInt but for unsigned numbers.\nA sign prefix is not permitted.
Parsed FlagSet.Parsed() bool\n
Parsed flag.Parsed() bool\nParsed reports whether the command-line flags have been parsed.
Password Userinfo.Password() (string, bool)\n
PathError fs.PathError\nPathError records an error and the operation and file path that caused it.\n
PathEscape url.PathEscape(s string) string\nPathEscape escapes the string so it can be safely placed inside a URL path\nsegment, replacing special characters (including /) with %XX sequences as\nneeded.
PathUnescape url.PathUnescape(s string) (string, error)\nPathUnescape does the inverse transformation of PathEscape, converting each\n3-byte encoded substring of the form "%AB" into the hex-decoded byte 0xAB.\nIt returns an error if any % is not followed by two hexadecimal digits.\nPathUnescape is identical to QueryUnescape except that it does not unescape\n'+' to ' ' (space).
Peek Reader.Peek(n int) ([]byte, error)\n
Peek Scanner.Peek() rune\n
Perm Rand.Perm(n int) []int\n
Perm rand.Perm(n int) []int\nPerm returns, as a slice of n ints, a pseudo-random permutation of the\nintegers in the half-open interval [0,n) from the default Source.
Phase cmplx.Phase(x complex128) float64\nPhase returns the phase (also called the argument) of x. The returned value\nis in the range [-Pi, Pi].
Pid ProcessState.Pid() int\n
Pipe io.Pipe() (*PipeReader, *PipeWriter)\nPipe creates a synchronous in-memory pipe. It can be used to connect code\nexpecting an io.Reader with code expecting an io.Writer.\nReads and Writes on the pipe are matched one to one except when multiple\nReads are needed to consume a single Write. That is, each Write to the\nPipeWriter blocks until it has satisfied one or more Reads from the\nPipeReader that fully consume the written data. The data is copied directly\nfrom the Write to the corresponding Read (or Reads); there is no internal\nbuffering.\nIt is safe to call Read and Write in parallel with each other or with Close.\nParallel calls to Read and parallel calls to Write are also safe: the\nindividual calls will be gated sequentially.
Pipe net.Pipe() (Conn, Conn)\nPipe creates a synchronous, in-memory, full duplex network connection; both\nends implement the Conn interface. Reads on one end are matched with writes\non the other, copying data directly between the two; there is no internal\nbuffering.
Pipe os.Pipe() (r *File, w *File, err error)\nPipe returns a connected pair of Files; reads from r return bytes written to\nw. It returns the files and an error, if any.
PipeNode parse.PipeNode\nPipeNode holds a pipeline with optional declaration\n
PipeReader io.PipeReader\nA PipeReader is the read half of a pipe.\n
PipeWriter io.PipeWriter\nA PipeWriter is the write half of a pipe.\n
Polar cmplx.Polar(x complex128) (r, θ float64)\nPolar returns the absolute value r and phase θ of x, such that x = r *\ne**θi. The phase is in the range [-Pi, Pi].
Pool sync.Pool\nA Pool is a set of temporary objects that may be individually saved and\nretrieved.\n\nAny item stored in the Pool may be removed automatically at any time without\nnotification. If the Pool holds the only reference when this happens, the\nitem might be deallocated.\n\nA Pool is safe for use by multiple goroutines simultaneously.\n\nPool's purpose is to cache allocated but unused items for later reuse,\nrelieving pressure on the garbage collector. That is, it makes it easy to\nbuild efficient, thread-safe free lists. However, it is not suitable for all\nfree lists.\n\nAn appropriate use of a Pool is to manage a group of temporary items\nsilently shared among and potentially reused by concurrent independent\nclients of a package. Pool provides a way to amortize allocation overhead\nacross many clients.\n\nAn example of good use of a Pool is in the fmt package, which maintains a\ndynamically-sized store of temporary output buffers. The store scales under\nload (when many goroutines are actively printing) and shrinks when\nquiescent.\n\nOn the other hand, a free list maintained as part of a short-lived object is\nnot a suitable use for a Pool, since the overhead does not amortize well in\nthat scenario. It is more efficient to have such objects implement their own\nfree list.\n\nA Pool must not be copied after first use.\n
Port URL.Port() string\n
Pos Scanner.Pos() (pos Position)\n
Position scanner.Position\nPosition is a value that represents a source position. A position is valid\nif Line > 0.\n
Post Client.Post(url, contentType string, body io.Reader) (resp *Response, err error)\n
Post http.Post(url, contentType string, body io.Reader) (resp *Response, err error)\nPost issues a POST to the specified URL.\nCaller should close resp.Body when done reading from it.\nIf the provided body is an io.Closer, it is closed after the request.\nPost is a wrapper around DefaultClient.Post.\nTo set custom headers, use NewRequest and DefaultClient.Do.\nSee the Client.Do method documentation for details on how redirects are\nhandled.\nTo make a request with a specified context.Context, use\nNewRequestWithContext and DefaultClient.Do.
PostForm Client.PostForm(url string, data url.Values) (resp *Response, err error)\n
PostForm http.PostForm(url string, data url.Values) (resp *Response, err error)\nPostForm issues a POST to the specified URL, with data's keys and values\nURL-encoded as the request body.\nThe Content-Type header is set to application/x-www-form-urlencoded. To set\nother headers, use NewRequest and DefaultClient.Do.\nWhen err is nil, resp always contains a non-nil resp.Body. Caller should\nclose resp.Body when done reading from it.\nPostForm is a wrapper around DefaultClient.PostForm.\nSee the Client.Do method documentation for details on how redirects are\nhandled.\nTo make a request with a specified context.Context, use\nNewRequestWithContext and DefaultClient.Do.
PostFormValue Request.PostFormValue(key string) string\n
Pow cmplx.Pow(x, y complex128) complex128\nPow returns x**y, the base-x exponential of y. For generalized compatibility\nwith math.Pow:\nPow(0, ±0) returns 1+0i\nPow(0, c) for real(c)<0 returns Inf+0i if imag(c) is zero, otherwise Inf+Inf i.
Pow math.Pow(x, y float64) float64\nPow returns x**y, the base-x exponential of y.\nSpecial cases are (in order):\nPow(x, ±0) = 1 for any x\nPow(1, y) = 1 for any y\nPow(x, 1) = x for any x\nPow(NaN, y) = NaN\nPow(x, NaN) = NaN\nPow(±0, y) = ±Inf for y an odd integer < 0\nPow(±0, -Inf) = +Inf\nPow(±0, +Inf) = +0\nPow(±0, y) = +Inf for finite y < 0 and not an odd integer\nPow(±0, y) = ±0 for y an odd integer > 0\nPow(±0, y) = +0 for finite y > 0 and not an odd integer\nPow(-1, ±Inf) = 1\nPow(x, +Inf) = +Inf for |x| > 1\nPow(x, -Inf) = +0 for |x| > 1\nPow(x, +Inf) = +0 for |x| < 1\nPow(x, -Inf) = +Inf for |x| < 1\nPow(+Inf, y) = +Inf for y > 0\nPow(+Inf, y) = +0 for y < 0\nPow(-Inf, y) = Pow(-0, -y)\nPow(x, y) = NaN for finite x < 0 and finite non-integer y
Pow10 math.Pow10(n int) float64\nPow10 returns 10**n, the base-10 exponential of n.\nSpecial cases are:\nPow10(n) =    0 for n < -323\nPow10(n) = +Inf for n > 308
Prefix Logger.Prefix() string\n
Prefix Prog.Prefix() (prefix string, complete bool)\n
Prefix log.Prefix() string\nPrefix returns the output prefix for the standard logger.
Print Logger.Print(v ...interface{})\n
Print fmt.Print(a ...interface{}) (n int, err error)\nPrint formats using the default formats for its operands and writes to\nstandard output. Spaces are added between operands when neither is a string.\nIt returns the number of bytes written and any write error encountered.
Print log.Print(v ...interface{})\nPrint calls Output to print to the standard logger. Arguments are handled in\nthe manner of fmt.Print.
PrintDefaults FlagSet.PrintDefaults()\n
PrintDefaults flag.PrintDefaults()\nPrintDefaults prints, to standard error unless configured otherwise, a usage\nmessage showing the default settings of all defined command-line flags. For\nan integer valued flag x, the default output has the form\n-x int\nusage-message-for-x (default 7)\nThe usage message will appear on a separate line for anything but a bool\nflag with a one-byte name. For bool flags, the type is omitted and if the\nflag name is one byte the usage message appears on the same line. The\nparenthetical default is omitted if the default is the zero value for the\ntype. The listed type, here int, can be changed by placing a back-quoted\nname in the flag's usage string; the first such item in the message is taken\nto be a parameter name to show in the message and the back quotes are\nstripped from the message when displayed. For instance, given\nflag.String("I", "", "search `directory` for include files")\nthe output will be\n-I directory\nsearch directory for include files.\nTo change the destination for flag messages, call CommandLine.SetOutput.
Printf Logger.Printf(format string, v ...interface{})\n
Printf fmt.Printf(format string, a ...interface{}) (n int, err error)\nPrintf formats according to a format specifier and writes to standard\noutput. It returns the number of bytes written and any write error\nencountered.
Printf log.Printf(format string, v ...interface{})\nPrintf calls Output to print to the standard logger. Arguments are handled\nin the manner of fmt.Printf.
Println Logger.Println(v ...interface{})\n
Println fmt.Println(a ...interface{}) (n int, err error)\nPrintln formats using the default formats for its operands and writes to\nstandard output. Spaces are always added between operands and a newline is\nappended. It returns the number of bytes written and any write error\nencountered.
Println log.Println(v ...interface{})\nPrintln calls Output to print to the standard logger. Arguments are handled\nin the manner of fmt.Println.
ProcAttr os.ProcAttr\nProcAttr holds the attributes that will be applied to a new process started\nby StartProcess.\n
ProcInst xml.ProcInst\nA ProcInst represents an XML processing instruction of the form <?target\ninst?>\n
Process os.Process\nProcess stores the information about a process created by StartProcess.\n
ProcessState os.ProcessState\nProcessState stores information about a process, as reported by Wait.\n
Prog syntax.Prog\nA Prog is a compiled regular expression program.\n
ProtoAtLeast Request.ProtoAtLeast(major, minor int) bool\n
ProtoAtLeast Response.ProtoAtLeast(major, minor int) bool\n
ProtocolError http.ProtocolError\nProtocolError represents an HTTP protocol error.\n\nDeprecated: Not all errors in the http package related to protocol errors\nare of type ProtocolError.\n
ProxyFromEnvironment http.ProxyFromEnvironment(req *Request) (*url.URL, error)\nProxyFromEnvironment returns the URL of the proxy to use for a given\nrequest, as indicated by the environment variables HTTP_PROXY, HTTPS_PROXY\nand NO_PROXY (or the lowercase versions thereof). HTTPS_PROXY takes\nprecedence over HTTP_PROXY for https requests.\nThe environment values may be either a complete URL or a "host[:port]", in\nwhich case the "http" scheme is assumed. The schemes "http", "https", and\n"socks5" are supported. An error is returned if the value is a different\nform.\nA nil URL and nil error are returned if no proxy is defined in the\nenvironment, or a proxy should not be used for the given request, as defined\nby NO_PROXY.\nAs a special case, if req.URL.Host is "localhost" (with or without a port\nnumber), then a nil URL and nil error will be returned.
ProxyURL http.ProxyURL(fixedURL *url.URL) func(*Request) (*url.URL, error)\nProxyURL returns a proxy function (for use in a Transport) that always\nreturns the same URL.
PushOptions http.PushOptions\nPushOptions describes options for Pusher.Push.\n
Pusher http.Pusher\nPusher is the interface implemented by ResponseWriters that support HTTP/2\nserver push. For more background, see\nhttps://tools.ietf.org/html/rfc7540#section-8.2.\n
Put Pool.Put(x interface{})\n
PutUvarint binary.PutUvarint(buf []byte, x uint64) int\nPutUvarint encodes a uint64 into buf and returns the number of bytes\nwritten. If the buffer is too small, PutUvarint will panic.
PutVarint binary.PutVarint(buf []byte, x int64) int\nPutVarint encodes an int64 into buf and returns the number of bytes written.\nIf the buffer is too small, PutVarint will panic.
Query URL.Query() Values\n
QueryEscape url.QueryEscape(s string) string\nQueryEscape escapes the string so it can be safely placed inside a URL\nquery.
QueryUnescape url.QueryUnescape(s string) (string, error)\nQueryUnescape does the inverse transformation of QueryEscape, converting\neach 3-byte encoded substring of the form "%AB" into the hex-decoded byte\n0xAB. It returns an error if any % is not followed by two hexadecimal\ndigits.
Quote strconv.Quote(s string) string\nQuote returns a double-quoted Go string literal representing s. The returned\nstring uses Go escape sequences (\t, \n, \xFF, \u0100) for control\ncharacters and non-printable characters as defined by IsPrint.
QuoteMeta regexp.QuoteMeta(s string) string\nQuoteMeta returns a string that escapes all regular expression\nmetacharacters inside the argument text; the returned string is a regular\nexpression matching the literal text.
QuoteRune strconv.QuoteRune(r rune) string\nQuoteRune returns a single-quoted Go character literal representing the\nrune. The returned string uses Go escape sequences (\t, \n, \xFF, \u0100)\nfor control characters and non-printable characters as defined by IsPrint.
QuoteRuneToASCII strconv.QuoteRuneToASCII(r rune) string\nQuoteRuneToASCII returns a single-quoted Go character literal representing\nthe rune. The returned string uses Go escape sequences (\t, \n, \xFF,\n\u0100) for non-ASCII characters and non-printable characters as defined by\nIsPrint.
QuoteRuneToGraphic strconv.QuoteRuneToGraphic(r rune) string\nQuoteRuneToGraphic returns a single-quoted Go character literal representing\nthe rune. If the rune is not a Unicode graphic character, as defined by\nIsGraphic, the returned string will use a Go escape sequence (\t, \n, \xFF,\n\u0100).
QuoteToASCII strconv.QuoteToASCII(s string) string\nQuoteToASCII returns a double-quoted Go string literal representing s. The\nreturned string uses Go escape sequences (\t, \n, \xFF, \u0100) for\nnon-ASCII characters and non-printable characters as defined by IsPrint.
QuoteToGraphic strconv.QuoteToGraphic(s string) string\nQuoteToGraphic returns a double-quoted Go string literal representing s. The\nreturned string leaves Unicode graphic characters, as defined by IsGraphic,\nunchanged and uses Go escape sequences (\t, \n, \xFF, \u0100) for\nnon-graphic characters.
QuotedPrefix strconv.QuotedPrefix(s string) (string, error)\nQuotedPrefix returns the quoted string (as understood by Unquote) at the\nprefix of s. If s does not start with a valid quoted string, QuotedPrefix\nreturns an error.
RLock RWMutex.RLock()\n
RLocker RWMutex.RLocker() Locker\n
RUnlock RWMutex.RUnlock()\n
RWMutex sync.RWMutex\nA RWMutex is a reader/writer mutual exclusion lock. The lock can be held by\nan arbitrary number of readers or a single writer. The zero value for a\nRWMutex is an unlocked mutex.\n\nA RWMutex must not be copied after first use.\n\nIf a goroutine holds a RWMutex for reading and another goroutine might call\nLock, no goroutine should expect to be able to acquire a read lock until the\ninitial read lock is released. In particular, this prohibits recursive read\nlocking. This is to ensure that the lock eventually becomes available; a\nblocked Lock call excludes new readers from acquiring the lock.\n
Rand rand.Rand\nA Rand is a source of random numbers.\n
Range Map.Range(f func(key, value interface{}) bool)\n
Range16 unicode.Range16\nRange16 represents of a range of 16-bit Unicode code points. The range runs\nfrom Lo to Hi inclusive and has the specified stride.\n
Range32 unicode.Range32\nRange32 represents of a range of Unicode code points and is used when one or\nmore of the values will not fit in 16 bits. The range runs from Lo to Hi\ninclusive and has the specified stride. Lo and Hi must always be >= 1<<16.\n
RangeNode parse.RangeNode\nRangeNode represents a {{range}} action and its commands.\n
RangeTable unicode.RangeTable\nRangeTable defines a set of Unicode code points by listing the ranges of\ncode points within the set. The ranges are listed in two slices to save\nspace: a slice of 16-bit ranges and a slice of 32-bit ranges. The two slices\nmust be in sorted order and non-overlapping. Also, R32 should contain only\nvalues >= 0x10000 (1<<16).\n
RawToken Decoder.RawToken() (Token, error)\n
Read Buffer.Read(p []byte) (n int, err error)\n
Read File.Read(b []byte) (n int, err error)\n
Read IPConn.Read(b []byte) (int, error)\n
Read LimitedReader.Read(p []byte) (n int, err error)\n
Read PipeReader.Read(data []byte) (n int, err error)\n
Read Rand.Read(p []byte) (n int, err error)\n
Read Reader.Read() (record []string, err error)\n
Read Reader.Read(b []byte) (n int, err error)\n
Read Reader.Read(b []byte) (n int, err error)\n
Read Reader.Read(p []byte) (n int, err error)\n
Read SectionReader.Read(p []byte) (n int, err error)\n
Read TCPConn.Read(b []byte) (int, error)\n
Read UDPConn.Read(b []byte) (int, error)\n
Read UnixConn.Read(b []byte) (int, error)\n
Read binary.Read(r io.Reader, order ByteOrder, data interface{}) error\nRead reads structured binary data from r into data. Data must be a pointer\nto a fixed-size value or a slice of fixed-size values. Bytes read from r are\ndecoded using the specified byte order and written to successive fields of\nthe data. When decoding boolean values, a zero byte is decoded as false, and\nany other non-zero byte is decoded as true. When reading into structs, the\nfield data for fields with blank (_) field names is skipped; i.e., blank\nfield names may be used for padding. When reading into a struct, all\nnon-blank fields must be exported or Read may panic.\nThe error is EOF only if no bytes were read. If an EOF happens after reading\nsome but not all the bytes, Read returns ErrUnexpectedEOF.
Read rand.Read(p []byte) (n int, err error)\nRead generates len(p) random bytes from the default Source and writes them\ninto p. It always returns len(p) and a nil error. Read, unlike the Rand.Read\nmethod, is safe for concurrent use.
ReadAll Reader.ReadAll() (records [][]string, err error)\n
ReadAll io.ReadAll(r Reader) ([]byte, error)\nReadAll reads from r until an error or EOF and returns the data it read. A\nsuccessful call returns err == nil, not err == EOF. Because ReadAll is\ndefined to read from src until EOF, it does not treat an EOF from Read as an\nerror to be reported.
ReadAll ioutil.ReadAll(r io.Reader) ([]byte, error)\nReadAll reads from r until an error or EOF and returns the data it read. A\nsuccessful call returns err == nil, not err == EOF. Because ReadAll is\ndefined to read from src until EOF, it does not treat an EOF from Read as an\nerror to be reported.\nAs of Go 1.16, this function simply calls io.ReadAll.
ReadAt File.ReadAt(b []byte, off int64) (n int, err error)\n
ReadAt Reader.ReadAt(b []byte, off int64) (n int, err error)\n
ReadAt Reader.ReadAt(b []byte, off int64) (n int, err error)\n
ReadAt SectionReader.ReadAt(p []byte, off int64) (n int, err error)\n
ReadAtLeast io.ReadAtLeast(r Reader, buf []byte, min int) (n int, err error)\nReadAtLeast reads from r into buf until it has read at least min bytes. It\nreturns the number of bytes copied and an error if fewer bytes were read.\nThe error is EOF only if no bytes were read. If an EOF happens after reading\nfewer than min bytes, ReadAtLeast returns ErrUnexpectedEOF. If min is\ngreater than the length of buf, ReadAtLeast returns ErrShortBuffer. On\nreturn, n >= min if and only if err == nil. If r returns an error having\nread at least min bytes, the error is dropped.
ReadByte Buffer.ReadByte() (byte, error)\n
ReadByte Reader.ReadByte() (byte, error)\n
ReadByte Reader.ReadByte() (byte, error)\n
ReadByte Reader.ReadByte() (byte, error)\n
ReadBytes Buffer.ReadBytes(delim byte) (line []byte, err error)\n
ReadBytes Reader.ReadBytes(delim byte) ([]byte, error)\n
ReadCloser io.ReadCloser\nReadCloser is the interface that groups the basic Read and Close methods.\n
ReadDir DirEntry.ReadDir(fsys FS, name string) ([]DirEntry, error)\n
ReadDir FS.ReadDir(name string) ([]fs.DirEntry, error)\n
ReadDir File.ReadDir(n int) ([]DirEntry, error)\n
ReadDir fs.ReadDir(fsys FS, name string) ([]DirEntry, error)\nReadDir reads the named directory and returns a list of directory entries\nsorted by filename.\nIf fs implements ReadDirFS, ReadDir calls fs.ReadDir. Otherwise ReadDir\ncalls fs.Open and uses ReadDir and Close on the returned file.
ReadDir ioutil.ReadDir(dirname string) ([]fs.FileInfo, error)\nReadDir reads the directory named by dirname and returns a list of\nfs.FileInfo for the directory's contents, sorted by filename. If an error\noccurs reading the directory, ReadDir returns no directory entries along\nwith the error.\nAs of Go 1.16, os.ReadDir is a more efficient and correct choice: it returns\na list of fs.DirEntry instead of fs.FileInfo, and it returns partial results\nin the case of an error midway through reading a directory.
ReadDir os.ReadDir(name string) ([]DirEntry, error)\nReadDir reads the named directory, returning all its directory entries\nsorted by filename. If an error occurs reading the directory, ReadDir\nreturns the entries it was able to read before the error, along with the\nerror.
ReadDirFS fs.ReadDirFS\nReadDirFS is the interface implemented by a file system that provides an\noptimized implementation of ReadDir.\n
ReadDirFile fs.ReadDirFile\nA ReadDirFile is a directory file whose entries can be read with the ReadDir\nmethod. Every directory file should implement this interface. (It is\npermissible for any file to implement this interface, but if so ReadDir\nshould return an error for non-directories.)\n
ReadFile FS.ReadFile(name string) ([]byte, error)\n
ReadFile fs.ReadFile(fsys FS, name string) ([]byte, error)\nReadFile reads the named file from the file system fs and returns its\ncontents. A successful call returns a nil error, not io.EOF. (Because\nReadFile reads the whole file, the expected EOF from the final Read is not\ntreated as an error to be reported.)\nIf fs implements ReadFileFS, ReadFile calls fs.ReadFile. Otherwise ReadFile\ncalls fs.Open and uses Read and Close on the returned file.
ReadFile ioutil.ReadFile(filename string) ([]byte, error)\nReadFile reads the file named by filename and returns the contents. A\nsuccessful call returns err == nil, not err == EOF. Because ReadFile reads\nthe whole file, it does not treat an EOF from Read as an error to be\nreported.\nAs of Go 1.16, this function simply calls os.ReadFile.
ReadFile os.ReadFile(name string) ([]byte, error)\nReadFile reads the named file and returns the contents. A successful call\nreturns err == nil, not err == EOF. Because ReadFile reads the whole file,\nit does not treat an EOF from Read as an error to be reported.
ReadFileFS fs.ReadFileFS\nReadFileFS is the interface implemented by a file system that provides an\noptimized implementation of ReadFile.\n
ReadFrom Buffer.ReadFrom(r io.Reader) (n int64, err error)\n
ReadFrom File.ReadFrom(r io.Reader) (n int64, err error)\n
ReadFrom IPConn.ReadFrom(b []byte) (int, Addr, error)\n
ReadFrom TCPConn.ReadFrom(r io.Reader) (int64, error)\n
ReadFrom UDPConn.ReadFrom(b []byte) (int, Addr, error)\n
ReadFrom UnixConn.ReadFrom(b []byte) (int, Addr, error)\n
ReadFrom Writer.ReadFrom(r io.Reader) (n int64, err error)\n
ReadFromIP IPConn.ReadFromIP(b []byte) (int, *IPAddr, error)\n
ReadFromUDP UDPConn.ReadFromUDP(b []byte) (n int, addr *UDPAddr, err error)\n
ReadFromUnix UnixConn.ReadFromUnix(b []byte) (int, *UnixAddr, error)\n
ReadFull io.ReadFull(r Reader, buf []byte) (n int, err error)\nReadFull reads exactly len(buf) bytes from r into buf. It returns the number\nof bytes copied and an error if fewer bytes were read. The error is EOF only\nif no bytes were read. If an EOF happens after reading some but not all the\nbytes, ReadFull returns ErrUnexpectedEOF. On return, n == len(buf) if and\nonly if err == nil. If r returns an error having read at least len(buf)\nbytes, the error is dropped.
ReadLine Reader.ReadLine() (line []byte, isPrefix bool, err error)\n
ReadMemStats runtime.ReadMemStats(m *MemStats)\nReadMemStats populates m with memory allocator statistics.\nThe returned memory allocator statistics are up to date as of the call to\nReadMemStats. This is in contrast with a heap profile, which is a snapshot\nas of the most recently completed garbage collection cycle.
ReadMsgIP IPConn.ReadMsgIP(b, oob []byte) (n, oobn, flags int, addr *IPAddr, err error)\n
ReadMsgUDP UDPConn.ReadMsgUDP(b, oob []byte) (n, oobn, flags int, addr *UDPAddr, err error)\n
ReadMsgUnix UnixConn.ReadMsgUnix(b, oob []byte) (n, oobn, flags int, addr *UnixAddr, err error)\n
ReadRequest http.ReadRequest(b *bufio.Reader) (*Request, error)\nReadRequest reads and parses an incoming request from b.\nReadRequest is a low-level function and should only be used for specialized\napplications; most code should use the Server to read requests and handle\nthem via the Handler interface. ReadRequest only supports HTTP/1.x requests.\nFor HTTP/2, use golang.org/x/net/http2.
ReadResponse http.ReadResponse(r *bufio.Reader, req *Request) (*Response, error)\nReadResponse reads and returns an HTTP response from r. The req parameter\noptionally specifies the Request that corresponds to this Response. If nil,\na GET request is assumed. Clients must call resp.Body.Close when finished\nreading resp.Body. After that call, clients can inspect resp.Trailer to find\nkey/value pairs included in the response trailer.
ReadRune Buffer.ReadRune() (r rune, size int, err error)\n
ReadRune Reader.ReadRune() (ch rune, size int, err error)\n
ReadRune Reader.ReadRune() (ch rune, size int, err error)\n
ReadRune Reader.ReadRune() (r rune, size int, err error)\n
ReadSeekCloser io.ReadSeekCloser\nReadSeekCloser is the interface that groups the basic Read, Seek and Close\nmethods.\n
ReadSeeker io.ReadSeeker\nReadSeeker is the interface that groups the basic Read and Seek methods.\n
ReadSlice Reader.ReadSlice(delim byte) (line []byte, err error)\n
ReadString Buffer.ReadString(delim byte) (line string, err error)\n
ReadString Reader.ReadString(delim byte) (string, error)\n
ReadTrace runtime.ReadTrace() []byte\nReadTrace returns the next chunk of binary tracing data, blocking until data\nis available. If tracing is turned off and all the data accumulated while it\nwas on has been returned, ReadTrace returns nil. The caller must copy the\nreturned data before calling ReadTrace again. ReadTrace must be called from\none goroutine at a time.
ReadUvarint binary.ReadUvarint(r io.ByteReader) (uint64, error)\nReadUvarint reads an encoded unsigned integer from r and returns it as a\nuint64.
ReadVarint binary.ReadVarint(r io.ByteReader) (int64, error)\nReadVarint reads an encoded signed integer from r and returns it as an\nint64.
ReadWriteCloser io.ReadWriteCloser\nReadWriteCloser is the interface that groups the basic Read, Write and Close\nmethods.\n
ReadWriteSeeker io.ReadWriteSeeker\nReadWriteSeeker is the interface that groups the basic Read, Write and Seek\nmethods.\n
ReadWriter bufio.ReadWriter\nReadWriter stores pointers to a Reader and a Writer. It implements\nio.ReadWriter.\n
ReadWriter io.ReadWriter\nReadWriter is the interface that groups the basic Read and Write methods.\n
Readdir File.Readdir(n int) ([]FileInfo, error)\n
Readdirnames File.Readdirnames(n int) (names []string, err error)\n
Reader bufio.Reader\nReader implements buffering for an io.Reader object.\n
Reader bytes.Reader\nA Reader implements the io.Reader, io.ReaderAt, io.WriterTo, io.Seeker,\nio.ByteScanner, and io.RuneScanner interfaces by reading from a byte slice.\nUnlike a Buffer, a Reader is read-only and supports seeking. The zero value\nfor Reader operates like a Reader of an empty slice.\n
Reader csv.Reader\nA Reader reads records from a CSV-encoded file.\n\nAs returned by NewReader, a Reader expects input conforming to RFC 4180. The\nexported fields can be changed to customize the details before the first\ncall to Read or ReadAll.\n\nThe Reader converts all \r\n sequences in its input to plain \n, including\nin multiline field values, so that the returned data does not depend on\nwhich line-ending convention an input file uses.\n
Reader io.Reader\nReader is the interface that wraps the basic Read method.\n\nRead reads up to len(p) bytes into p. It returns the number of bytes read (0\n<= n <= len(p)) and any error encountered. Even if Read returns n < len(p),\nit may use all of p as scratch space during the call. If some data is\navailable but not len(p) bytes, Read conventionally returns what is\navailable instead of waiting for more.\n\nWhen Read encounters an error or end-of-file condition after successfully\nreading n > 0 bytes, it returns the number of bytes read. It may return the\n(non-nil) error from the same call or return the error (and n == 0) from a\nsubsequent call. An instance of this general case is that a Reader returning\na non-zero number of bytes at the end of the input stream may return either\nerr == EOF or err == nil. The next Read should return 0, EOF.\n\nCallers should always process the n > 0 bytes returned before considering\nthe error err. Doing so correctly handles I/O errors that happen after\nreading some bytes and also both of the allowed EOF behaviors.\n\nImplementations of Read are discouraged from returning a zero byte count\nwith a nil error, except when len(p) == 0. Callers should treat a return of\n0 and nil as indicating that nothing happened; in particular it does not\nindicate EOF.\n\nImplementations must not retain p.\n
Reader strings.Reader\nA Reader implements the io.Reader, io.ReaderAt, io.ByteReader,\nio.ByteScanner, io.RuneReader, io.RuneScanner, io.Seeker, and io.WriterTo\ninterfaces by reading from a string. The zero value for Reader operates like\na Reader of an empty string.\n
ReaderAt io.ReaderAt\nReaderAt is the interface that wraps the basic ReadAt method.\n\nReadAt reads len(p) bytes into p starting at offset off in the underlying\ninput source. It returns the number of bytes read (0 <= n <= len(p)) and any\nerror encountered.\n\nWhen ReadAt returns n < len(p), it returns a non-nil error explaining why\nmore bytes were not returned. In this respect, ReadAt is stricter than Read.\n\nEven if ReadAt returns n < len(p), it may use all of p as scratch space\nduring the call. If some data is available but not len(p) bytes, ReadAt\nblocks until either all the data is available or an error occurs. In this\nrespect ReadAt is different from Read.\n\nIf the n = len(p) bytes returned by ReadAt are at the end of the input\nsource, ReadAt may return either err == EOF or err == nil.\n\nIf ReadAt is reading from an input source with a seek offset, ReadAt should\nnot affect nor be affected by the underlying seek offset.\n\nClients of ReadAt can execute parallel ReadAt calls on the same input\nsource.\n\nImplementations must not retain p.\n
ReaderFrom io.ReaderFrom\nReaderFrom is the interface that wraps the ReadFrom method.\n\nReadFrom reads data from r until EOF or error. The return value n is the\nnumber of bytes read. Any error except EOF encountered during the read is\nalso returned.\n\nThe Copy function uses ReaderFrom if available.\n
Readlink os.Readlink(name string) (string, error)\nReadlink returns the destination of the named symbolic link. If there is an\nerror, it will be of type *PathError.
Rect cmplx.Rect(r, θ float64) complex128\nRect returns the complex number x with polar coordinates r, θ.
Redacted URL.Redacted() string\n
Redirect http.Redirect(w ResponseWriter, r *Request, url string, code int)\nRedirect replies to the request with a redirect to url, which may be a path\nrelative to the request path.\nThe provided code should be in the 3xx range and is usually\nStatusMovedPermanently, StatusFound or StatusSeeOther.\nIf the Content-Type header has not been set, Redirect sets it to "text/html;\ncharset=utf-8" and writes a small HTML body. Setting the Content-Type header\nto any value, including nil, disables that behavior.
RedirectHandler Handler.RedirectHandler(url string, code int) Handler\n
RedirectHandler http.RedirectHandler(url string, code int) Handler\nRedirectHandler returns a request handler that redirects each request it\nreceives to the given url using the given status code.\nThe provided code should be in the 3xx range and is usually\nStatusMovedPermanently, StatusFound or StatusSeeOther.
Referer Request.Referer() string\n
Regexp regexp.Regexp\nRegexp is the representation of a compiled regular expression. A Regexp is\nsafe for concurrent use by multiple goroutines, except for configuration\nmethods, such as Longest.\n
Regexp syntax.Regexp\nA Regexp is a node in a regular expression syntax tree.\n
RegisterCover testing.RegisterCover(c Cover)\nRegisterCover records the coverage data accumulators for the tests. NOTE:\nThis function is internal to the testing infrastructure and may change. It\nis not covered (yet) by the Go 1 compatibility guidelines.
RegisterOnShutdown Server.RegisterOnShutdown(f func())\n
RegisterProtocol Transport.RegisterProtocol(scheme string, rt RoundTripper)\n
Rel filepath.Rel(basepath, targpath string) (string, error)\nRel returns a relative path that is lexically equivalent to targpath when\njoined to basepath with an intervening separator. That is, Join(basepath,\nRel(basepath, targpath)) is equivalent to targpath itself. On success, the\nreturned path will always be relative to basepath, even if basepath and\ntargpath share no elements. An error is returned if targpath can't be made\nrelative to basepath or if knowing the current working directory would be\nnecessary to compute it. Rel calls Clean on the result.
Release Process.Release() error\n
Remainder math.Remainder(x, y float64) float64\nRemainder returns the IEEE 754 floating-point remainder of x/y.\nSpecial cases are:\nRemainder(±Inf, y) = NaN\nRemainder(NaN, y) = NaN\nRemainder(x, 0) = NaN\nRemainder(x, ±Inf) = x\nRemainder(x, NaN) = NaN
RemoteAddr IPConn.RemoteAddr() Addr\n
RemoteAddr TCPConn.RemoteAddr() Addr\n
RemoteAddr UDPConn.RemoteAddr() Addr\n
RemoteAddr UnixConn.RemoteAddr() Addr\n
Remove os.Remove(name string) error\nRemove removes the named file or (empty) directory. If there is an error, it\nwill be of type *PathError.
RemoveAll os.RemoveAll(path string) error\nRemoveAll removes path and any children it contains. It removes everything\nit can but returns the first error it encounters. If the path does not\nexist, RemoveAll returns nil (no error). If there is an error, it will be of\ntype *PathError.
Rename os.Rename(oldpath, newpath string) error\nRename renames (moves) oldpath to newpath. If newpath already exists and is\nnot a directory, Rename replaces it. OS-specific restrictions may apply when\noldpath and newpath are in different directories. If there is an error, it\nwill be of type *LinkError.
Repeat bytes.Repeat(b []byte, count int) []byte\nRepeat returns a new byte slice consisting of count copies of b.\nIt panics if count is negative or if the result of (len(b) * count)\noverflows.
Repeat strings.Repeat(s string, count int) string\nRepeat returns a new string consisting of count copies of the string s.\nIt panics if count is negative or if the result of (len(s) * count)\noverflows.
Replace Replacer.Replace(s string) string\n
Replace bytes.Replace(s, old, new []byte, n int) []byte\nReplace returns a copy of the slice s with the first n non-overlapping\ninstances of old replaced by new. If old is empty, it matches at the\nbeginning of the slice and after each UTF-8 sequence, yielding up to k+1\nreplacements for a k-rune slice. If n < 0, there is no limit on the number\nof replacements.
Replace strings.Replace(s, old, new string, n int) string\nReplace returns a copy of the string s with the first n non-overlapping\ninstances of old replaced by new. If old is empty, it matches at the\nbeginning of the string and after each UTF-8 sequence, yielding up to k+1\nreplacements for a k-rune string. If n < 0, there is no limit on the number\nof replacements.
ReplaceAll Regexp.ReplaceAll(src, repl []byte) []byte\n
ReplaceAll bytes.ReplaceAll(s, old, new []byte) []byte\nReplaceAll returns a copy of the slice s with all non-overlapping instances\nof old replaced by new. If old is empty, it matches at the beginning of the\nslice and after each UTF-8 sequence, yielding up to k+1 replacements for a\nk-rune slice.
ReplaceAll strings.ReplaceAll(s, old, new string) string\nReplaceAll returns a copy of the string s with all non-overlapping instances\nof old replaced by new. If old is empty, it matches at the beginning of the\nstring and after each UTF-8 sequence, yielding up to k+1 replacements for a\nk-rune string.
ReplaceAllFunc Regexp.ReplaceAllFunc(src []byte, repl func([]byte) []byte) []byte\n
ReplaceAllLiteral Regexp.ReplaceAllLiteral(src, repl []byte) []byte\n
ReplaceAllLiteralString Regexp.ReplaceAllLiteralString(src, repl string) string\n
ReplaceAllString Regexp.ReplaceAllString(src, repl string) string\n
ReplaceAllStringFunc Regexp.ReplaceAllStringFunc(src string, repl func(string) string) string\n
Replacer strings.Replacer\nReplacer replaces a list of strings with replacements. It is safe for\nconcurrent use by multiple goroutines.\n
ReportAllocs B.ReportAllocs()\n
ReportMetric B.ReportMetric(n float64, unit string)\n
Request http.Request\nA Request represents an HTTP request received by a server or to be sent by a\nclient.\n\nThe field semantics differ slightly between client and server usage. In\naddition to the notes on the fields below, see the documentation for\nRequest.Write and RoundTripper.\n
RequestURI URL.RequestURI() string\n
Reset Buffer.Reset()\n
Reset Builder.Reset()\n
Reset Reader.Reset(b []byte)\n
Reset Reader.Reset(r io.Reader)\n
Reset Reader.Reset(s string)\n
Reset Ticker.Reset(d Duration)\n
Reset Timer.Reset(d Duration) bool\n
Reset Writer.Reset(w io.Writer)\n
Reset signal.Reset(sig ...os.Signal)\nReset undoes the effect of any prior calls to Notify for the provided\nsignals. If no signals are provided, all signal handlers will be reset.
ResetTimer B.ResetTimer()\n
ResolveIPAddr net.ResolveIPAddr(network, address string) (*IPAddr, error)\nResolveIPAddr returns an address of IP end point.\nThe network must be an IP network name.\nIf the host in the address parameter is not a literal IP address,\nResolveIPAddr resolves the address to an address of IP end point. Otherwise,\nit parses the address as a literal IP address. The address parameter can use\na host name, but this is not recommended, because it will return at most one\nof the host name's IP addresses.\nSee func Dial for a description of the network and address parameters.
ResolveReference URL.ResolveReference(ref *URL) *URL\n
ResolveTCPAddr net.ResolveTCPAddr(network, address string) (*TCPAddr, error)\nResolveTCPAddr returns an address of TCP end point.\nThe network must be a TCP network name.\nIf the host in the address parameter is not a literal IP address or the port\nis not a literal port number, ResolveTCPAddr resolves the address to an\naddress of TCP end point. Otherwise, it parses the address as a pair of\nliteral IP address and port number. The address parameter can use a host\nname, but this is not recommended, because it will return at most one of the\nhost name's IP addresses.\nSee func Dial for a description of the network and address parameters.
ResolveUDPAddr net.ResolveUDPAddr(network, address string) (*UDPAddr, error)\nResolveUDPAddr returns an address of UDP end point.\nThe network must be a UDP network name.\nIf the host in the address parameter is not a literal IP address or the port\nis not a literal port number, ResolveUDPAddr resolves the address to an\naddress of UDP end point. Otherwise, it parses the address as a pair of\nliteral IP address and port number. The address parameter can use a host\nname, but this is not recommended, because it will return at most one of the\nhost name's IP addresses.\nSee func Dial for a description of the network and address parameters.
ResolveUnixAddr net.ResolveUnixAddr(network, address string) (*UnixAddr, error)\nResolveUnixAddr returns an address of Unix domain socket end point.\nThe network must be a Unix network name.\nSee func Dial for a description of the network and address parameters.
Resolver net.Resolver\nA Resolver looks up names and numbers.\n\nA nil *Resolver is equivalent to a zero Resolver.\n
Response http.Response\nResponse represents the response from an HTTP request.\n\nThe Client and Transport return Responses from servers once the response\nheaders have been received. The response body is streamed on demand as the\nBody field is read.\n
ResponseWriter http.ResponseWriter\nA ResponseWriter interface is used by an HTTP handler to construct an HTTP\nresponse.\n\nA ResponseWriter may not be used after the Handler.ServeHTTP method has\nreturned.\n
Reverse Interface.Reverse(data Interface) Interface\n
Reverse sort.Reverse(data Interface) Interface\nReverse returns the reverse order for data.
Round Time.Round(d Duration) Time\n
Round math.Round(x float64) float64\nRound returns the nearest integer, rounding half away from zero.\nSpecial cases are:\nRound(±0) = ±0\nRound(±Inf) = ±Inf\nRound(NaN) = NaN
RoundToEven math.RoundToEven(x float64) float64\nRoundToEven returns the nearest integer, rounding ties to even.\nSpecial cases are:\nRoundToEven(±0) = ±0\nRoundToEven(±Inf) = ±Inf\nRoundToEven(NaN) = NaN
RoundTrip Transport.RoundTrip(req *Request) (*Response, error)\n
RoundTripper http.RoundTripper\nRoundTripper is an interface representing the ability to execute a single\nHTTP transaction, obtaining the Response for a given Request.\n\nA RoundTripper must be safe for concurrent use by multiple goroutines.\n
Run B.Run(name string, f func(b *B)) bool\n
Run Cmd.Run() error\n
Run M.Run() (code int)\n
Run T.Run(name string, f func(t *T)) bool\n
RunBenchmarks testing.RunBenchmarks(matchString func(pat, str string) (bool, error))\nRunBenchmarks is an internal function but exported because it is\ncross-package; it is part of the implementation of the "go test" command.
RunExamples testing.RunExamples(matchString func(pat, str string) (bool, error), examples []InternalExample) (ok bool)\nRunExamples is an internal function but exported because it is\ncross-package; it is part of the implementation of the "go test" command.
RunParallel B.RunParallel(body func(*PB))\n
RunTests testing.RunTests(matchString func(pat, str string) (bool, error), tests []InternalTest) (ok bool)\nRunTests is an internal function but exported because it is cross-package;\nit is part of the implementation of the "go test" command.
RuneCount utf8.RuneCount(p []byte) int\nRuneCount returns the number of runes in p. Erroneous and short encodings\nare treated as single runes of width 1 byte.
RuneCountInString utf8.RuneCountInString(s string) (n int)\nRuneCountInString is like RuneCount but its input is a string.
RuneLen utf8.RuneLen(r rune) int\nRuneLen returns the number of bytes required to encode the rune. It returns\n-1 if the rune is not a valid value to encode in UTF-8.
RuneReader io.RuneReader\nRuneReader is the interface that wraps the ReadRune method.\n\nReadRune reads a single UTF-8 encoded Unicode character and returns the rune\nand its size in bytes. If no character is available, err will be set.\n
RuneScanner io.RuneScanner\nRuneScanner is the interface that adds the UnreadRune method to the basic\nReadRune method.\n\nUnreadRune causes the next call to ReadRune to return the same rune as the\nprevious call to ReadRune. It may be an error to call UnreadRune twice\nwithout an intervening call to ReadRune.\n
RuneStart utf8.RuneStart(b byte) bool\nRuneStart reports whether the byte could be the first byte of an encoded,\npossibly invalid rune. Second and subsequent bytes always have the top two\nbits set to 10.
Runes bytes.Runes(s []byte) []rune\nRunes interprets s as a sequence of UTF-8-encoded code points. It returns a\nslice of runes (Unicode code points) equivalent to s.
RuntimeError TypeAssertionError.RuntimeError()\n
SRV net.SRV\nAn SRV represents a single DNS SRV record.\n
SameFile os.SameFile(fi1, fi2 FileInfo) bool\nSameFile reports whether fi1 and fi2 describe the same file. For example, on\nUnix this means that the device and inode fields of the two underlying\nstructures are identical; on other systems the decision may be based on the\npath names. SameFile only applies to results returned by this package's\nStat. It returns false in other cases.
Scan Scanner.Scan() bool\n
Scan Scanner.Scan() rune\n
Scan fmt.Scan(a ...interface{}) (n int, err error)\nScan scans text read from standard input, storing successive space-separated\nvalues into successive arguments. Newlines count as space. It returns the\nnumber of items successfully scanned. If that is less than the number of\narguments, err will report why.
ScanBytes bufio.ScanBytes(data []byte, atEOF bool) (advance int, token []byte, err error)\nScanBytes is a split function for a Scanner that returns each byte as a\ntoken.
ScanLines bufio.ScanLines(data []byte, atEOF bool) (advance int, token []byte, err error)\nScanLines is a split function for a Scanner that returns each line of text,\nstripped of any trailing end-of-line marker. The returned line may be empty.\nThe end-of-line marker is one optional carriage return followed by one\nmandatory newline. In regular expression notation, it is `\r?\n`. The last\nnon-empty line of input will be returned even if it has no newline.
ScanRunes bufio.ScanRunes(data []byte, atEOF bool) (advance int, token []byte, err error)\nScanRunes is a split function for a Scanner that returns each UTF-8-encoded\nrune as a token. The sequence of runes returned is equivalent to that from a\nrange loop over the input as a string, which means that erroneous UTF-8\nencodings translate to U+FFFD = "\xef\xbf\xbd". Because of the Scan\ninterface, this makes it impossible for the client to distinguish correctly\nencoded replacement runes from encoding errors.
ScanState fmt.ScanState\nScanState represents the scanner state passed to custom scanners. Scanners\nmay do rune-at-a-time scanning or ask the ScanState to discover the next\nspace-delimited token.\n
ScanWords bufio.ScanWords(data []byte, atEOF bool) (advance int, token []byte, err error)\nScanWords is a split function for a Scanner that returns each\nspace-separated word of text, with surrounding spaces deleted. It will never\nreturn an empty string. The definition of space is set by unicode.IsSpace.
Scanf fmt.Scanf(format string, a ...interface{}) (n int, err error)\nScanf scans text read from standard input, storing successive\nspace-separated values into successive arguments as determined by the\nformat. It returns the number of items successfully scanned. If that is less\nthan the number of arguments, err will report why. Newlines in the input\nmust match newlines in the format. The one exception: the verb %c always\nscans the next rune in the input, even if it is a space (or tab etc.) or\nnewline.
Scanln fmt.Scanln(a ...interface{}) (n int, err error)\nScanln is similar to Scan, but stops scanning at a newline and after the\nfinal item there must be a newline or EOF.
Scanner bufio.Scanner\nScanner provides a convenient interface for reading data such as a file of\nnewline-delimited lines of text. Successive calls to the Scan method will\nstep through the 'tokens' of a file, skipping the bytes between the tokens.\nThe specification of a token is defined by a split function of type\nSplitFunc; the default split function breaks the input into lines with line\ntermination stripped. Split functions are defined in this package for\nscanning a file into lines, bytes, UTF-8-encoded runes, and space-delimited\nwords. The client may instead provide a custom split function.\n\nScanning stops unrecoverably at EOF, the first I/O error, or a token too\nlarge to fit in the buffer. When a scan stops, the reader may have advanced\narbitrarily far past the last token. Programs that need more control over\nerror handling or large tokens, or must run sequential scans on a reader,\nshould use bufio.Reader instead.\n
Scanner fmt.Scanner\nScanner is implemented by any value that has a Scan method, which scans the\ninput for the representation of a value and stores the result in the\nreceiver, which must be a pointer to be useful. The Scan method is called\nfor any argument to Scan, Scanf, or Scanln that implements it.\n
Scanner scanner.Scanner\nA Scanner implements reading of Unicode characters and tokens from an\nio.Reader.\n
Search sort.Search(n int, f func(int) bool) int\nSearch uses binary search to find and return the smallest index i in [0, n)\nat which f(i) is true, assuming that on the range [0, n), f(i) == true\nimplies f(i+1) == true. That is, Search requires that f is false for some\n(possibly empty) prefix of the input range [0, n) and then true for the\n(possibly empty) remainder; Search returns the first true index. If there is\nno such index, Search returns n. (Note that the "not found" return value is\nnot -1 as in, for instance, strings.Index.) Search calls f(i) only for i in\nthe range [0, n).\nA common use of Search is to find the index i for a value x in a sorted,\nindexable data structure such as an array or slice. In this case, the\nargument f, typically a closure, captures the value to be searched for, and\nhow the data structure is indexed and ordered.\nFor instance, given a slice data sorted in ascending order, the call\nSearch(len(data), func(i int) bool { return data[i] >= 23 }) returns the\nsmallest index i such that data[i] >= 23. If the caller wants to find\nwhether 23 is in the slice, it must test data[i] == 23 separately.\nSearching data sorted in descending order would use the <= operator instead\nof the >= operator.\nTo complete the example above, the following code tries to find the value x\nin an integer slice data sorted in ascending order:\nx := 23\ni := sort.Search(len(data), func(i int) bool { return data[i] >= x })\nif i < len(data) && data[i] == x {\n// x is present at data[i]\n} else {\n// x is not present in data,\n// but i is the index where it would be inserted.\n}\nAs a more whimsical example, this program guesses your number:\nfunc GuessingGame() {\nvar s string\nfmt.Printf("Pick an integer from 0 to 100.\n")\nanswer := sort.Search(100, func(i int) bool {\nfmt.Printf("Is your number <= %d? ", i)\nfmt.Scanf("%s", &s)\nreturn s != "" && s[0] == 'y'\n})\nfmt.Printf("Your number is %d.\n", answer)\n}
SearchFloat64s sort.SearchFloat64s(a []float64, x float64) int\nSearchFloat64s searches for x in a sorted slice of float64s and returns the\nindex as specified by Search. The return value is the index to insert x if x\nis not present (it could be len(a)). The slice must be sorted in ascending\norder.
SearchInts sort.SearchInts(a []int, x int) int\nSearchInts searches for x in a sorted slice of ints and returns the index as\nspecified by Search. The return value is the index to insert x if x is not\npresent (it could be len(a)). The slice must be sorted in ascending order.
SearchStrings sort.SearchStrings(a []string, x string) int\nSearchStrings searches for x in a sorted slice of strings and returns the\nindex as specified by Search. The return value is the index to insert x if x\nis not present (it could be len(a)). The slice must be sorted in ascending\norder.
Second Time.Second() int\n
SectionReader io.SectionReader\nSectionReader implements Read, Seek, and ReadAt on a section of an\nunderlying ReaderAt.\n
Seed Rand.Seed(seed int64)\n
Seed rand.Seed(seed int64)\nSeed uses the provided seed value to initialize the default Source to a\ndeterministic state. If Seed is not called, the generator behaves as if\nseeded by Seed(1). Seed values that have the same remainder when divided by\n2³¹-1 generate the same pseudo-random sequence. Seed, unlike the Rand.Seed\nmethod, is safe for concurrent use.
Seek File.Seek(offset int64, whence int) (ret int64, err error)\n
Seek Reader.Seek(offset int64, whence int) (int64, error)\n
Seek Reader.Seek(offset int64, whence int) (int64, error)\n
Seek SectionReader.Seek(offset int64, whence int) (int64, error)\n
Seeker io.Seeker\nSeeker is the interface that wraps the basic Seek method.\n\nSeek sets the offset for the next Read or Write to offset, interpreted\naccording to whence: SeekStart means relative to the start of the file,\nSeekCurrent means relative to the current offset, and SeekEnd means relative\nto the end. Seek returns the new offset relative to the start of the file\nand an error, if any.\n\nSeeking to an offset before the start of the file is an error. Seeking to\nany positive offset is legal, but the behavior of subsequent I/O operations\non the underlying object is implementation-dependent.\n
Serve Server.Serve(l net.Listener) error\n
Serve http.Serve(l net.Listener, handler Handler) error\nServe accepts incoming HTTP connections on the listener l, creating a new\nservice goroutine for each. The service goroutines read requests and then\ncall handler to reply to them.\nThe handler is typically nil, in which case the DefaultServeMux is used.\nHTTP/2 support is only enabled if the Listener returns *tls.Conn connections\nand they were configured with "h2" in the TLS Config.NextProtos.\nServe always returns a non-nil error.
ServeContent http.ServeContent(w ResponseWriter, req *Request, name string, modtime time.Time)\nServeContent replies to the request using the content in the provided\nReadSeeker. The main benefit of ServeContent over io.Copy is that it handles\nRange requests properly, sets the MIME type, and handles If-Match,\nIf-Unmodified-Since, If-None-Match, If-Modified-Since, and If-Range\nrequests.\nIf the response's Content-Type header is not set, ServeContent first tries\nto deduce the type from name's file extension and, if that fails, falls back\nto reading the first block of the content and passing it to\nDetectContentType. The name is otherwise unused; in particular it can be\nempty and is never sent in the response.\nIf modtime is not the zero time or Unix epoch, ServeContent includes it in a\nLast-Modified header in the response. If the request includes an\nIf-Modified-Since header, ServeContent uses modtime to decide whether the\ncontent needs to be sent at all.\nThe content's Seek method must work: ServeContent uses a seek to the end of\nthe content to determine its size.\nIf the caller has set w's ETag header formatted per RFC 7232, section 2.3,\nServeContent uses it to handle requests using If-Match, If-None-Match, or\nIf-Range.\nNote that *os.File implements the io.ReadSeeker interface.
ServeFile http.ServeFile(w ResponseWriter, r *Request, name string)\nServeFile replies to the request with the contents of the named file or\ndirectory.\nIf the provided file or directory name is a relative path, it is interpreted\nrelative to the current directory and may ascend to parent directories. If\nthe provided name is constructed from user input, it should be sanitized\nbefore calling ServeFile.\nAs a precaution, ServeFile will reject requests where r.URL.Path contains a\n".." path element; this protects against callers who might unsafely use\nfilepath.Join on r.URL.Path without sanitizing it and then use that\nfilepath.Join result as the name argument.\nAs another special case, ServeFile redirects any request where r.URL.Path\nends in "/index.html" to the same path, without the final "index.html". To\navoid such redirects either modify the path or use ServeContent.\nOutside of those two special cases, ServeFile does not use r.URL.Path for\nselecting the file or directory to serve; only the file or directory\nprovided in the name argument is used.
ServeHTTP ServeMux.ServeHTTP(w ResponseWriter, r *Request)\n
ServeMux http.ServeMux\nServeMux is an HTTP request multiplexer. It matches the URL of each incoming\nrequest against a list of registered patterns and calls the handler for the\npattern that most closely matches the URL.\n\nPatterns name fixed, rooted paths, like "/favicon.ico", or rooted subtrees,\nlike "/images/" (note the trailing slash). Longer patterns take precedence\nover shorter ones, so that if there are handlers registered for both\n"/images/" and "/images/thumbnails/", the latter handler will be called for\npaths beginning "/images/thumbnails/" and the former will receive requests\nfor any other paths in the "/images/" subtree.\n\nNote that since a pattern ending in a slash names a rooted subtree, the\npattern "/" matches all paths not matched by other registered patterns, not\njust the URL with Path == "/".\n\nIf a subtree has been registered and a request is received naming the\nsubtree root without its trailing slash, ServeMux redirects that request to\nthe subtree root (adding the trailing slash). This behavior can be\noverridden with a separate registration for the path without the trailing\nslash. For example, registering "/images/" causes ServeMux to redirect a\nrequest for "/images" to "/images/", unless "/images" has been registered\nseparately.\n\nPatterns may optionally begin with a host name, restricting matches to URLs\non that host only. Host-specific patterns take precedence over general\npatterns, so that a handler might register for the two patterns\n"/codesearch" and "codesearch.google.com/" without also taking over requests\nfor "http://www.google.com/".\n\nServeMux also takes care of sanitizing the URL request path and the Host\nheader, stripping the port number and redirecting any request containing .\nor .. elements or repeated slashes to an equivalent, cleaner URL.\n
ServeTLS Server.ServeTLS(l net.Listener, certFile, keyFile string) error\n
ServeTLS http.ServeTLS(l net.Listener, handler Handler, certFile, keyFile string) error\nServeTLS accepts incoming HTTPS connections on the listener l, creating a\nnew service goroutine for each. The service goroutines read requests and\nthen call handler to reply to them.\nThe handler is typically nil, in which case the DefaultServeMux is used.\nAdditionally, files containing a certificate and matching private key for\nthe server must be provided. If the certificate is signed by a certificate\nauthority, the certFile should be the concatenation of the server's\ncertificate, any intermediates, and the CA's certificate.\nServeTLS always returns a non-nil error.
Server http.Server\nA Server defines parameters for running an HTTP server. The zero value for\nServer is a valid configuration.\n
Set FlagSet.Set(name, value string) error\n
Set flag.Set(name, value string) error\nSet sets the value of the named command-line flag.
SetBasicAuth Request.SetBasicAuth(username, password string)\n
SetBlockProfileRate runtime.SetBlockProfileRate(rate int)\nSetBlockProfileRate controls the fraction of goroutine blocking events that\nare reported in the blocking profile. The profiler aims to sample an average\nof one blocking event per rate nanoseconds spent blocked.\nTo include every blocking event in the profile, pass rate = 1. To turn off\nprofiling entirely, pass rate <= 0.
SetBytes B.SetBytes(n int64)\n
SetCPUProfileRate runtime.SetCPUProfileRate(hz int)\nSetCPUProfileRate sets the CPU profiling rate to hz samples per second. If\nhz <= 0, SetCPUProfileRate turns off profiling. If the profiler is on, the\nrate cannot be changed without first turning it off.\nMost clients should use the runtime/pprof package or the testing package's\n-test.cpuprofile flag instead of calling SetCPUProfileRate directly.
SetCgoTraceback runtime.SetCgoTraceback(version int, traceback, context, symbolizer unsafe.Pointer)\nSetCgoTraceback records three C functions to use to gather traceback\ninformation from C code and to convert that traceback information into\nsymbolic information. These are used when printing stack traces for a\nprogram that uses cgo.\nThe traceback and context functions may be called from a signal handler, and\nmust therefore use only async-signal safe functions. The symbolizer function\nmay be called while the program is crashing, and so must be cautious about\nusing memory. None of the functions may call back into Go.\nThe context function will be called with a single argument, a pointer to a\nstruct:\nstruct {\nContext uintptr\n}\nIn C syntax, this struct will be\nstruct {\nuintptr_t Context;\n};\nIf the Context field is 0, the context function is being called to record\nthe current traceback context. It should record in the Context field\nwhatever information is needed about the current point of execution to later\nproduce a stack trace, probably the stack pointer and PC. In this case the\ncontext function will be called from C code.\nIf the Context field is not 0, then it is a value returned by a previous\ncall to the context function. This case is called when the context is no\nlonger needed; that is, when the Go code is returning to its C code caller.\nThis permits the context function to release any associated resources.\nWhile it would be correct for the context function to record a complete a\nstack trace whenever it is called, and simply copy that out in the traceback\nfunction, in a typical program the context function will be called many\ntimes without ever recording a traceback for that context. Recording a\ncomplete stack trace in a call to the context function is likely to be\ninefficient.\nThe traceback function will be called with a single argument, a pointer to a\nstruct:\nstruct {\nContext    uintptr\nSigContext uintptr\nBuf        *uintptr\nMax        uintptr\n}\nIn C syntax, this struct will be\nstruct {\nuintptr_t  Context;\nuintptr_t  SigContext;\nuintptr_t* Buf;\nuintptr_t  Max;\n};\nThe Context field will be zero to gather a traceback from the current\nprogram execution point. In this case, the traceback function will be called\nfrom C code.\nOtherwise Context will be a value previously returned by a call to the\ncontext function. The traceback function should gather a stack trace from\nthat saved point in the program execution. The traceback function may be\ncalled from an execution thread other than the one that recorded the\ncontext, but only when the context is known to be valid and unchanging. The\ntraceback function may also be called deeper in the call stack on the same\nthread that recorded the context. The traceback function may be called\nmultiple times with the same Context value; it will usually be appropriate\nto cache the result, if possible, the first time this is called for a\nspecific context value.\nIf the traceback function is called from a signal handler on a Unix system,\nSigContext will be the signal context argument passed to the signal handler\n(a C ucontext_t* cast to uintptr_t). This may be used to start tracing at\nthe point where the signal occurred. If the traceback function is not called\nfrom a signal handler, SigContext will be zero.\nBuf is where the traceback information should be stored. It should be PC\nvalues, such that Buf[0] is the PC of the caller, Buf[1] is the PC of that\nfunction's caller, and so on. Max is the maximum number of entries to store.\nThe function should store a zero to indicate the top of the stack, or that\nthe caller is on a different stack, presumably a Go stack.\nUnlike runtime.Callers, the PC values returned should, when passed to the\nsymbolizer function, return the file/line of the call instruction. No\nadditional subtraction is required or appropriate.\nOn all platforms, the traceback function is invoked when a call from Go to C\nto Go requests a stack trace. On linux/amd64, linux/ppc64le, and\nfreebsd/amd64, the traceback function is also invoked when a signal is\nreceived by a thread that is executing a cgo call. The traceback function\nshould not make assumptions about when it is called, as future versions of\nGo may make additional calls.\nThe symbolizer function will be called with a single argument, a pointer to\na struct:\nstruct {\nPC      uintptr // program counter to fetch information for\nFile    *byte   // file name (NUL terminated)\nLineno  uintptr // line number\nFunc    *byte   // function name (NUL terminated)\nEntry   uintptr // function entry point\nMore    uintptr // set non-zero if more info for this PC\nData    uintptr // unused by runtime, available for function\n}\nIn C syntax, this struct will be\nstruct {\nuintptr_t PC;\nchar*     File;\nuintptr_t Lineno;\nchar*     Func;\nuintptr_t Entry;\nuintptr_t More;\nuintptr_t Data;\n};\nThe PC field will be a value returned by a call to the traceback function.\nThe first time the function is called for a particular traceback, all the\nfields except PC will be 0. The function should fill in the other fields if\npossible, setting them to 0/nil if the information is not available. The\nData field may be used to store any useful information across calls. The\nMore field should be set to non-zero if there is more information for this\nPC, zero otherwise. If More is set non-zero, the function will be called\nagain with the same PC, and may return different information (this is\nintended for use with inlined functions). If More is zero, the function will\nbe called with the next PC value in the traceback. When the traceback is\ncomplete, the function will be called once more with PC set to zero; this\nmay be used to free any information. Each call will leave the fields of the\nstruct set to the same values they had upon return, except for the PC field\nwhen the More field is zero. The function must not keep a copy of the struct\npointer between calls.\nWhen calling SetCgoTraceback, the version argument is the version number of\nthe structs that the functions expect to receive. Currently this must be\nzero.\nThe symbolizer function may be nil, in which case the results of the\ntraceback function will be displayed as numbers. If the traceback function\nis nil, the symbolizer function will never be called. The context function\nmay be nil, in which case the traceback function will only be called with\nthe context field set to zero. If the context function is nil, then calls\nfrom Go to C to Go will not show a traceback for the C portion of the call\nstack.\nSetCgoTraceback should be called only once, ideally from an init function.
SetCookie http.SetCookie(w ResponseWriter, cookie *Cookie)\nSetCookie adds a Set-Cookie header to the provided ResponseWriter's headers.\nThe provided cookie must have a valid Name. Invalid cookies may be silently\ndropped.
SetDeadline File.SetDeadline(t time.Time) error\n
SetDeadline IPConn.SetDeadline(t time.Time) error\n
SetDeadline TCPConn.SetDeadline(t time.Time) error\n
SetDeadline TCPListener.SetDeadline(t time.Time) error\n
SetDeadline UDPConn.SetDeadline(t time.Time) error\n
SetDeadline UnixConn.SetDeadline(t time.Time) error\n
SetDeadline UnixListener.SetDeadline(t time.Time) error\n
SetEscapeHTML Encoder.SetEscapeHTML(on bool)\n
SetFinalizer runtime.SetFinalizer(obj interface{}, finalizer interface{})\nSetFinalizer sets the finalizer associated with obj to the provided\nfinalizer function. When the garbage collector finds an unreachable block\nwith an associated finalizer, it clears the association and runs\nfinalizer(obj) in a separate goroutine. This makes obj reachable again, but\nnow without an associated finalizer. Assuming that SetFinalizer is not\ncalled again, the next time the garbage collector sees that obj is\nunreachable, it will free obj.\nSetFinalizer(obj, nil) clears any finalizer associated with obj.\nThe argument obj must be a pointer to an object allocated by calling new, by\ntaking the address of a composite literal, or by taking the address of a\nlocal variable. The argument finalizer must be a function that takes a\nsingle argument to which obj's type can be assigned, and can have arbitrary\nignored return values. If either of these is not true, SetFinalizer may\nabort the program.\nFinalizers are run in dependency order: if A points at B, both have\nfinalizers, and they are otherwise unreachable, only the finalizer for A\nruns; once A is freed, the finalizer for B can run. If a cyclic structure\nincludes a block with a finalizer, that cycle is not guaranteed to be\ngarbage collected and the finalizer is not guaranteed to run, because there\nis no ordering that respects the dependencies.\nThe finalizer is scheduled to run at some arbitrary time after the program\ncan no longer reach the object to which obj points. There is no guarantee\nthat finalizers will run before a program exits, so typically they are\nuseful only for releasing non-memory resources associated with an object\nduring a long-running program. For example, an os.File object could use a\nfinalizer to close the associated operating system file descriptor when a\nprogram discards an os.File without calling Close, but it would be a mistake\nto depend on a finalizer to flush an in-memory I/O buffer such as a\nbufio.Writer, because the buffer would not be flushed at program exit.\nIt is not guaranteed that a finalizer will run if the size of *obj is zero\nbytes.\nIt is not guaranteed that a finalizer will run for objects allocated in\ninitializers for package-level variables. Such objects may be\nlinker-allocated, not heap-allocated.\nA finalizer may run as soon as an object becomes unreachable. In order to\nuse finalizers correctly, the program must ensure that the object is\nreachable until it is no longer required. Objects stored in global\nvariables, or that can be found by tracing pointers from a global variable,\nare reachable. For other objects, pass the object to a call of the KeepAlive\nfunction to mark the last point in the function where the object must be\nreachable.\nFor example, if p points to a struct, such as os.File, that contains a file\ndescriptor d, and p has a finalizer that closes that file descriptor, and if\nthe last use of p in a function is a call to syscall.Write(p.d, buf, size),\nthen p may be unreachable as soon as the program enters syscall.Write. The\nfinalizer may run at that moment, closing p.d, causing syscall.Write to fail\nbecause it is writing to a closed file descriptor (or, worse, to an entirely\ndifferent file descriptor opened by a different goroutine). To avoid this\nproblem, call runtime.KeepAlive(p) after the call to syscall.Write.\nA single goroutine runs all finalizers for a program, sequentially. If a\nfinalizer must run for a long time, it should do so by starting a new\ngoroutine.
SetFlags Logger.SetFlags(flag int)\n
SetFlags log.SetFlags(flag int)\nSetFlags sets the output flags for the standard logger. The flag bits are\nLdate, Ltime, and so on.
SetIndent Encoder.SetIndent(prefix, indent string)\n
SetKeepAlive TCPConn.SetKeepAlive(keepalive bool) error\n
SetKeepAlivePeriod TCPConn.SetKeepAlivePeriod(d time.Duration) error\n
SetKeepAlivesEnabled Server.SetKeepAlivesEnabled(v bool)\n
SetLinger TCPConn.SetLinger(sec int) error\n
SetMutexProfileFraction runtime.SetMutexProfileFraction(rate int) int\nSetMutexProfileFraction controls the fraction of mutex contention events\nthat are reported in the mutex profile. On average 1/rate events are\nreported. The previous rate is returned.\nTo turn off profiling entirely, pass rate 0. To just read the current rate,\npass rate < 0. (For n>1 the details of sampling may change.)
SetNoDelay TCPConn.SetNoDelay(noDelay bool) error\n
SetOutput FlagSet.SetOutput(output io.Writer)\n
SetOutput Logger.SetOutput(w io.Writer)\n
SetOutput log.SetOutput(w io.Writer)\nSetOutput sets the output destination for the standard logger.
SetParallelism B.SetParallelism(p int)\n
SetPos IdentifierNode.SetPos(pos Pos) *IdentifierNode\n
SetPrefix Logger.SetPrefix(prefix string)\n
SetPrefix log.SetPrefix(prefix string)\nSetPrefix sets the output prefix for the standard logger.
SetReadBuffer IPConn.SetReadBuffer(bytes int) error\n
SetReadBuffer TCPConn.SetReadBuffer(bytes int) error\n
SetReadBuffer UDPConn.SetReadBuffer(bytes int) error\n
SetReadBuffer UnixConn.SetReadBuffer(bytes int) error\n
SetReadDeadline File.SetReadDeadline(t time.Time) error\n
SetReadDeadline IPConn.SetReadDeadline(t time.Time) error\n
SetReadDeadline TCPConn.SetReadDeadline(t time.Time) error\n
SetReadDeadline UDPConn.SetReadDeadline(t time.Time) error\n
SetReadDeadline UnixConn.SetReadDeadline(t time.Time) error\n
SetTree IdentifierNode.SetTree(t *Tree) *IdentifierNode\n
SetUnlinkOnClose UnixListener.SetUnlinkOnClose(unlink bool)\n
SetWriteBuffer IPConn.SetWriteBuffer(bytes int) error\n
SetWriteBuffer TCPConn.SetWriteBuffer(bytes int) error\n
SetWriteBuffer UDPConn.SetWriteBuffer(bytes int) error\n
SetWriteBuffer UnixConn.SetWriteBuffer(bytes int) error\n
SetWriteDeadline File.SetWriteDeadline(t time.Time) error\n
SetWriteDeadline IPConn.SetWriteDeadline(t time.Time) error\n
SetWriteDeadline TCPConn.SetWriteDeadline(t time.Time) error\n
SetWriteDeadline UDPConn.SetWriteDeadline(t time.Time) error\n
SetWriteDeadline UnixConn.SetWriteDeadline(t time.Time) error\n
Setenv B.Setenv(key, value string)\n
Setenv T.Setenv(key, value string)\n
Setenv os.Setenv(key, value string) error\nSetenv sets the value of the environment variable named by the key. It\nreturns an error, if any.
Short testing.Short() bool\nShort reports whether the -test.short flag is set.
Shuffle Rand.Shuffle(n int, swap func(i, j int))\n
Shuffle rand.Shuffle(n int, swap func(i, j int))\nShuffle pseudo-randomizes the order of elements using the default Source. n\nis the number of elements. Shuffle panics if n < 0. swap swaps the elements\nwith indexes i and j.
Shutdown Server.Shutdown(ctx context.Context) error\n
Signal Cond.Signal()\n
Signal Process.Signal(sig Signal) error\n
Signal os.Signal\nA Signal represents an operating system signal. The usual underlying\nimplementation is operating system-dependent: on Unix it is syscall.Signal.\n
Signbit math.Signbit(x float64) bool\nSignbit reports whether x is negative or negative zero.
SimpleFold unicode.SimpleFold(r rune) rune\nSimpleFold iterates over Unicode code points equivalent under the\nUnicode-defined simple case folding. Among the code points equivalent to\nrune (including rune itself), SimpleFold returns the smallest rune > r if\none exists, or else the smallest rune >= 0. If r is not a valid Unicode code\npoint, SimpleFold(r) returns r.\nFor example:\nSimpleFold('A') = 'a'\nSimpleFold('a') = 'A'\nSimpleFold('K') = 'k'\nSimpleFold('k') = '\u212A' (Kelvin symbol, K)\nSimpleFold('\u212A') = 'K'\nSimpleFold('1') = '1'\nSimpleFold(-2) = -2
Simplify Regexp.Simplify() *Regexp\n
Sin cmplx.Sin(x complex128) complex128\nSin returns the sine of x.
Sin math.Sin(x float64) float64\nSin returns the sine of the radian argument x.\nSpecial cases are:\nSin(±0) = ±0\nSin(±Inf) = NaN\nSin(NaN) = NaN
Since time.Since(t Time) Duration\nSince returns the time elapsed since t. It is shorthand for\ntime.Now().Sub(t).
Sincos math.Sincos(x float64) (sin, cos float64)\nSincos returns Sin(x), Cos(x).\nSpecial cases are:\nSincos(±0) = ±0, 1\nSincos(±Inf) = NaN, NaN\nSincos(NaN) = NaN, NaN
Sinh cmplx.Sinh(x complex128) complex128\nSinh returns the hyperbolic sine of x.
Sinh math.Sinh(x float64) float64\nSinh returns the hyperbolic sine of x.\nSpecial cases are:\nSinh(±0) = ±0\nSinh(±Inf) = ±Inf\nSinh(NaN) = NaN
Size Reader.Size() int64\n
Size Reader.Size() int64\n
Size Reader.Size() int\n
Size SectionReader.Size() int64\n
Size Writer.Size() int\n
Size binary.Size(v interface{}) int\nSize returns how many bytes Write would generate to encode the value v,\nwhich must be a fixed-size value or a slice of fixed-size values, or a\npointer to such data. If v is neither of these, Size returns -1.
Skip B.Skip(args ...interface{})\n
Skip Decoder.Skip() error\n
Skip T.Skip(args ...interface{})\n
SkipNow B.SkipNow()\n
SkipNow T.SkipNow()\n
Skipf B.Skipf(format string, args ...interface{})\n
Skipf T.Skipf(format string, args ...interface{})\n
Skipped B.Skipped() bool\n
Skipped T.Skipped() bool\n
Sleep time.Sleep(d Duration)\nSleep pauses the current goroutine for at least the duration d. A negative\nor zero duration causes Sleep to return immediately.
Slice sort.Slice(x interface{}, less func(i, j int) bool)\nSlice sorts the slice x given the provided less function. It panics if x is\nnot a slice.\nThe sort is not guaranteed to be stable: equal elements may be reversed from\ntheir original order. For a stable sort, use SliceStable.\nThe less function must satisfy the same requirements as the Interface type's\nLess method.
SliceIsSorted sort.SliceIsSorted(x interface{}, less func(i, j int) bool) bool\nSliceIsSorted reports whether the slice x is sorted according to the\nprovided less function. It panics if x is not a slice.
SliceStable sort.SliceStable(x interface{}, less func(i, j int) bool)\nSliceStable sorts the slice x using the provided less function, keeping\nequal elements in their original order. It panics if x is not a slice.\nThe less function must satisfy the same requirements as the Interface type's\nLess method.
Sort sort.Sort(data Interface)\nSort sorts data. It makes one call to data.Len to determine n and\nO(n*log(n)) calls to data.Less and data.Swap. The sort is not guaranteed to\nbe stable.
Source rand.Source\nA Source represents a source of uniformly-distributed pseudo-random int64\nvalues in the range [0, 1<<63).\n
Source64 rand.Source64\nA Source64 is a Source that can also generate uniformly-distributed\npseudo-random uint64 values in the range [0, 1<<64) directly. If a Rand r's\nunderlying Source s implements Source64, then r.Uint64 returns the result of\none call to s.Uint64 instead of making two calls to s.Int63.\n
Split Regexp.Split(s string, n int) []string\n
Split Scanner.Split(split SplitFunc)\n
Split bytes.Split(s, sep []byte) [][]byte\nSplit slices s into all subslices separated by sep and returns a slice of\nthe subslices between those separators. If sep is empty, Split splits after\neach UTF-8 sequence. It is equivalent to SplitN with a count of -1.
Split filepath.Split(path string) (dir, file string)\nSplit splits path immediately following the final Separator, separating it\ninto a directory and file name component. If there is no Separator in path,\nSplit returns an empty dir and file set to path. The returned values have\nthe property that path = dir+file.
Split path.Split(path string) (dir, file string)\nSplit splits path immediately following the final slash, separating it into\na directory and file name component. If there is no slash in path, Split\nreturns an empty dir and file set to path. The returned values have the\nproperty that path = dir+file.
Split strings.Split(s, sep string) []string\nSplit slices s into all substrings separated by sep and returns a slice of\nthe substrings between those separators.\nIf s does not contain sep and sep is not empty, Split returns a slice of\nlength 1 whose only element is s.\nIf sep is empty, Split splits after each UTF-8 sequence. If both s and sep\nare empty, Split returns an empty slice.\nIt is equivalent to SplitN with a count of -1.
SplitAfter bytes.SplitAfter(s, sep []byte) [][]byte\nSplitAfter slices s into all subslices after each instance of sep and\nreturns a slice of those subslices. If sep is empty, SplitAfter splits after\neach UTF-8 sequence. It is equivalent to SplitAfterN with a count of -1.
SplitAfter strings.SplitAfter(s, sep string) []string\nSplitAfter slices s into all substrings after each instance of sep and\nreturns a slice of those substrings.\nIf s does not contain sep and sep is not empty, SplitAfter returns a slice\nof length 1 whose only element is s.\nIf sep is empty, SplitAfter splits after each UTF-8 sequence. If both s and\nsep are empty, SplitAfter returns an empty slice.\nIt is equivalent to SplitAfterN with a count of -1.
SplitAfterN bytes.SplitAfterN(s, sep []byte, n int) [][]byte\nSplitAfterN slices s into subslices after each instance of sep and returns a\nslice of those subslices. If sep is empty, SplitAfterN splits after each\nUTF-8 sequence. The count determines the number of subslices to return:\nn > 0: at most n subslices; the last subslice will be the unsplit remainder.\nn == 0: the result is nil (zero subslices)\nn < 0: all subslices
SplitAfterN strings.SplitAfterN(s, sep string, n int) []string\nSplitAfterN slices s into substrings after each instance of sep and returns\na slice of those substrings.\nThe count determines the number of substrings to return:\nn > 0: at most n substrings; the last substring will be the unsplit remainder.\nn == 0: the result is nil (zero substrings)\nn < 0: all substrings\nEdge cases for s and sep (for example, empty strings) are handled as\ndescribed in the documentation for SplitAfter.
SplitHostPort net.SplitHostPort(hostport string) (host, port string, err error)\nSplitHostPort splits a network address of the form "host:port",\n"host%zone:port", "[host]:port" or "[host%zone]:port" into host or host%zone\nand port.\nA literal IPv6 address in hostport must be enclosed in square brackets, as\nin "[::1]:80", "[::1%lo0]:80".\nSee func Dial for a description of the hostport parameter, and host and port\nresults.
SplitList filepath.SplitList(path string) []string\nSplitList splits a list of paths joined by the OS-specific ListSeparator,\nusually found in PATH or GOPATH environment variables. Unlike strings.Split,\nSplitList returns an empty slice when passed an empty string.
SplitN bytes.SplitN(s, sep []byte, n int) [][]byte\nSplitN slices s into subslices separated by sep and returns a slice of the\nsubslices between those separators. If sep is empty, SplitN splits after\neach UTF-8 sequence. The count determines the number of subslices to return:\nn > 0: at most n subslices; the last subslice will be the unsplit remainder.\nn == 0: the result is nil (zero subslices)\nn < 0: all subslices
SplitN strings.SplitN(s, sep string, n int) []string\nSplitN slices s into substrings separated by sep and returns a slice of the\nsubstrings between those separators.\nThe count determines the number of substrings to return:\nn > 0: at most n substrings; the last substring will be the unsplit remainder.\nn == 0: the result is nil (zero substrings)\nn < 0: all substrings\nEdge cases for s and sep (for example, empty strings) are handled as\ndescribed in the documentation for Split.
Sprint fmt.Sprint(a ...interface{}) string\nSprint formats using the default formats for its operands and returns the\nresulting string. Spaces are added between operands when neither is a\nstring.
Sprintf fmt.Sprintf(format string, a ...interface{}) string\nSprintf formats according to a format specifier and returns the resulting\nstring.
Sprintln fmt.Sprintln(a ...interface{}) string\nSprintln formats using the default formats for its operands and returns the\nresulting string. Spaces are always added between operands and a newline is\nappended.
Sqrt cmplx.Sqrt(x complex128) complex128\nSqrt returns the square root of x. The result r is chosen so that real(r) ≥\n0 and imag(r) has the same sign as imag(x).
Sqrt math.Sqrt(x float64) float64\nSqrt returns the square root of x.\nSpecial cases are:\nSqrt(+Inf) = +Inf\nSqrt(±0) = ±0\nSqrt(x < 0) = NaN\nSqrt(NaN) = NaN
Sscan fmt.Sscan(str string, a ...interface{}) (n int, err error)\nSscan scans the argument string, storing successive space-separated values\ninto successive arguments. Newlines count as space. It returns the number of\nitems successfully scanned. If that is less than the number of arguments,\nerr will report why.
Sscanf fmt.Sscanf(str string, format string, a ...interface{}) (n int, err error)\nSscanf scans the argument string, storing successive space-separated values\ninto successive arguments as determined by the format. It returns the number\nof items successfully parsed. Newlines in the input must match newlines in\nthe format.
Sscanln fmt.Sscanln(str string, a ...interface{}) (n int, err error)\nSscanln is similar to Sscan, but stops scanning at a newline and after the\nfinal item there must be a newline or EOF.
Stable sort.Stable(data Interface)\nStable sorts data while keeping the original order of equal elements.\nIt makes one call to data.Len to determine n, O(n*log(n)) calls to data.Less\nand O(n*log(n)*log(n)) calls to data.Swap.
Stack MemProfileRecord.Stack() []uintptr\n
Stack StackRecord.Stack() []uintptr\n
Stack runtime.Stack(buf []byte, all bool) int\nStack formats a stack trace of the calling goroutine into buf and returns\nthe number of bytes written to buf. If all is true, Stack formats stack\ntraces of all other goroutines into buf after the trace for the current\ngoroutine.
StackRecord runtime.StackRecord\nA StackRecord describes a single execution stack.\n
Start Cmd.Start() error\n
StartCond Prog.StartCond() EmptyOp\n
StartElement xml.StartElement\nA StartElement represents an XML start element.\n
StartProcess Process.StartProcess(name string, argv []string, attr *ProcAttr) (*Process, error)\n
StartProcess os.StartProcess(name string, argv []string, attr *ProcAttr) (*Process, error)\nStartProcess starts a new process with the program, arguments and attributes\nspecified by name, argv and attr. The argv slice will become os.Args in the\nnew process, so it normally starts with the program name.\nIf the calling goroutine has locked the operating system thread with\nruntime.LockOSThread and modified any inheritable OS-level thread state (for\nexample, Linux or Plan 9 name spaces), the new process will inherit the\ncaller's thread state.\nStartProcess is a low-level interface. The os/exec package provides\nhigher-level interfaces.\nIf there is an error, it will be of type *PathError.
StartTimer B.StartTimer()\n
StartTrace runtime.StartTrace() error\nStartTrace enables tracing for the current process. While tracing, the data\nwill be buffered and available via ReadTrace. StartTrace returns an error if\ntracing is already enabled. Most clients should use the runtime/trace\npackage or the testing package's -test.trace flag instead of calling\nStartTrace directly.
Stat File.Stat() (FileInfo, error)\n
Stat FileInfo.Stat(fsys FS, name string) (FileInfo, error)\n
Stat fs.Stat(fsys FS, name string) (FileInfo, error)\nStat returns a FileInfo describing the named file from the file system.\nIf fs implements StatFS, Stat calls fs.Stat. Otherwise, Stat opens the file\nto stat it.
Stat os.Stat(name string) (FileInfo, error)\nStat returns a FileInfo describing the named file. If there is an error, it\nwill be of type *PathError.
StatFS fs.StatFS\nA StatFS is a file system with a Stat method.\n
State fmt.State\nState represents the printer state passed to custom formatters. It provides\naccess to the io.Writer interface plus information about the flags and\noptions for the operand's format specifier.\n
StatusText http.StatusText(code int) string\nStatusText returns a text for the HTTP status code. It returns the empty\nstring if the code is unknown.
StderrPipe Cmd.StderrPipe() (io.ReadCloser, error)\n
StdinPipe Cmd.StdinPipe() (io.WriteCloser, error)\n
StdoutPipe Cmd.StdoutPipe() (io.ReadCloser, error)\n
Stop Ticker.Stop()\n
Stop Timer.Stop() bool\n
Stop signal.Stop(c chan<- os.Signal)\nStop causes package signal to stop relaying incoming signals to c. It undoes\nthe effect of all prior calls to Notify using c. When Stop returns, it is\nguaranteed that c will receive no more signals.
StopTimer B.StopTimer()\n
StopTrace runtime.StopTrace()\nStopTrace stops tracing, if it was previously enabled. StopTrace only\nreturns after all the reads for the trace have completed.
Store Map.Store(key, value interface{})\n
Strict Encoding.Strict() *Encoding\n
String ActionNode.String() string\n
String BenchmarkResult.String() string\n
String BoolNode.String() string\n
String BranchNode.String() string\n
String Buffer.String() string\n
String Builder.String() string\n
String ChainNode.String() string\n
String Cmd.String() string\n
String CommandNode.String() string\n
String CommentNode.String() string\n
String Cookie.String() string\n
String DotNode.String() string\n
String FieldNode.String() string\n
String FlagSet.String(name string, value string, usage string) *string\n
String IPAddr.String() string\n
String IPNet.String() string\n
String IdentifierNode.String() string\n
String Inst.String() string\n
String ListNode.String() string\n
String Location.String() string\n
String NilNode.String() string\n
String NumberNode.String() string\n
String PipeNode.String() string\n
String Position.String() string\n
String ProcessState.String() string\n
String Prog.String() string\n
String Regexp.String() string\n
String Regexp.String() string\n
String StringNode.String() string\n
String TCPAddr.String() string\n
String TemplateNode.String() string\n
String TextNode.String() string\n
String Time.String() string\n
String UDPAddr.String() string\n
String URL.String() string\n
String UnixAddr.String() string\n
String Userinfo.String() string\n
String VariableNode.String() string\n
String flag.String(name string, value string, usage string) *string\nString defines a string flag with specified name, default value, and usage\nstring. The return value is the address of a string variable that stores the\nvalue of the flag.
StringNode parse.StringNode\nStringNode holds a string constant. The value has been "unquoted".\n
StringVar FlagSet.StringVar(p *string, name string, value string, usage string)\n
StringVar flag.StringVar(p *string, name string, value string, usage string)\nStringVar defines a string flag with specified name, default value, and\nusage string. The argument p points to a string variable in which to store\nthe value of the flag.
StringWriter io.StringWriter\nStringWriter is the interface that wraps the WriteString method.\n
Stringer fmt.Stringer\nStringer is implemented by any value that has a String method, which defines\nthe “native” format for that value. The String method is used to print\nvalues passed as an operand to any format that accepts a string or to an\nunformatted printer such as Print.\n
Strings sort.Strings(x []string)\nStrings sorts a slice of strings in increasing order.
StringsAreSorted sort.StringsAreSorted(x []string) bool\nStringsAreSorted reports whether the slice x is sorted in increasing order.
StripPrefix Handler.StripPrefix(prefix string, h Handler) Handler\n
StripPrefix http.StripPrefix(prefix string, h Handler) Handler\nStripPrefix returns a handler that serves HTTP requests by removing the\ngiven prefix from the request URL's Path (and RawPath if set) and invoking\nthe handler h. StripPrefix handles a request for a path that doesn't begin\nwith prefix by replying with an HTTP 404 not found error. The prefix must\nmatch exactly: if the prefix in the request contains escaped characters the\nreply is also an HTTP 404 not found error.
Sub FS.Sub(fsys FS, dir string) (FS, error)\n
Sub Time.Sub(u Time) Duration\n
Sub fs.Sub(fsys FS, dir string) (FS, error)\nSub returns an FS corresponding to the subtree rooted at fsys's dir.\nIf dir is ".", Sub returns fsys unchanged. Otherwise, if fs implements\nSubFS, Sub returns fsys.Sub(dir). Otherwise, Sub returns a new FS\nimplementation sub that, in effect, implements sub.Open(name) as\nfsys.Open(path.Join(dir, name)). The implementation also translates calls to\nReadDir, ReadFile, and Glob appropriately.\nNote that Sub(os.DirFS("/"), "prefix") is equivalent to os.DirFS("/prefix")\nand that neither of them guarantees to avoid operating system accesses\noutside "/prefix", because the implementation of os.DirFS does not check for\nsymbolic links inside "/prefix" that point to other directories. That is,\nos.DirFS is not a general substitute for a chroot-style security mechanism,\nand Sub does not change that fact.
SubFS fs.SubFS\nA SubFS is a file system with a Sub method.\n
SubexpIndex Regexp.SubexpIndex(name string) int\n
SubexpNames Regexp.SubexpNames() []string\n
Success ProcessState.Success() bool\n
Symlink os.Symlink(oldname, newname string) error\nSymlink creates newname as a symbolic link to oldname. On Windows, a symlink\nto a non-existent oldname creates a file symlink; if oldname is later\ncreated as a directory the symlink will not work. If there is an error, it\nwill be of type *LinkError.
Sync File.Sync() error\n
SyntaxError json.SyntaxError\nA SyntaxError is a description of a JSON syntax error.\n
SyntaxError xml.SyntaxError\nA SyntaxError represents a syntax error in the XML input stream.\n
Sys ProcessState.Sys() interface{}\n
SysUsage ProcessState.SysUsage() interface{}\n
SyscallConn File.SyscallConn() (syscall.RawConn, error)\n
SyscallConn IPConn.SyscallConn() (syscall.RawConn, error)\n
SyscallConn TCPConn.SyscallConn() (syscall.RawConn, error)\n
SyscallConn TCPListener.SyscallConn() (syscall.RawConn, error)\n
SyscallConn UDPConn.SyscallConn() (syscall.RawConn, error)\n
SyscallConn UnixConn.SyscallConn() (syscall.RawConn, error)\n
SyscallConn UnixListener.SyscallConn() (syscall.RawConn, error)\n
SyscallError os.SyscallError\nSyscallError records an error from a specific system call.\n
SystemTime ProcessState.SystemTime() time.Duration\n
T testing.T\nT is a type passed to Test functions to manage test state and support\nformatted test logs.\n\nA test ends when its Test function returns or calls any of the methods\nFailNow, Fatal, Fatalf, SkipNow, Skip, or Skipf. Those methods, as well as\nthe Parallel method, must be called only from the goroutine running the Test\nfunction.\n\nThe other reporting methods, such as the variations of Log and Error, may be\ncalled simultaneously from multiple goroutines.\n
TB testing.TB\nTB is the interface common to T and B.\n
TCPAddr net.TCPAddr\nTCPAddr represents the address of a TCP end point.\n
TCPConn net.TCPConn\nTCPConn is an implementation of the Conn interface for TCP network\nconnections.\n
TCPListener net.TCPListener\nTCPListener is a TCP network listener. Clients should typically use\nvariables of type Listener instead of assuming TCP.\n
TagPathError xml.TagPathError\nA TagPathError represents an error in the unmarshaling process caused by the\nuse of field tags with conflicting paths.\n
Tan cmplx.Tan(x complex128) complex128\nTan returns the tangent of x.
Tan math.Tan(x float64) float64\nTan returns the tangent of the radian argument x.\nSpecial cases are:\nTan(±0) = ±0\nTan(±Inf) = NaN\nTan(NaN) = NaN
Tanh cmplx.Tanh(x complex128) complex128\nTanh returns the hyperbolic tangent of x.
Tanh math.Tanh(x float64) float64\nTanh returns the hyperbolic tangent of x.\nSpecial cases are:\nTanh(±0) = ±0\nTanh(±Inf) = ±1\nTanh(NaN) = NaN
TeeReader Reader.TeeReader(r Reader, w Writer) Reader\n
TeeReader io.TeeReader(r Reader, w Writer) Reader\nTeeReader returns a Reader that writes to w what it reads from r. All reads\nfrom r performed through it are matched with corresponding writes to w.\nThere is no internal buffering - the write must complete before the read\ncompletes. Any error encountered while writing is reported as a read error.
TempDir B.TempDir() string\n
TempDir T.TempDir() string\n
TempDir ioutil.TempDir(dir, pattern string) (name string, err error)\nTempDir creates a new temporary directory in the directory dir. The\ndirectory name is generated by taking pattern and applying a random string\nto the end. If pattern includes a "*", the random string replaces the last\n"*". TempDir returns the name of the new directory. If dir is the empty\nstring, TempDir uses the default directory for temporary files (see\nos.TempDir). Multiple programs calling TempDir simultaneously will not\nchoose the same directory. It is the caller's responsibility to remove the\ndirectory when no longer needed.\nAs of Go 1.17, this function simply calls os.MkdirTemp.
TempDir os.TempDir() string\nTempDir returns the default directory to use for temporary files.\nOn Unix systems, it returns $TMPDIR if non-empty, else /tmp. On Windows, it\nuses GetTempPath, returning the first non-empty value from %TMP%, %TEMP%,\n%USERPROFILE%, or the Windows directory. On Plan 9, it returns /tmp.\nThe directory is neither guaranteed to exist nor have accessible\npermissions.
TempFile ioutil.TempFile(dir, pattern string) (f *os.File, err error)\nTempFile creates a new temporary file in the directory dir, opens the file\nfor reading and writing, and returns the resulting *os.File. The filename is\ngenerated by taking pattern and adding a random string to the end. If\npattern includes a "*", the random string replaces the last "*". If dir is\nthe empty string, TempFile uses the default directory for temporary files\n(see os.TempDir). Multiple programs calling TempFile simultaneously will not\nchoose the same file. The caller can use f.Name() to find the pathname of\nthe file. It is the caller's responsibility to remove the file when no\nlonger needed.\nAs of Go 1.17, this function simply calls os.CreateTemp.
Template template.Template\nTemplate is a specialized Template from "text/template" that produces a safe\nHTML document fragment.\n
Template template.Template\nTemplate is the representation of a parsed template. The *parse.Tree field\nis exported only for use by html/template and should be treated as\nunexported by all other clients.\n
TemplateNode parse.TemplateNode\nTemplateNode represents a {{template}} action.\n
Templates Template.Templates() []*Template\n
Templates Template.Templates() []*Template\n
Temporary AddrError.Temporary() bool\n
Temporary DNSConfigError.Temporary() bool\n
Temporary DNSError.Temporary() bool\n
Temporary Error.Temporary() bool\n
Temporary OpError.Temporary() bool\n
Temporary ParseError.Temporary() bool\n
TestFS fstest.TestFS(fsys fs.FS, expected ...string) error\nTestFS tests a file system implementation. It walks the entire tree of files\nin fsys, opening and checking that each file behaves correctly. It also\nchecks that the file system contains at least the expected files. As a\nspecial case, if no expected files are listed, fsys must be empty.\nOtherwise, fsys must contain at least the listed files; it can also contain\nothers. The contents of fsys must not change concurrently with TestFS.\nIf TestFS finds any misbehaviors, it returns an error reporting all of them.\nThe error text spans multiple lines, one per detected misbehavior.\nTypical usage inside a test is:\nif err := fstest.TestFS(myFS, "file/that/should/be/present"); err != nil {\nt.Fatal(err)\n}
TestReader iotest.TestReader(r io.Reader, content []byte) error\nTestReader tests that reading from r returns the expected file content. It\ndoes reads of different sizes, until EOF. If r implements io.ReaderAt or\nio.Seeker, TestReader also checks that those operations behave as they\nshould.\nIf TestReader finds any misbehaviors, it returns an error reporting them.\nThe error text may span multiple lines.
Text Scanner.Text() string\n
TextMarshaler encoding.TextMarshaler\nTextMarshaler is the interface implemented by an object that can marshal\nitself into a textual form.\n\nMarshalText encodes the receiver into UTF-8-encoded text and returns the\nresult.\n
TextNode parse.TextNode\nTextNode holds plain text.\n
TextUnmarshaler encoding.TextUnmarshaler\nTextUnmarshaler is the interface implemented by an object that can unmarshal\na textual representation of itself.\n\nUnmarshalText must be able to decode the form generated by MarshalText.\nUnmarshalText must copy the text if it wishes to retain the text after\nreturning.\n
ThreadCreateProfile runtime.ThreadCreateProfile(p []StackRecord) (n int, ok bool)\nThreadCreateProfile returns n, the number of records in the thread creation\nprofile. If len(p) >= n, ThreadCreateProfile copies the profile into p and\nreturns n, true. If len(p) < n, ThreadCreateProfile does not change p and\nreturns n, false.\nMost clients should use the runtime/pprof package instead of calling\nThreadCreateProfile directly.
Tick time.Tick(d Duration) <-chan Time\nTick is a convenience wrapper for NewTicker providing access to the ticking\nchannel only. While Tick is useful for clients that have no need to shut\ndown the Ticker, be aware that without a way to shut it down the underlying\nTicker cannot be recovered by the garbage collector; it "leaks". Unlike\nNewTicker, Tick will return nil if d <= 0.
Ticker time.Ticker\nA Ticker holds a channel that delivers “ticks” of a clock at intervals.\n
Time time.Time\nA Time represents an instant in time with nanosecond precision.\n\nPrograms using times should typically store and pass them as values, not\npointers. That is, time variables and struct fields should be of type\ntime.Time, not *time.Time.\n\nA Time value can be used by multiple goroutines simultaneously except that\nthe methods GobDecode, UnmarshalBinary, UnmarshalJSON and UnmarshalText are\nnot concurrency-safe.\n\nTime instants can be compared using the Before, After, and Equal methods.\nThe Sub method subtracts two instants, producing a Duration. The Add method\nadds a Time and a Duration, producing a Time.\n\nThe zero value of type Time is January 1, year 1, 00:00:00.000000000 UTC. As\nthis time is unlikely to come up in practice, the IsZero method gives a\nsimple way of detecting a time that has not been initialized explicitly.\n\nEach Time has associated with it a Location, consulted when computing the\npresentation form of the time, such as in the Format, Hour, and Year\nmethods. The methods Local, UTC, and In return a Time with a specific\nlocation. Changing the location in this way changes only the presentation;\nit does not change the instant in time being denoted and therefore does not\naffect the computations described in earlier paragraphs.\n\nRepresentations of a Time value saved by the GobEncode, MarshalBinary,\nMarshalJSON, and MarshalText methods store the Time.Location's offset, but\nnot the location name. They therefore lose information about Daylight Saving\nTime.\n\nIn addition to the required “wall clock” reading, a Time may contain an\noptional reading of the current process's monotonic clock, to provide\nadditional precision for comparison or subtraction. See the “Monotonic\nClocks” section in the package documentation for details.\n\nNote that the Go == operator compares not just the time instant but also the\nLocation and the monotonic clock reading. Therefore, Time values should not\nbe used as map or database keys without first guaranteeing that the\nidentical Location has been set for all values, which can be achieved\nthrough use of the UTC or Local method, and that the monotonic clock reading\nhas been stripped by setting t = t.Round(0). In general, prefer t.Equal(u)\nto t == u, since t.Equal uses the most accurate comparison available and\ncorrectly handles the case when only one of its arguments has a monotonic\nclock reading.\n
Timeout AddrError.Timeout() bool\n
Timeout DNSConfigError.Timeout() bool\n
Timeout DNSError.Timeout() bool\n
Timeout Error.Timeout() bool\n
Timeout OpError.Timeout() bool\n
Timeout ParseError.Timeout() bool\n
Timeout PathError.Timeout() bool\n
Timeout SyscallError.Timeout() bool\n
TimeoutHandler Handler.TimeoutHandler(h Handler, dt time.Duration, msg string) Handler\n
TimeoutHandler http.TimeoutHandler(h Handler, dt time.Duration, msg string) Handler\nTimeoutHandler returns a Handler that runs h with the given time limit.\nThe new Handler calls h.ServeHTTP to handle each request, but if a call runs\nfor longer than its time limit, the handler responds with a 503 Service\nUnavailable error and the given message in its body. (If msg is empty, a\nsuitable default message will be sent.) After such a timeout, writes by h to\nits ResponseWriter will return ErrHandlerTimeout.\nTimeoutHandler supports the Pusher interface but does not support the\nHijacker or Flusher interfaces.
TimeoutReader iotest.TimeoutReader(r io.Reader) io.Reader\nTimeoutReader returns ErrTimeout on the second read with no data. Subsequent\ncalls to read succeed.
Timer time.Timer\nThe Timer type represents a single event. When the Timer expires, the\ncurrent time will be sent on C, unless the Timer was created by AfterFunc. A\nTimer must be created with NewTimer or AfterFunc.\n
Title bytes.Title(s []byte) []byte\nTitle treats s as UTF-8-encoded bytes and returns a copy with all Unicode\nletters that begin words mapped to their title case.\nBUG(rsc): The rule Title uses for word boundaries does not handle Unicode\npunctuation properly.
Title strings.Title(s string) string\nTitle returns a copy of the string s with all Unicode letters that begin\nwords mapped to their Unicode title case.\nBUG(rsc): The rule Title uses for word boundaries does not handle Unicode\npunctuation properly.
To unicode.To(_case int, r rune) rune\nTo maps the rune to the specified case: UpperCase, LowerCase, or TitleCase.
ToLower bytes.ToLower(s []byte) []byte\nToLower returns a copy of the byte slice s with all Unicode letters mapped\nto their lower case.
ToLower strings.ToLower(s string) string\nToLower returns s with all Unicode letters mapped to their lower case.
ToLower unicode.ToLower(r rune) rune\nToLower maps the rune to lower case.
ToLowerSpecial bytes.ToLowerSpecial(c unicode.SpecialCase, s []byte) []byte\nToLowerSpecial treats s as UTF-8-encoded bytes and returns a copy with all\nthe Unicode letters mapped to their lower case, giving priority to the\nspecial casing rules.
ToLowerSpecial strings.ToLowerSpecial(c unicode.SpecialCase, s string) string\nToLowerSpecial returns a copy of the string s with all Unicode letters\nmapped to their lower case using the case mapping specified by c.
ToSlash filepath.ToSlash(path string) string\nToSlash returns the result of replacing each separator character in path\nwith a slash ('/') character. Multiple separators are replaced by multiple\nslashes.
ToTitle bytes.ToTitle(s []byte) []byte\nToTitle treats s as UTF-8-encoded bytes and returns a copy with all the\nUnicode letters mapped to their title case.
ToTitle strings.ToTitle(s string) string\nToTitle returns a copy of the string s with all Unicode letters mapped to\ntheir Unicode title case.
ToTitle unicode.ToTitle(r rune) rune\nToTitle maps the rune to title case.
ToTitleSpecial bytes.ToTitleSpecial(c unicode.SpecialCase, s []byte) []byte\nToTitleSpecial treats s as UTF-8-encoded bytes and returns a copy with all\nthe Unicode letters mapped to their title case, giving priority to the\nspecial casing rules.
ToTitleSpecial strings.ToTitleSpecial(c unicode.SpecialCase, s string) string\nToTitleSpecial returns a copy of the string s with all Unicode letters\nmapped to their Unicode title case, giving priority to the special casing\nrules.
ToUpper bytes.ToUpper(s []byte) []byte\nToUpper returns a copy of the byte slice s with all Unicode letters mapped\nto their upper case.
ToUpper strings.ToUpper(s string) string\nToUpper returns s with all Unicode letters mapped to their upper case.
ToUpper unicode.ToUpper(r rune) rune\nToUpper maps the rune to upper case.
ToUpperSpecial bytes.ToUpperSpecial(c unicode.SpecialCase, s []byte) []byte\nToUpperSpecial treats s as UTF-8-encoded bytes and returns a copy with all\nthe Unicode letters mapped to their upper case, giving priority to the\nspecial casing rules.
ToUpperSpecial strings.ToUpperSpecial(c unicode.SpecialCase, s string) string\nToUpperSpecial returns a copy of the string s with all Unicode letters\nmapped to their upper case using the case mapping specified by c.
ToValidUTF8 bytes.ToValidUTF8(s, replacement []byte) []byte\nToValidUTF8 treats s as UTF-8-encoded bytes and returns a copy with each run\nof bytes representing invalid UTF-8 replaced with the bytes in replacement,\nwhich may be empty.
ToValidUTF8 strings.ToValidUTF8(s, replacement string) string\nToValidUTF8 returns a copy of the string s with each run of invalid UTF-8\nbyte sequences replaced by the replacement string, which may be empty.
Token Decoder.Token() (Token, error)\n
Token Decoder.Token() (Token, error)\n
Token json.Token\n
Token xml.Token\n
TokenReader xml.TokenReader\nA TokenReader is anything that can decode a stream of XML tokens, including\na Decoder.\n\nWhen Token encounters an error or end-of-file condition after successfully\nreading a token, it returns the token. It may return the (non-nil) error\nfrom the same call or return the error (and a nil token) from a subsequent\ncall. An instance of this general case is that a TokenReader returning a\nnon-nil token at the end of the token stream may return either io.EOF or a\nnil error. The next Read should return nil, io.EOF.\n\nImplementations of Token are discouraged from returning a nil token with a\nnil error. Callers should treat a return of nil, nil as indicating that\nnothing happened; in particular it does not indicate EOF.\n
TokenString scanner.TokenString(tok rune) string\nTokenString returns a printable string for a token or Unicode character.
TokenText Scanner.TokenText() string\n
Transport http.Transport\nTransport is an implementation of RoundTripper that supports HTTP, HTTPS,\nand HTTP proxies (for either HTTP or HTTPS with CONNECT).\n\nBy default, Transport caches connections for future re-use. This may leave\nmany open connections when accessing many hosts. This behavior can be\nmanaged using Transport's CloseIdleConnections method and the\nMaxIdleConnsPerHost and DisableKeepAlives fields.\n\nTransports should be reused instead of created as needed. Transports are\nsafe for concurrent use by multiple goroutines.\n\nA Transport is a low-level primitive for making HTTP and HTTPS requests. For\nhigh-level functionality, such as cookies and redirects, see Client.\n\nTransport uses HTTP/1.1 for HTTP URLs and either HTTP/1.1 or HTTP/2 for\nHTTPS URLs, depending on whether the server supports HTTP/2, and how the\nTransport is configured. The DefaultTransport supports HTTP/2. To explicitly\nenable HTTP/2 on a transport, use golang.org/x/net/http2 and call\nConfigureTransport. See the package docs for more about HTTP/2.\n\nResponses with status codes in the 1xx range are either handled\nautomatically (100 expect-continue) or ignored. The one exception is HTTP\nstatus code 101 (Switching Protocols), which is considered a terminal status\nand returned by RoundTrip. To see the ignored 1xx responses, use the\nhttptrace trace package's ClientTrace.Got1xxResponse.\n\nTransport only retries a request upon encountering a network error if the\nrequest is idempotent and either has no body or has its Request.GetBody\ndefined. HTTP requests are considered idempotent if they have HTTP methods\nGET, HEAD, OPTIONS, or TRACE; or if their Header map contains an\n"Idempotency-Key" or "X-Idempotency-Key" entry. If the idempotency key value\nis a zero-length slice, the request is treated as idempotent but the header\nis not sent on the wire.\n
Tree parse.Tree\nTree is the representation of a single parsed template.\n
Trim bytes.Trim(s []byte, cutset string) []byte\nTrim returns a subslice of s by slicing off all leading and trailing\nUTF-8-encoded code points contained in cutset.
Trim strings.Trim(s, cutset string) string\nTrim returns a slice of the string s with all leading and trailing Unicode\ncode points contained in cutset removed.
TrimFunc bytes.TrimFunc(s []byte, f func(r rune) bool) []byte\nTrimFunc returns a subslice of s by slicing off all leading and trailing\nUTF-8-encoded code points c that satisfy f(c).
TrimFunc strings.TrimFunc(s string, f func(rune) bool) string\nTrimFunc returns a slice of the string s with all leading and trailing\nUnicode code points c satisfying f(c) removed.
TrimLeft bytes.TrimLeft(s []byte, cutset string) []byte\nTrimLeft returns a subslice of s by slicing off all leading UTF-8-encoded\ncode points contained in cutset.
TrimLeft strings.TrimLeft(s, cutset string) string\nTrimLeft returns a slice of the string s with all leading Unicode code\npoints contained in cutset removed.\nTo remove a prefix, use TrimPrefix instead.
TrimLeftFunc bytes.TrimLeftFunc(s []byte, f func(r rune) bool) []byte\nTrimLeftFunc treats s as UTF-8-encoded bytes and returns a subslice of s by\nslicing off all leading UTF-8-encoded code points c that satisfy f(c).
TrimLeftFunc strings.TrimLeftFunc(s string, f func(rune) bool) string\nTrimLeftFunc returns a slice of the string s with all leading Unicode code\npoints c satisfying f(c) removed.
TrimPrefix bytes.TrimPrefix(s, prefix []byte) []byte\nTrimPrefix returns s without the provided leading prefix string. If s\ndoesn't start with prefix, s is returned unchanged.
TrimPrefix strings.TrimPrefix(s, prefix string) string\nTrimPrefix returns s without the provided leading prefix string. If s\ndoesn't start with prefix, s is returned unchanged.
TrimRight bytes.TrimRight(s []byte, cutset string) []byte\nTrimRight returns a subslice of s by slicing off all trailing UTF-8-encoded\ncode points that are contained in cutset.
TrimRight strings.TrimRight(s, cutset string) string\nTrimRight returns a slice of the string s, with all trailing Unicode code\npoints contained in cutset removed.\nTo remove a suffix, use TrimSuffix instead.
TrimRightFunc bytes.TrimRightFunc(s []byte, f func(r rune) bool) []byte\nTrimRightFunc returns a subslice of s by slicing off all trailing\nUTF-8-encoded code points c that satisfy f(c).
TrimRightFunc strings.TrimRightFunc(s string, f func(rune) bool) string\nTrimRightFunc returns a slice of the string s with all trailing Unicode code\npoints c satisfying f(c) removed.
TrimSpace bytes.TrimSpace(s []byte) []byte\nTrimSpace returns a subslice of s by slicing off all leading and trailing\nwhite space, as defined by Unicode.
TrimSpace strings.TrimSpace(s string) string\nTrimSpace returns a slice of the string s, with all leading and trailing\nwhite space removed, as defined by Unicode.
TrimSuffix bytes.TrimSuffix(s, suffix []byte) []byte\nTrimSuffix returns s without the provided trailing suffix string. If s\ndoesn't end with suffix, s is returned unchanged.
TrimSuffix strings.TrimSuffix(s, suffix string) string\nTrimSuffix returns s without the provided trailing suffix string. If s\ndoesn't end with suffix, s is returned unchanged.
Trunc math.Trunc(x float64) float64\nTrunc returns the integer value of x.\nSpecial cases are:\nTrunc(±0) = ±0\nTrunc(±Inf) = ±Inf\nTrunc(NaN) = NaN
Truncate Buffer.Truncate(n int)\n
Truncate File.Truncate(size int64) error\n
Truncate Time.Truncate(d Duration) Time\n
Truncate os.Truncate(name string, size int64) error\nTruncate changes the size of the named file. If the file is a symbolic link,\nit changes the size of the link's target. If there is an error, it will be\nof type *PathError.
TruncateWriter iotest.TruncateWriter(w io.Writer, n int64) io.Writer\nTruncateWriter returns a Writer that writes to w but stops silently after n\nbytes.
Type DotNode.Type() NodeType\n
Type NilNode.Type() NodeType\n
TypeAssertionError runtime.TypeAssertionError\nA TypeAssertionError explains a failed type assertion.\n
UDPAddr net.UDPAddr\nUDPAddr represents the address of a UDP end point.\n
UDPConn net.UDPConn\nUDPConn is the implementation of the Conn and PacketConn interfaces for UDP\nnetwork connections.\n
URL url.URL\nA URL represents a parsed URL (technically, a URI reference).\n\nThe general form represented is:\n\n[scheme:][//[userinfo@]host][/]path[?query][#fragment]\n\nURLs that do not start with a slash after the scheme are interpreted as:\n\nscheme:opaque[?query][#fragment]\n\nNote that the Path field is stored in decoded form: /%47%6f%2f becomes /Go/.\nA consequence is that it is impossible to tell which slashes in the Path\nwere slashes in the raw URL and which were %2f. This distinction is rarely\nimportant, but when it is, the code should use RawPath, an optional field\nwhich only gets set if the default encoding is different from Path.\n\nURL's String method uses the EscapedPath method to obtain the path. See the\nEscapedPath method for more details.\n
URLQueryEscaper template.URLQueryEscaper(args ...interface{}) string\nURLQueryEscaper returns the escaped value of the textual representation of\nits arguments in a form suitable for embedding in a URL query.
URLQueryEscaper template.URLQueryEscaper(args ...interface{}) string\nURLQueryEscaper returns the escaped value of the textual representation of\nits arguments in a form suitable for embedding in a URL query.
UTC Time.UTC() Time\n
Uint FlagSet.Uint(name string, value uint, usage string) *uint\n
Uint flag.Uint(name string, value uint, usage string) *uint\nUint defines a uint flag with specified name, default value, and usage\nstring. The return value is the address of a uint variable that stores the\nvalue of the flag.
Uint32 Rand.Uint32() uint32\n
Uint32 rand.Uint32() uint32\nUint32 returns a pseudo-random 32-bit value as a uint32 from the default\nSource.
Uint64 FlagSet.Uint64(name string, value uint64, usage string) *uint64\n
Uint64 Rand.Uint64() uint64\n
Uint64 Zipf.Uint64() uint64\n
Uint64 flag.Uint64(name string, value uint64, usage string) *uint64\nUint64 defines a uint64 flag with specified name, default value, and usage\nstring. The return value is the address of a uint64 variable that stores the\nvalue of the flag.
Uint64 rand.Uint64() uint64\nUint64 returns a pseudo-random 64-bit value as a uint64 from the default\nSource.
Uint64Var FlagSet.Uint64Var(p *uint64, name string, value uint64, usage string)\n
Uint64Var flag.Uint64Var(p *uint64, name string, value uint64, usage string)\nUint64Var defines a uint64 flag with specified name, default value, and\nusage string. The argument p points to a uint64 variable in which to store\nthe value of the flag.
UintVar FlagSet.UintVar(p *uint, name string, value uint, usage string)\n
UintVar flag.UintVar(p *uint, name string, value uint, usage string)\nUintVar defines a uint flag with specified name, default value, and usage\nstring. The argument p points to a uint variable in which to store the value\nof the flag.
UnescapeString html.UnescapeString(s string) string\nUnescapeString unescapes entities like "&lt;" to become "<". It unescapes a\nlarger range of entities than EscapeString escapes. For example, "&aacute;"\nunescapes to "á", as does "&#225;" and "&#xE1;".\nUnescapeString(EscapeString(s)) == s always holds, but the converse isn't\nalways true.
Unix Time.Unix() int64\n
Unix Time.Unix(sec int64, nsec int64) Time\n
Unix time.Unix(sec int64, nsec int64) Time\nUnix returns the local Time corresponding to the given Unix time, sec\nseconds and nsec nanoseconds since January 1, 1970 UTC. It is valid to pass\nnsec outside the range [0, 999999999]. Not all sec values have a\ncorresponding time value. One such value is 1<<63-1 (the largest int64\nvalue).
UnixAddr net.UnixAddr\nUnixAddr represents the address of a Unix domain socket end point.\n
UnixConn net.UnixConn\nUnixConn is an implementation of the Conn interface for connections to Unix\ndomain sockets.\n
UnixListener net.UnixListener\nUnixListener is a Unix domain socket listener. Clients should typically use\nvariables of type Listener instead of assuming Unix domain sockets.\n
UnixMicro Time.UnixMicro() int64\n
UnixMicro Time.UnixMicro(usec int64) Time\n
UnixMicro time.UnixMicro(usec int64) Time\nUnixMicro returns the local Time corresponding to the given Unix time, usec\nmicroseconds since January 1, 1970 UTC.
UnixMilli Time.UnixMilli() int64\n
UnixMilli Time.UnixMilli(msec int64) Time\n
UnixMilli time.UnixMilli(msec int64) Time\nUnixMilli returns the local Time corresponding to the given Unix time, msec\nmilliseconds since January 1, 1970 UTC.
UnixNano Time.UnixNano() int64\n
Unlock Mutex.Unlock()\n
Unlock RWMutex.Unlock()\n
UnlockOSThread runtime.UnlockOSThread()\nUnlockOSThread undoes an earlier call to LockOSThread. If this drops the\nnumber of active LockOSThread calls on the calling goroutine to zero, it\nunwires the calling goroutine from its fixed operating system thread. If\nthere are no active LockOSThread calls, this is a no-op.\nBefore calling UnlockOSThread, the caller must ensure that the OS thread is\nsuitable for running other goroutines. If the caller made any permanent\nchanges to the state of the thread that would affect other goroutines, it\nshould not call this function and thus leave the goroutine locked to the OS\nthread until the goroutine (and hence the thread) exits.
Unmarshal json.Unmarshal(data []byte, v interface{}) error\nUnmarshal parses the JSON-encoded data and stores the result in the value\npointed to by v. If v is nil or not a pointer, Unmarshal returns an\nInvalidUnmarshalError.\nUnmarshal uses the inverse of the encodings that Marshal uses, allocating\nmaps, slices, and pointers as necessary, with the following additional\nrules:\nTo unmarshal JSON into a pointer, Unmarshal first handles the case of the\nJSON being the JSON literal null. In that case, Unmarshal sets the pointer\nto nil. Otherwise, Unmarshal unmarshals the JSON into the value pointed at\nby the pointer. If the pointer is nil, Unmarshal allocates a new value for\nit to point to.\nTo unmarshal JSON into a value implementing the Unmarshaler interface,\nUnmarshal calls that value's UnmarshalJSON method, including when the input\nis a JSON null. Otherwise, if the value implements encoding.TextUnmarshaler\nand the input is a JSON quoted string, Unmarshal calls that value's\nUnmarshalText method with the unquoted form of the string.\nTo unmarshal JSON into a struct, Unmarshal matches incoming object keys to\nthe keys used by Marshal (either the struct field name or its tag),\npreferring an exact match but also accepting a case-insensitive match. By\ndefault, object keys which don't have a corresponding struct field are\nignored (see Decoder.DisallowUnknownFields for an alternative).\nTo unmarshal JSON into an interface value, Unmarshal stores one of these in\nthe interface value:\nbool, for JSON booleans\nfloat64, for JSON numbers\nstring, for JSON strings\n[]interface{}, for JSON arrays\nmap[string]interface{}, for JSON objects\nnil for JSON null\nTo unmarshal a JSON array into a slice, Unmarshal resets the slice length to\nzero and then appends each element to the slice. As a special case, to\nunmarshal an empty JSON array into a slice, Unmarshal replaces the slice\nwith a new empty slice.\nTo unmarshal a JSON array into a Go array, Unmarshal decodes JSON array\nelements into corresponding Go array elements. If the Go array is smaller\nthan the JSON array, the additional JSON array elements are discarded. If\nthe JSON array is smaller than the Go array, the additional Go array\nelements are set to zero values.\nTo unmarshal a JSON object into a map, Unmarshal first establishes a map to\nuse. If the map is nil, Unmarshal allocates a new map. Otherwise Unmarshal\nreuses the existing map, keeping existing entries. Unmarshal then stores\nkey-value pairs from the JSON object into the map. The map's key type must\neither be any string type, an integer, implement json.Unmarshaler, or\nimplement encoding.TextUnmarshaler.\nIf a JSON value is not appropriate for a given target type, or if a JSON\nnumber overflows the target type, Unmarshal skips that field and completes\nthe unmarshaling as best it can. If no more serious errors are encountered,\nUnmarshal returns an UnmarshalTypeError describing the earliest such error.\nIn any case, it's not guaranteed that all the remaining fields following the\nproblematic one will be unmarshaled into the target object.\nThe JSON null value unmarshals into an interface, map, pointer, or slice by\nsetting that Go value to nil. Because null is often used in JSON to mean\n“not present,” unmarshaling a JSON null into any other Go type has no effect\non the value and produces no error.\nWhen unmarshaling quoted strings, invalid UTF-8 or invalid UTF-16 surrogate\npairs are not treated as an error. Instead, they are replaced by the Unicode\nreplacement character U+FFFD.
Unmarshal xml.Unmarshal(data []byte, v interface{}) error\nUnmarshal parses the XML-encoded data and stores the result in the value\npointed to by v, which must be an arbitrary struct, slice, or string.\nWell-formed data that does not fit into v is discarded.\nBecause Unmarshal uses the reflect package, it can only assign to exported\n(upper case) fields. Unmarshal uses a case-sensitive comparison to match XML\nelement names to tag values and struct field names.\nUnmarshal maps an XML element to a struct using the following rules. In the\nrules, the tag of a field refers to the value associated with the key 'xml'\nin the struct field's tag (see the example above).\n* If the struct has a field of type []byte or string with tag\n",innerxml", Unmarshal accumulates the raw XML nested inside the\nelement in that field. The rest of the rules still apply.\n* If the struct has a field named XMLName of type Name,\nUnmarshal records the element name in that field.\n* If the XMLName field has an associated tag of the form\n"name" or "namespace-URL name", the XML element must have\nthe given name (and, optionally, name space) or else Unmarshal\nreturns an error.\n* If the XML element has an attribute whose name matches a\nstruct field name with an associated tag containing ",attr" or\nthe explicit name in a struct field tag of the form "name,attr",\nUnmarshal records the attribute value in that field.\n* If the XML element has an attribute not handled by the previous\nrule and the struct has a field with an associated tag containing\n",any,attr", Unmarshal records the attribute value in the first\nsuch field.\n* If the XML element contains character data, that data is\naccumulated in the first struct field that has tag ",chardata".\nThe struct field may have type []byte or string.\nIf there is no such field, the character data is discarded.\n* If the XML element contains comments, they are accumulated in\nthe first struct field that has tag ",comment".  The struct\nfield may have type []byte or string. If there is no such\nfield, the comments are discarded.\n* If the XML element contains a sub-element whose name matches\nthe prefix of a tag formatted as "a" or "a>b>c", unmarshal\nwill descend into the XML structure looking for elements with the\ngiven names, and will map the innermost elements to that struct\nfield. A tag starting with ">" is equivalent to one starting\nwith the field name followed by ">".\n* If the XML element contains a sub-element whose name matches\na struct field's XMLName tag and the struct field has no\nexplicit name tag as per the previous rule, unmarshal maps\nthe sub-element to that struct field.\n* If the XML element contains a sub-element whose name matches a\nfield without any mode flags (",attr", ",chardata", etc), Unmarshal\nmaps the sub-element to that struct field.\n* If the XML element contains a sub-element that hasn't matched any\nof the above rules and the struct has a field with tag ",any",\nunmarshal maps the sub-element to that struct field.\n* An anonymous struct field is handled as if the fields of its\nvalue were part of the outer struct.\n* A struct field with tag "-" is never unmarshaled into.\nIf Unmarshal encounters a field type that implements the Unmarshaler\ninterface, Unmarshal calls its UnmarshalXML method to produce the value from\nthe XML element. Otherwise, if the value implements\nencoding.TextUnmarshaler, Unmarshal calls that value's UnmarshalText method.\nUnmarshal maps an XML element to a string or []byte by saving the\nconcatenation of that element's character data in the string or []byte. The\nsaved []byte is never nil.\nUnmarshal maps an attribute value to a string or []byte by saving the value\nin the string or slice.\nUnmarshal maps an attribute value to an Attr by saving the attribute,\nincluding its name, in the Attr.\nUnmarshal maps an XML element or attribute value to a slice by extending the\nlength of the slice and mapping the element or attribute to the newly\ncreated value.\nUnmarshal maps an XML element or attribute value to a bool by setting it to\nthe boolean value represented by the string. Whitespace is trimmed and\nignored.\nUnmarshal maps an XML element or attribute value to an integer or\nfloating-point field by setting the field to the result of interpreting the\nstring value in decimal. There is no check for overflow. Whitespace is\ntrimmed and ignored.\nUnmarshal maps an XML element to a Name by recording the element name.\nUnmarshal maps an XML element to a pointer by setting the pointer to a\nfreshly allocated value and then mapping the element to that value.\nA missing element or empty attribute value will be unmarshaled as a zero\nvalue. If the field is a slice, a zero value will be appended to the field.\nOtherwise, the field will be set to its zero value.
UnmarshalBinary Time.UnmarshalBinary(data []byte) error\n
UnmarshalBinary URL.UnmarshalBinary(text []byte) error\n
UnmarshalFieldError json.UnmarshalFieldError\nAn UnmarshalFieldError describes a JSON object key that led to an unexported\n(and therefore unwritable) struct field.\n\nDeprecated: No longer used; kept for compatibility.\n
UnmarshalJSON Time.UnmarshalJSON(data []byte) error\n
UnmarshalText Time.UnmarshalText(data []byte) error\n
UnmarshalTypeError json.UnmarshalTypeError\nAn UnmarshalTypeError describes a JSON value that was not appropriate for a\nvalue of a specific Go type.\n
Unmarshaler json.Unmarshaler\nUnmarshaler is the interface implemented by types that can unmarshal a JSON\ndescription of themselves. The input can be assumed to be a valid encoding\nof a JSON value. UnmarshalJSON must copy the JSON data if it wishes to\nretain the data after returning.\n\nBy convention, to approximate the behavior of Unmarshal itself, Unmarshalers\nimplement UnmarshalJSON([]byte("null")) as a no-op.\n
Unmarshaler xml.Unmarshaler\nUnmarshaler is the interface implemented by objects that can unmarshal an\nXML element description of themselves.\n\nUnmarshalXML decodes a single XML element beginning with the given start\nelement. If it returns an error, the outer call to Unmarshal stops and\nreturns that error. UnmarshalXML must consume exactly one XML element. One\ncommon implementation strategy is to unmarshal into a separate value with a\nlayout matching the expected XML using d.DecodeElement, and then to copy the\ndata from that value into the receiver. Another common strategy is to use\nd.Token to process the XML object one token at a time. UnmarshalXML may not\nuse d.RawToken.\n
UnmarshalerAttr xml.UnmarshalerAttr\nUnmarshalerAttr is the interface implemented by objects that can unmarshal\nan XML attribute description of themselves.\n\nUnmarshalXMLAttr decodes a single XML attribute. If it returns an error, the\nouter call to Unmarshal stops and returns that error. UnmarshalXMLAttr is\nused only for struct fields with the "attr" option in the field tag.\n
Unquote strconv.Unquote(s string) (string, error)\nUnquote interprets s as a single-quoted, double-quoted, or backquoted Go\nstring literal, returning the string value that s quotes. (If s is\nsingle-quoted, it would be a Go character literal; Unquote returns the\ncorresponding one-character string.)
UnquoteChar strconv.UnquoteChar(s string, quote byte) (value rune, multibyte bool, tail string, err error)\nUnquoteChar decodes the first character or byte in the escaped string or\ncharacter literal represented by the string s. It returns four values:\n1) value, the decoded Unicode code point or byte value;\n2) multibyte, a boolean indicating whether the decoded character requires a multibyte UTF-8 representation;\n3) tail, the remainder of the string after the character; and\n4) an error that will be nil if the character is syntactically valid.\nThe second argument, quote, specifies the type of literal being parsed and\ntherefore which escaped quote character is permitted. If set to a single\nquote, it permits the sequence \' and disallows unescaped '. If set to a\ndouble quote, it permits \" and disallows unescaped ". If set to zero, it\ndoes not permit either escape and allows both quote characters to appear\nunescaped.
UnquoteUsage flag.UnquoteUsage(flag *Flag) (name string, usage string)\nUnquoteUsage extracts a back-quoted name from the usage string for a flag\nand returns it and the un-quoted usage. Given "a `name` to show" it returns\n("name", "a name to show"). If there are no back quotes, the name is an\neducated guess of the type of the flag's value, or the empty string if the\nflag is boolean.
UnreadByte Buffer.UnreadByte() error\n
UnreadByte Reader.UnreadByte() error\n
UnreadByte Reader.UnreadByte() error\n
UnreadByte Reader.UnreadByte() error\n
UnreadRune Buffer.UnreadRune() error\n
UnreadRune Reader.UnreadRune() error\n
UnreadRune Reader.UnreadRune() error\n
UnreadRune Reader.UnreadRune() error\n
Unsetenv os.Unsetenv(key string) error\nUnsetenv unsets a single environment variable.
UnsupportedTypeError json.UnsupportedTypeError\nAn UnsupportedTypeError is returned by Marshal when attempting to encode an\nunsupported value type.\n
UnsupportedTypeError xml.UnsupportedTypeError\nUnsupportedTypeError is returned when Marshal encounters a type that cannot\nbe converted into XML.\n
UnsupportedValueError json.UnsupportedValueError\nAn UnsupportedValueError is returned by Marshal when attempting to encode an\nunsupported value.\n
Until time.Until(t Time) Duration\nUntil returns the duration until t. It is shorthand for t.Sub(time.Now()).
Unwrap DNSConfigError.Unwrap() error\n
Unwrap Error.Unwrap() error\n
Unwrap Error.Unwrap() error\n
Unwrap ExecError.Unwrap() error\n
Unwrap LinkError.Unwrap() error\n
Unwrap MarshalerError.Unwrap() error\n
Unwrap NumError.Unwrap() error\n
Unwrap OpError.Unwrap() error\n
Unwrap ParseError.Unwrap() error\n
Unwrap PathError.Unwrap() error\n
Unwrap SyscallError.Unwrap() error\n
Unwrap errors.Unwrap(err error) error\nUnwrap returns the result of calling the Unwrap method on err, if err's type\ncontains an Unwrap method returning error. Otherwise, Unwrap returns nil.
UseNumber Decoder.UseNumber()\n
User Userinfo.User(username string) *Userinfo\n
User url.User(username string) *Userinfo\nUser returns a Userinfo containing the provided username and no password\nset.
UserAgent Request.UserAgent() string\n
UserCacheDir os.UserCacheDir() (string, error)\nUserCacheDir returns the default root directory to use for user-specific\ncached data. Users should create their own application-specific subdirectory\nwithin this one and use that.\nOn Unix systems, it returns $XDG_CACHE_HOME as specified by\nhttps://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html\nif non-empty, else $HOME/.cache. On Darwin, it returns $HOME/Library/Caches.\nOn Windows, it returns %LocalAppData%. On Plan 9, it returns\n$home/lib/cache.\nIf the location cannot be determined (for example, $HOME is not defined),\nthen it will return an error.
UserConfigDir os.UserConfigDir() (string, error)\nUserConfigDir returns the default root directory to use for user-specific\nconfiguration data. Users should create their own application-specific\nsubdirectory within this one and use that.\nOn Unix systems, it returns $XDG_CONFIG_HOME as specified by\nhttps://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html\nif non-empty, else $HOME/.config. On Darwin, it returns\n$HOME/Library/Application Support. On Windows, it returns %AppData%. On Plan\n9, it returns $home/lib.\nIf the location cannot be determined (for example, $HOME is not defined),\nthen it will return an error.
UserHomeDir os.UserHomeDir() (string, error)\nUserHomeDir returns the current user's home directory.\nOn Unix, including macOS, it returns the $HOME environment variable. On\nWindows, it returns %USERPROFILE%. On Plan 9, it returns the $home\nenvironment variable.
UserPassword Userinfo.UserPassword(username, password string) *Userinfo\n
UserPassword url.UserPassword(username, password string) *Userinfo\nUserPassword returns a Userinfo containing the provided username and\npassword.\nThis functionality should only be used with legacy web sites. RFC 2396 warns\nthat interpreting Userinfo this way “is NOT RECOMMENDED, because the passing\nof authentication information in clear text (such as URI) has proven to be a\nsecurity risk in almost every case where it has been used.”
UserTime ProcessState.UserTime() time.Duration\n
Userinfo url.Userinfo\nThe Userinfo type is an immutable encapsulation of username and password\ndetails for a URL. An existing Userinfo value is guaranteed to have a\nusername set (potentially empty, as allowed by RFC 2396), and optionally a\npassword.\n
Username Userinfo.Username() string\n
Uvarint binary.Uvarint(buf []byte) (uint64, int)\nUvarint decodes a uint64 from buf and returns that value and the number of\nbytes read (> 0). If an error occurred, the value is 0 and the number of\nbytes n is <= 0 meaning:\nn == 0: buf too small\nn  < 0: value larger than 64 bits (overflow)\nand -n is the number of bytes read
Valid json.Valid(data []byte) bool\nValid reports whether data is a valid JSON encoding.
Valid utf8.Valid(p []byte) bool\nValid reports whether p consists entirely of valid UTF-8-encoded runes.
ValidPath fs.ValidPath(name string) bool\nValidPath reports whether the given path name is valid for use in a call to\nOpen.\nPath names passed to open are UTF-8-encoded, unrooted, slash-separated\nsequences of path elements, like “x/y/z”. Path names must not contain an\nelement that is “.” or “..” or the empty string, except for the special case\nthat the root directory is named “.”. Paths must not start or end with a\nslash: “/x” and “x/” are invalid.\nNote that paths are slash-separated on all systems, even Windows. Paths\ncontaining other characters such as backslash and colon are accepted as\nvalid, but those characters must never be interpreted by an FS\nimplementation as path element separators.
ValidRune utf8.ValidRune(r rune) bool\nValidRune reports whether r can be legally encoded as UTF-8. Code points\nthat are out of range or a surrogate half are illegal.
ValidString utf8.ValidString(s string) bool\nValidString reports whether s consists entirely of valid UTF-8-encoded\nrunes.
Value flag.Value\nValue is the interface to the dynamic value stored in a flag. (The default\nvalue is represented as a string.)\n\nIf a Value has an IsBoolFlag() bool method returning true, the command-line\nparser makes -name equivalent to -name=true rather than using the next\ncommand-line argument.\n\nSet is called once, in command line order, for each flag present. The flag\npackage may call the String method with a zero-valued receiver, such as a\nnil pointer.\n
Value quick.Value(t reflect.Type, rand *rand.Rand) (value reflect.Value, ok bool)\nValue returns an arbitrary value of the given type. If the type implements\nthe Generator interface, that will be used. Note: To create arbitrary values\nfor structs, all the fields must be exported.
Var FlagSet.Var(value Value, name string, usage string)\n
Var flag.Var(value Value, name string, usage string)\nVar defines a flag with the specified name and usage string. The type and\nvalue of the flag are represented by the first argument, of type Value,\nwhich typically holds a user-defined implementation of Value. For instance,\nthe caller could create a flag that turns a comma-separated string into a\nslice of strings by giving the slice the methods of Value; in particular,\nSet would decompose the comma-separated string into the slice.
VariableNode parse.VariableNode\nVariableNode holds a list of variable names, possibly with chained field\naccesses. The dollar sign is part of the (first) name.\n
Varint binary.Varint(buf []byte) (int64, int)\nVarint decodes an int64 from buf and returns that value and the number of\nbytes read (> 0). If an error occurred, the value is 0 and the number of\nbytes n is <= 0 with the following meaning:\nn == 0: buf too small\nn  < 0: value larger than 64 bits (overflow)\nand -n is the number of bytes read
Verbose testing.Verbose() bool\nVerbose reports whether the -test.v flag is set.
Version runtime.Version() string\nVersion returns the Go tree's version string. It is either the commit hash\nand date at the time of the build or, when possible, a release tag like\n"go1.3".
Visit FlagSet.Visit(fn func(*Flag))\n
Visit flag.Visit(fn func(*Flag))\nVisit visits the command-line flags in lexicographical order, calling fn for\neach. It visits only those flags that have been set.
VisitAll FlagSet.VisitAll(fn func(*Flag))\n
VisitAll flag.VisitAll(fn func(*Flag))\nVisitAll visits the command-line flags in lexicographical order, calling fn\nfor each. It visits all flags, even those not set.
VolumeName filepath.VolumeName(path string) string\nVolumeName returns leading volume name. Given "C:\foo\bar" it returns "C:"\non Windows. Given "\\host\share\foo" it returns "\\host\share". On other\nplatforms it returns "".
Wait Cmd.Wait() error\n
Wait Cond.Wait()\n
Wait Process.Wait() (*ProcessState, error)\n
Wait WaitGroup.Wait()\n
WaitGroup sync.WaitGroup\nA WaitGroup waits for a collection of goroutines to finish. The main\ngoroutine calls Add to set the number of goroutines to wait for. Then each\nof the goroutines runs and calls Done when finished. At the same time, Wait\ncan be used to block until all goroutines have finished.\n\nA WaitGroup must not be copied after first use.\n
Walk filepath.Walk(root string, fn WalkFunc) error\nWalk walks the file tree rooted at root, calling fn for each file or\ndirectory in the tree, including root.\nAll errors that arise visiting files and directories are filtered by fn: see\nthe WalkFunc documentation for details.\nThe files are walked in lexical order, which makes the output deterministic\nbut requires Walk to read an entire directory into memory before proceeding\nto walk that directory.\nWalk does not follow symbolic links.\nWalk is less efficient than WalkDir, introduced in Go 1.16, which avoids\ncalling os.Lstat on every visited file or directory.
WalkDir filepath.WalkDir(root string, fn fs.WalkDirFunc) error\nWalkDir walks the file tree rooted at root, calling fn for each file or\ndirectory in the tree, including root.\nAll errors that arise visiting files and directories are filtered by fn: see\nthe fs.WalkDirFunc documentation for details.\nThe files are walked in lexical order, which makes the output deterministic\nbut requires WalkDir to read an entire directory into memory before\nproceeding to walk that directory.\nWalkDir does not follow symbolic links.
WalkDir fs.WalkDir(fsys FS, root string, fn WalkDirFunc) error\nWalkDir walks the file tree rooted at root, calling fn for each file or\ndirectory in the tree, including root.\nAll errors that arise visiting files and directories are filtered by fn: see\nthe fs.WalkDirFunc documentation for details.\nThe files are walked in lexical order, which makes the output deterministic\nbut requires WalkDir to read an entire directory into memory before\nproceeding to walk that directory.\nWalkDir does not follow symbolic links found in directories, but if root\nitself is a symbolic link, its target will be walked.
Weekday Time.Weekday() Weekday\n
WithContext Request.WithContext(ctx context.Context) *Request\n
WithNode parse.WithNode\nWithNode represents a {{with}} action and its commands.\n
WithPadding Encoding.WithPadding(padding rune) *Encoding\n
WithPadding Encoding.WithPadding(padding rune) *Encoding\n
Write Buffer.Write(p []byte) (n int, err error)\n
Write Builder.Write(p []byte) (int, error)\n
Write File.Write(b []byte) (n int, err error)\n
Write IPConn.Write(b []byte) (int, error)\n
Write PipeWriter.Write(data []byte) (n int, err error)\n
Write Request.Write(w io.Writer) error\n
Write Response.Write(w io.Writer) error\n
Write TCPConn.Write(b []byte) (int, error)\n
Write UDPConn.Write(b []byte) (int, error)\n
Write UnixConn.Write(b []byte) (int, error)\n
Write Writer.Write(p []byte) (nn int, err error)\n
Write Writer.Write(record []string) error\n
Write binary.Write(w io.Writer, order ByteOrder, data interface{}) error\nWrite writes the binary representation of data into w. Data must be a\nfixed-size value or a slice of fixed-size values, or a pointer to such data.\nBoolean values encode as one byte: 1 for true, and 0 for false. Bytes\nwritten to w are encoded using the specified byte order and read from\nsuccessive fields of the data. When writing structs, zero values are written\nfor fields with blank (_) field names.
WriteAll Writer.WriteAll(records [][]string) error\n
WriteAt File.WriteAt(b []byte, off int64) (n int, err error)\n
WriteByte Buffer.WriteByte(c byte) error\n
WriteByte Builder.WriteByte(c byte) error\n
WriteByte Writer.WriteByte(c byte) error\n
WriteCloser io.WriteCloser\nWriteCloser is the interface that groups the basic Write and Close methods.\n
WriteFile ioutil.WriteFile(filename string, data []byte, perm fs.FileMode) error\nWriteFile writes data to a file named by filename. If the file does not\nexist, WriteFile creates it with permissions perm (before umask); otherwise\nWriteFile truncates it before writing, without changing permissions.\nAs of Go 1.16, this function simply calls os.WriteFile.
WriteFile os.WriteFile(name string, data []byte, perm FileMode) error\nWriteFile writes data to the named file, creating it if necessary. If the\nfile does not exist, WriteFile creates it with permissions perm (before\numask); otherwise WriteFile truncates it before writing, without changing\npermissions.
WriteMsgIP IPConn.WriteMsgIP(b, oob []byte, addr *IPAddr) (n, oobn int, err error)\n
WriteMsgUDP UDPConn.WriteMsgUDP(b, oob []byte, addr *UDPAddr) (n, oobn int, err error)\n
WriteMsgUnix UnixConn.WriteMsgUnix(b, oob []byte, addr *UnixAddr) (n, oobn int, err error)\n
WriteProxy Request.WriteProxy(w io.Writer) error\n
WriteRune Buffer.WriteRune(r rune) (n int, err error)\n
WriteRune Builder.WriteRune(r rune) (int, error)\n
WriteRune Writer.WriteRune(r rune) (size int, err error)\n
WriteSeeker io.WriteSeeker\nWriteSeeker is the interface that groups the basic Write and Seek methods.\n
WriteString Buffer.WriteString(s string) (n int, err error)\n
WriteString Builder.WriteString(s string) (int, error)\n
WriteString File.WriteString(s string) (n int, err error)\n
WriteString Replacer.WriteString(w io.Writer, s string) (n int, err error)\n
WriteString Writer.WriteString(s string) (int, error)\n
WriteString io.WriteString(w Writer, s string) (n int, err error)\nWriteString writes the contents of the string s to w, which accepts a slice\nof bytes. If w implements StringWriter, its WriteString method is invoked\ndirectly. Otherwise, w.Write is called exactly once.
WriteTo Buffer.WriteTo(w io.Writer) (n int64, err error)\n
WriteTo IPConn.WriteTo(b []byte, addr Addr) (int, error)\n
WriteTo Reader.WriteTo(w io.Writer) (n int64, err error)\n
WriteTo Reader.WriteTo(w io.Writer) (n int64, err error)\n
WriteTo Reader.WriteTo(w io.Writer) (n int64, err error)\n
WriteTo UDPConn.WriteTo(b []byte, addr Addr) (int, error)\n
WriteTo UnixConn.WriteTo(b []byte, addr Addr) (int, error)\n
WriteToIP IPConn.WriteToIP(b []byte, addr *IPAddr) (int, error)\n
WriteToUDP UDPConn.WriteToUDP(b []byte, addr *UDPAddr) (int, error)\n
WriteToUnix UnixConn.WriteToUnix(b []byte, addr *UnixAddr) (int, error)\n
Writer Logger.Writer() io.Writer\n
Writer bufio.Writer\nWriter implements buffering for an io.Writer object. If an error occurs\nwriting to a Writer, no more data will be accepted and all subsequent\nwrites, and Flush, will return the error. After all data has been written,\nthe client should call the Flush method to guarantee all data has been\nforwarded to the underlying io.Writer.\n
Writer csv.Writer\nA Writer writes records using CSV encoding.\n\nAs returned by NewWriter, a Writer writes records terminated by a newline\nand uses ',' as the field delimiter. The exported fields can be changed to\ncustomize the details before the first call to Write or WriteAll.\n\nComma is the field delimiter.\n\nIf UseCRLF is true, the Writer ends each output line with \r\n instead of\n\n.\n\nThe writes of individual records are buffered. After all data has been\nwritten, the client should call the Flush method to guarantee all data has\nbeen forwarded to the underlying io.Writer. Any errors that occurred should\nbe checked by calling the Error method.\n
Writer io.Writer\nWriter is the interface that wraps the basic Write method.\n\nWrite writes len(p) bytes from p to the underlying data stream. It returns\nthe number of bytes written from p (0 <= n <= len(p)) and any error\nencountered that caused the write to stop early. Write must return a non-nil\nerror if it returns n < len(p). Write must not modify the slice data, even\ntemporarily.\n\nImplementations must not retain p.\n
Writer log.Writer() io.Writer\nWriter returns the output destination for the standard logger.
WriterAt io.WriterAt\nWriterAt is the interface that wraps the basic WriteAt method.\n\nWriteAt writes len(p) bytes from p to the underlying data stream at offset\noff. It returns the number of bytes written from p (0 <= n <= len(p)) and\nany error encountered that caused the write to stop early. WriteAt must\nreturn a non-nil error if it returns n < len(p).\n\nIf WriteAt is writing to a destination with a seek offset, WriteAt should\nnot affect nor be affected by the underlying seek offset.\n\nClients of WriteAt can execute parallel WriteAt calls on the same\ndestination if the ranges do not overlap.\n\nImplementations must not retain p.\n
WriterTo io.WriterTo\nWriterTo is the interface that wraps the WriteTo method.\n\nWriteTo writes data to w until there's no more data to write or when an\nerror occurs. The return value n is the number of bytes written. Any error\nencountered during the write is also returned.\n\nThe Copy function uses WriterTo if available.\n
Y0 math.Y0(x float64) float64\nY0 returns the order-zero Bessel function of the second kind.\nSpecial cases are:\nY0(+Inf) = 0\nY0(0) = -Inf\nY0(x < 0) = NaN\nY0(NaN) = NaN
Y1 math.Y1(x float64) float64\nY1 returns the order-one Bessel function of the second kind.\nSpecial cases are:\nY1(+Inf) = 0\nY1(0) = -Inf\nY1(x < 0) = NaN\nY1(NaN) = NaN
Year Time.Year() int\n
YearDay Time.YearDay() int\n
Yn math.Yn(n int, x float64) float64\nYn returns the order-n Bessel function of the second kind.\nSpecial cases are:\nYn(n, +Inf) = 0\nYn(n ≥ 0, 0) = -Inf\nYn(n < 0, 0) = +Inf if n is odd, -Inf if n is even\nYn(n, x < 0) = NaN\nYn(n, NaN) = NaN
Zipf rand.Zipf\nA Zipf generates Zipf distributed variates.\n
Zone Time.Zone() (name string, offset int)\n
append append(slice []Type, elems ...Type) []Type\nThe append built-in function appends elements to the end of a slice. If it\nhas sufficient capacity, the destination is resliced to accommodate the new\nelements. If it does not, a new underlying array will be allocated. Append\nreturns the updated slice. It is therefore necessary to store the result of\nappend, often in the variable holding the slice itself:\nslice = append(slice, elem1, elem2)\nslice = append(slice, anotherSlice...)\nAs a special case, it is legal to append a string to a byte slice, like\nthis:\nslice = append([]byte("hello "), "world"...)
cap cap(v Type) int\nThe cap built-in function returns the capacity of v, according to its type:\nArray: the number of elements in v (same as len(v)).\nPointer to array: the number of elements in *v (same as len(v)).\nSlice: the maximum length the slice can reach when resliced;\nif v is nil, cap(v) is zero.\nChannel: the channel buffer capacity, in units of elements;\nif v is nil, cap(v) is zero.\nFor some arguments, such as a simple array expression, the result can be a\nconstant. See the Go language specification's "Length and capacity" section\nfor details.
cap cap(v Type) int\nThe cap built-in function returns the capacity of v, according to its type:\nArray: the number of elements in v (same as len(v)).\nPointer to array: the number of elements in *v (same as len(v)).\nSlice: the maximum length the slice can reach when resliced;\nif v is nil, cap(v) is zero.\nChannel: the channel buffer capacity, in units of elements;\nif v is nil, cap(v) is zero.\nFor some arguments, such as a simple array expression, the result can be a\nconstant. See the Go language specification's "Length and capacity" section\nfor details.
close close(c chan<- Type)\nThe close built-in function closes a channel, which must be either\nbidirectional or send-only. It should be executed only by the sender, never\nthe receiver, and has the effect of shutting down the channel after the last\nsent value is received. After the last value has been received from a closed\nchannel c, any receive from c will succeed without blocking, returning the\nzero value for the channel element. The form\nx, ok := <-c\nwill also set ok to false for a closed channel.
complex complex(r, i FloatType) ComplexType\nThe complex built-in function constructs a complex value from two\nfloating-point values. The real and imaginary parts must be of the same\nsize, either float32 or float64 (or assignable to them), and the return\nvalue will be the corresponding complex type (complex64 for float32,\ncomplex128 for float64).
copy copy(dst, src []Type) int\nThe copy built-in function copies elements from a source slice into a\ndestination slice. (As a special case, it also will copy bytes from a string\nto a slice of bytes.) The source and destination may overlap. Copy returns\nthe number of elements copied, which will be the minimum of len(src) and\nlen(dst).
copy copy(dst, src []Type) int\nThe copy built-in function copies elements from a source slice into a\ndestination slice. (As a special case, it also will copy bytes from a string\nto a slice of bytes.) The source and destination may overlap. Copy returns\nthe number of elements copied, which will be the minimum of len(src) and\nlen(dst).
delete delete(m map[Type]Type1, key Type)\nThe delete built-in function deletes the element with the specified key\n(m[key]) from the map. If m is nil or there is no such element, delete is a\nno-op.
error builtin.error\nThe error built-in interface type is the conventional interface for\nrepresenting an error condition, with the nil value representing no error.\n
imag imag(c ComplexType) FloatType\nThe imag built-in function returns the imaginary part of the complex number\nc. The return value will be floating point type corresponding to the type of\nc.
len len(v Type) int\nThe len built-in function returns the length of v, according to its type:\nArray: the number of elements in v.\nPointer to array: the number of elements in *v (even if v is nil).\nSlice, or map: the number of elements in v; if v is nil, len(v) is zero.\nString: the number of bytes in v.\nChannel: the number of elements queued (unread) in the channel buffer;\nif v is nil, len(v) is zero.\nFor some arguments, such as a string literal or a simple array expression,\nthe result can be a constant. See the Go language specification's "Length\nand capacity" section for details.
len len(v Type) int\nThe len built-in function returns the length of v, according to its type:\nArray: the number of elements in v.\nPointer to array: the number of elements in *v (even if v is nil).\nSlice, or map: the number of elements in v; if v is nil, len(v) is zero.\nString: the number of bytes in v.\nChannel: the number of elements queued (unread) in the channel buffer;\nif v is nil, len(v) is zero.\nFor some arguments, such as a string literal or a simple array expression,\nthe result can be a constant. See the Go language specification's "Length\nand capacity" section for details.
make make(t Type, size ...IntegerType) Type\nThe make built-in function allocates and initializes an object of type\nslice, map, or chan (only). Like new, the first argument is a type, not a\nvalue. Unlike new, make's return type is the same as the type of its\nargument, not a pointer to it. The specification of the result depends on\nthe type:\nSlice: The size specifies the length. The capacity of the slice is\nequal to its length. A second integer argument may be provided to\nspecify a different capacity; it must be no smaller than the\nlength. For example, make([]int, 0, 10) allocates an underlying array\nof size 10 and returns a slice of length 0 and capacity 10 that is\nbacked by this underlying array.\nMap: An empty map is allocated with enough space to hold the\nspecified number of elements. The size may be omitted, in which case\na small starting size is allocated.\nChannel: The channel's buffer is initialized with the specified\nbuffer capacity. If zero, or the size is omitted, the channel is\nunbuffered.
new new(Type) *Type\nThe new built-in function allocates memory. The first argument is a type,\nnot a value, and the value returned is a pointer to a newly allocated zero\nvalue of that type.
panic panic(v interface{})\nThe panic built-in function stops normal execution of the current goroutine.\nWhen a function F calls panic, normal execution of F stops immediately. Any\nfunctions whose execution was deferred by F are run in the usual way, and\nthen F returns to its caller. To the caller G, the invocation of F then\nbehaves like a call to panic, terminating G's execution and running any\ndeferred functions. This continues until all functions in the executing\ngoroutine have stopped, in reverse order. At that point, the program is\nterminated with a non-zero exit code. This termination sequence is called\npanicking and can be controlled by the built-in function recover.
print print(args ...Type)\nThe print built-in function formats its arguments in an\nimplementation-specific way and writes the result to standard error. Print\nis useful for bootstrapping and debugging; it is not guaranteed to stay in\nthe language.
println println(args ...Type)\nThe println built-in function formats its arguments in an\nimplementation-specific way and writes the result to standard error. Spaces\nare always added between arguments and a newline is appended. Println is\nuseful for bootstrapping and debugging; it is not guaranteed to stay in the\nlanguage.
real real(c ComplexType) FloatType\nThe real built-in function returns the real part of the complex number c.\nThe return value will be floating point type corresponding to the type of c.
recover recover() interface{}\nThe recover built-in function allows a program to manage behavior of a\npanicking goroutine. Executing a call to recover inside a deferred function\n(but not any function called by it) stops the panicking sequence by\nrestoring normal execution and retrieves the error value passed to the call\nof panic. If recover is called outside the deferred function it will not\nstop a panicking sequence. In this case, or when the goroutine is not\npanicking, or if the argument supplied to panic was nil, recover returns\nnil. Thus the return value from recover reports whether the goroutine is\npanicking.
